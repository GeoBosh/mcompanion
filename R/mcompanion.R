## Do not edit this file manually.
## It has been automatically generated from *.org sources.

## basic computational routines for mc-matrices.

mc_matrix <- function(x){ # x is normally the top but may be the full matrix as well
  if(is.matrix(x))        # the returned value is the top or the full matrix, respectively.
    x
  else if(is.vector(x))                       # companion
    matrix(x,nrow=1)
  else
    as.matrix(x)
}

mc_full <- function(x){    # x is the top or the full matrix
  wrk <- mc_matrix(x)
  nc <- ncol(wrk)
  ido <- nc - nrow(wrk)    # here ido=0 when either mcorder=nc or x is the full matrix.
  if(ido>0)
    rbind(wrk, diag(1,nrow=ido,ncol=nc) )
  else if(ido==0)
    wrk
  else
    stop("The top of the multi-companion matrix has more rows than columns.")
}

is_mc_bottom <- function(x){                         # todo: check x is a matrix-like object.
  (nrow(x) <= ncol(x)) && all( x == diag(1, nrow(x), ncol(x)) )
}

mc_order <- function(x){                                           # dali da razresha nc > nr ?
  nr <- nrow(x)
  if(nr != ncol(x)  ||  nr == 0) # 2013-03-26 allow 1x1 matrix; was (nr != ncol(x) || nr == 1)
      stop("multi-companion order is defined for square matrices (at least 1x1) only.")

  for(i in 1:nr){
      if( is_mc_bottom( x[i:nr, 1:nr, drop=FALSE] ) )  # nr == nrow(x) == ncol(x)
          return(i-1)
  }
  return(nr)                   # considers a full matrix a particular case of multi-companion.
}

                                            # begin: companion factorization of MultiCompanion

mc_leftc <- function(x, mo, mo.col){ # written to work with the full matrix or top rows only;
  x <- mc_matrix(x)                  # in the former case arg mo should be used.
  m  <- ncol(x)
  nr <- nrow(x)
  if(missing(mo))
    mo <- nr

  if(nr==1 || mo==1)
    return(x[1,])
  # so, below we have nr >= 2 and mo >= 2

  if(missing(mo.col))
    mo.col <- m

  if(mo.col > m){
      stop("mo.col must be less than or equal to m")
  }else if(mo == 0){
      res <- NA      # todo: anything better here? maybe also warning?
  }else if(mo.col == 0){
      res <- numeric(m)
  }else if(mo <= mo.col){
      wrk <- x[2:mo, (mo.col-mo+2):mo.col, drop=FALSE]
      u <- x[1, (mo.col-mo+2):mo.col]

      res <- numeric(m)
      res[1:(mo-1)] <- qr.solve(t(wrk), u, tol=1e-10) # 22/03/2007: solve(t(wrk),u)
      for(j in mo:mo.col){
          res[j] <- x[1,j-mo+1]
          for(i in 1:(mo-1)){
              res[j] <- res[j] - res[i]*x[i+1,j-mo+1]
          }
      }
  }else if( mo.col < mo ){
      wrk <- x[2:(mo.col+1), 1:mo.col, drop=FALSE]
      u <- x[1, 1:mo.col]
      res <- numeric(m)
                                    # 2013-12-03 todo: the case when wrk is 1x1 and mo.col = 1
      res[1:mo.col] <- qr.solve(t(wrk), u, tol=1e-10)  # solve(t(wrk),u)
  }

  res
}

mc_factorize <- function(x,mo,mo.col){                      # 2013--03-26 streamlining somewhat
  res <- mc_matrix(x)       # 2013-03-26 as.matrix(x)
  if(missing(mo.col))                     # 2013-03-26 flag <- missing(mo.col)
      mo.col <- ncol(res)
  for(i in 1:mo){
    res[i,] <- mc_leftc(x[i:mo, , drop=FALSE], mo.col=mo.col)
  }
  res[1:mo, , drop=FALSE]    # 2014-10-20 was: res[1:mo,]
}


mc_from_factors <- function(x){        # this should not use MultiCompanion objects!
  mo <- if(is.vector(x))
          1
        else
          nrow(x)

  if(mo==1){
    res <- mCompanion(x)
  }else{
    res <- mCompanion(x[1,])                    # this is lazy, can be done more economically.
    for(i in 2:mo)
      res <- res %*% mCompanion(x[i,])
  }
  res[1:mo,]                               # returns the top of the multi-companion matrix
}      # todo: (2014-10-20) do we need drop = FALSE here? Probably yes but for the functions
       #                    that use this one it probably doesn't matter.

                                            #   end: companion factorization of MultiCompanion

mc_from_filter <- function(x){     # rows v obraten red ponezhe i-tiyat red saotvestva
                                   # na i-tiya sezon, a faktorite se umnozhavat v obraten red.
                                         # rezultatat e Ftop, kakto pri mc_from_factors.
                   # 2015-02-11 - dobavyam proverka za nrow(x) > ncol(x)
    if(nrow(x) > ncol(x))
        x <- cbind(x, matrix(0, nrow = nrow(x), ncol = nrow(x) - ncol(x)))

    mc_from_factors(x[nrow(x):1,])
}



## formerly mC.stable
mcStable <- function(x){           # x is a full matrix or the top of a multi-companion matrix
  x <- mc_full(x)
  wrk <- eigen(x,only.values=TRUE)
  all(abs(wrk$values) < 1)
}

setGeneric("mcStable")

make_mcgev <- function(eigval, co, v, what.co = "bottom"){
    n <- length(v)
    k <- length(co)
    res <- numeric(n)

    if(what.co == "bottom"){
        res[(n-k+1):n] <- co
        if(k < n) # 4/4/2007
            for(i in (n-k):1){
                res[i] <- eigval * res[i+k] + v[i+k]
            }
    }else{  # "top"                 note: if eigval=0 then only the bottom is non-zero!
        res[1:k] <- co
        if(k<n){ # 4/4/2007
            if(eigval == 0) # 2104-06-03 here because if k=n "top" and "bottom" are equivalent
                stop("eigval must be different from 0 when what.co = 'top'")
            for(i in (k+1):n){
                res[i] <- (res[i-k] - v[i]) / eigval
            }
        }
    }
    res
}

make_mcev <- function(eigval, co, dim, what.co = "bottom"){
    n <- dim
    k <- length(co)
    res <- numeric(n)

    if(what.co == "bottom"){
        res[(n-k+1):n] <- co
        if(k < n) # 4/4/2007
            for(i in (n-k):1){
                res[i] <- eigval * res[i+k]
            }
    }else{  # "top"                  but if eigval=0 then only the bottom is non-zero!
        res[1:k] <- co
        ## 4/4/2007 for(i in (k+1):n)
        if(k<n){
            if(eigval == 0) # 2014-06-03 here because if k=n "top" and "bottom" are equivalent
                stop("eigval must be different from 0 when what.co = 'top'")
            for(i in (k+1):n){   # 4/4/2007
                res[i] <-  res[i-k] /eigval            # eigval must be different from 0 here!
            }
        }
    }
    res
}

#                # 2015-12-26 renamed from mc.0chain.triang() - not specific for eigenvalue zero
# mc_chains_triangulate <- function(chains, mo, mo.col){
#     m <- length(chains)
#     stopifnot(m <= mo)                                     # for mc matrix we must have m<=mo
#     if(m==1)
#         return(chains)
# 
#     dim <- NROW(chains[[1]])
#     len <- sapply(chains, NCOL)
# 
#     wrk <- chains[ sort(len, method = "sh", index = TRUE, decreasing = TRUE)$ix ]# stable sort
#     for(i in 1:(m - 1)){
#         evec <- wrk[[i]][ , 1]
#         # evec[j] ==0 for j<=dim-mo, no za da izbyagna iznenadi vklyuchvam testa po-dolu. !!!
#                                         #testing equality to zero, may be problematic
#         ii <- match(TRUE, evec != 0 & 1:dim > dim - mo)
#         for(j in (i + 1):m){                    # todo:  look for the largest abs() or similar
#             a <- wrk[[j]][ii,1] / evec[ii]          # for stability?
#             wrk[[j]] <- wrk[[j]] - a * wrk[[i]][,1:ncol(wrk[[j]])]
#             wrk[[j]][ii,1] <- 0                      # to ensure comparison with zero works ok
#         }
#     }
#     wrk
# }

null_complement <- function(m, universe = NULL, na.allow = TRUE){
    ## edited 2015-07-10 to give error when both 'm' and 'universe' are NULL
    if(na.allow && anyNA(m)){  # todo: this is probaly sensible only if all elem. of m are
                               #       NA; could be refined, at least for the case when some
                               #       columns of m are free from NA's
        if(isNA(m)){
            if(is.null(universe))
                ## Cannot determine the dimension of the space,  so error.
                stop("One of 'm' and 'universe' must be non-NULL.")
            else
                return(universe)
        }##else m is assumed a matrix

        if(is.null(universe))
            universe <- diag(nrow = NROW(m))

        if(all(is.na(m)))
            res <- matrix(NA_real_, nrow = NROW(m), ncol = ncol(universe) - NCOL(m))
        else{
            ## Zasega ostavyam kakto gornoto, vzh. komentara po-dolu.
            ##
            res <- matrix(NA_real_, nrow = NROW(m), ncol = ncol(universe) - NCOL(m))
            ##
            ## TODO: rezultatat e lineyni komb. na kolonite na u2, ako vsyaka ot kolonite na
            ## 'm' e ili iztsyalo NA ili bez NA's. Inache (ako ima koloni s chisla i NA)
            ## tryabva oste rabota. PRI VSYAKO POLOZHENIE mi tryabva klas za parametrizirani
            ## pod-prostranstva, napr. e edin element za parametrite i vtori za bazisa.
            ##       flags <- apply(m, 2, function(x) any(is.na(x)))
            ##       wrk <- m[ , !flags] # select columns without any NA's
            ##       u2 <- null_complement(wrk, universe = universe, na.allow = FALSE)
        }

        return(res)
    }

    if(is.null(universe))
        return( Null(m) )

    Null( cbind(m, Null(universe)) )   # compl of A w.r.t. B, where A is subspace of B
                                       # equals complement of (A union B_orth)
} # for additional comments on orthogonal spaces see the comments at the end of this file.

                                             # parametric_gev_core
spec_core <- function(mo, evalue, heights,
                      ubasis = NULL,
                      uorth = NULL,
                      evspace = NULL
                      ){   # mo - mc-order

    heights <- sort(heights, decreasing = TRUE) # heights of chains, a.k.a. block lengths
    hmax <- heights[1]   # maximal height
    s <- length(heights)  # no. of chains corresponding to evalue same as number of e.vectors

    stopifnot(s <= mo) # s - dim of ev.space?
                                        # ni[i] is the number of chains with height at least i
                                        # in particular, ni[1] is the number of e.vec.
    ni <- sapply(1:hmax, function(x) sum(heights >= x) )

    talli <- c(ni[-1],0)     # talli[i] is the number of vectors in chain i that are part of
                             #          taller chains

    mi <- ni - talli  # mi[i] is the number of over-hanging vectors in chain i
                      #    (i.e. vectors that are the last in their chains)

    full.core.basis <- diag(nrow = mo) # todo: consider other spaces, e.g. Haan

                       # consider this fixed, usually ev.universe.basis is the standard basis.
                       #     these two are considered fixed
    ev.universe.basis <-
        if(is.null(ubasis))           # matrix(NA_real_, nrow = mo, ncol = s)
            full.core.basis
        else
            ubasis

                                                          # todo: is ev.uninverse.orth needed?
    ev.uninverse.orth <-        # matrix(NA_real_, nrow = mo, ncol = mo - s)
        if(is.null(uorth))
            Null(ev.universe.basis)
        else
            uorth

                                               # if ev.space coincides with ev.universe, then
                                               # ev.space.orth contains only the zero vector
    ev.space <-       # ncol(evspace)  == s?
        if(!is.null(evspace))
            evspace
        else if(s == ncol(ev.universe.basis)) # number of e.v. equal to dim of allowed space
            ev.universe.basis          # this covers the case s = mo
        else if(s <  ncol(ev.universe.basis))
            matrix(NA_real_, nrow = mo, ncol = s)
        else
            stop("Dimension of allowed e.v. space should be >= no. of e.vectors")


                      # this is orth. w.r.t. "full space", which maybe larger than ev.universe
    ev.space.orth <-
        if(anyNA(ev.space))  # todo: this could be more refined; use null Complement, i.e.
                             # replace with something like:
                             #     null_complement(ev.space, universe = full.core.basis)
            matrix(NA_real_, nrow = mo, ncol = ncol(full.core.basis) - s)
        else
            Null(ev.space)

    evso.dim <- ncol(ev.space.orth) # space for the cores of hanging vectors

    sp.tall <- vector(length = hmax, mode = "list")
    sp.hang <- vector(length = hmax, mode = "list")

    for(i in 1:hmax){
        sp.tall[[i]] <- if(talli[i] > 0)
                            matrix(NA_real_, nrow = mo, ncol = talli[i])
                        else
                            NA
        sp.hang[[i]] <- if(mi[i] > 0)
                            matrix(NA_real_, nrow = mo, ncol = mi[i])
                        else
                            NA
    }

    param.tall <- vector(length = hmax, mode = "list")
    param.hang <- vector(length = hmax, mode = "list")

    ## the cores of the hanging vectors are in ev.space.orth
    for(i in 1:hmax){
        ## for now the param tails are same as sp.tail
        param.tall[[i]] <- if(talli[i] > 0)
                               matrix(NA_real_, nrow = mo, ncol = talli[i])
                           else
                               NA
    }

    ev.space.locorth <- # todo: this whole if-else may be can be replaced with null_complement
        if(anyNA(ev.space)){  # todo: this could be more refined
            if(isNA(param.tall[[1]]))
                matrix(NA_real_, nrow = mo, ncol = ncol(ev.space))
            else
                matrix(NA_real_, nrow = mo, ncol = ncol(ev.space) - ncol(param.tall[[1]]))
        }else{
            if(isNA(param.tall[[1]]))
                ev.space
            else
                null_complement(param.tall[[1]], universe = ev.space)
        }


    for(i in 1:hmax){
        param.hang[[i]] <-
            if(mi[i] > 0){
                if(evso.dim == 0 && i >= 2) # if evso.dim = 0 these cores can be set to zero
                             # matrix(numeric(1), nrow = ncol(ev.space.locorth), ncol = mi[i])
                    matrix(numeric(1), nrow = 0, ncol = mi[i])
                else
                    matrix(NA_real_, nrow = ncol(ev.space.locorth), ncol = mi[i])
            }else
                NA

    }





    core.vectors <- vector(length = hmax, mode = "list")

    ## e.v.
    i <- 1
    if(!isNA(sp.tall[[i]])){
        v.tall <- sp.tall[[i]]
    }else
        v.tall <- NA

    if(!isNA(sp.hang[[i]])){
        if(nrow(param.hang[[i]]) == 0){
            if(ncol(ev.space.orth) == 0)
                v.hang <- ev.space.locorth # ????????? matrix( ev.space.orth
            else
                v.hang <- ev.space.orth
        }else
            v.hang <- sp.hang[[i]] %*% param.hang[[i]]
    }else
        v.hang <- NA


    ## krapka; TODO: make more refined!
    ## if the eigenvectors span the ev universe and all heights are the same,
    ##     the e.v. can be considered fixed
    if(all(heights == heights[1]) &&
       ncol(ev.space) == ncol(ev.universe.basis)){

        v.tall <- if(all(is.na(ev.space)))
                      ev.universe.basis
                  else
                      ev.space
    }


    v.both <-
        if(!isNA(v.tall)){
            if(!isNA(v.hang))
                cbind(v.tall, v.hang)
            else
                v.tall
        }else if(!isNA(v.hang))
            v.hang
        else # both are NA, should not happen
            stop("no vectors for height one!")


    generators <- vector(length = hmax, mode = "list")

    if(ncol(v.both) == ncol(ev.universe.basis) &&
       ncol(v.tall) < ncol(ev.universe.basis)
       ){ # e.v. span the space, so any of v.tall or
                                                 # v.hang determines the other, choose the
                                                 # smaller

        ## FOR TESTING ONLY: setting things to -Inf
        if(ncol(v.tall) <= ncol(v.hang)){ # v.tall are the parameters
            par <- "tall"
            v.hang[] <- Inf # for now, to allow xx.ss handle this case without much change.
            v.tall[] <- -Inf    # for now, see the comment above
                                # todo: derive from others?
        }else{
            par <- "hang"
            v.tall[] <- Inf    # for now, see the comment above
            v.hang[] <- -Inf    # for now, to allow xx.ss handle this case without too much
        }
        v.both <- cbind(v.tall, v.hang)

        generators[[1]] <- list(param = "tall", tall = v.tall, hang = v.hang,
                                universe = ev.universe.basis, method = "complement")

    }

    core.vectors[[i]] <- list(tall = v.tall, hang = v.hang, both = v.both)
                # i=1 here

    ## g.e.v. i >= 2
    for(i in (1:hmax)[-1]){
        if(!isNA(sp.tall[[i]])){ # TODO: why not in both cases? (to get logical NA?)
            v.tall <- sp.tall[[i]]
        }else
            v.tall <- NA

        if(!isNA(sp.hang[[i]])){
            if(nrow(param.hang[[i]]) == 0){
                if(i == 1) # ev  ; but TODO: i cannot be one here!
                    if(ncol(ev.space.orth) == 0)
                        v.hang <- ev.space.locorth # ????????? matrix( ev.space.orth
                    else
                        v.hang <- ev.space.orth
                else # gev
                    v.hang <- matrix(numeric(1), nrow = mo, ncol = ncol(param.hang[[i]]))
            }else
                ## 2014-11-24 was: v.hang <- sp.hang[[i]] %*% param.hang[[i]]
                ##  TODO: check  if the change is correct!
                v.hang <- ev.space.locorth %*% param.hang[[i]]
        }else
            v.hang <- NA

        v.both <-
            if(!isNA(v.tall)){
                if(!isNA(v.hang))
                    cbind(v.tall, v.hang)
                else
                    v.tall
            }else if(!isNA(v.hang))
                v.hang
            else # both are NA, should not happen
                stop("no vectors for height i!")

        core.vectors[[i]] <- list(tall = v.tall, hang = v.hang, both = v.both)
    }

    ## TODO: describe what is going on here.
    wrk <- vector(length = s, mode = "list")
    cur.col <- 1
    for(i in 1:s){
        li <- lapply(core.vectors[1:heights[i]],
                     function(x) x$both[ , i, drop = FALSE] )
        wrk[[i]] <- do.call("cbind", li)
    }

    co <- do.call("cbind", wrk)

    list(evalue = evalue, heights = heights,
         co = co, core.vectors = core.vectors,
         param.tall = param.tall,
         param.hang = param.hang,
         generators = generators
         )
}

                                                             # 2014-06-11 substantially edited
mc_chain_scale <- function(ev, subset = NULL, fvec = NULL, fchain = NULL){
    if(is.null(subset)){
        n <- nrow(ev$eigvec)
        subset <- (n - ev$mo + 1) : n
    }else if(is.character(subset) && subset == "top")
        subset <- 1 : ev$mo
    ## else subset must be a vector of integers suitable for indexing

    if(is.null(fvec)){
        fvec <- function(v, ind){
            i <- which.max(abs( v[ind] ))
            v[ind][i]   # todo: check for positive length of ind? (in case v is all NA's)?
        }
    }

    if(is.null(fchain))
        fchain <- function(chain) chain / fvec(chain[ , 1], subset)

    new.chains <- lapply(chains_to_list(ev$eigvec, ev$len.block), fchain)
    ev$eigvec <- do.call("cbind", new.chains)
    ev
}

mc_chain_to_list <- function(ev){
    chains_to_list(ev$eigvec, ev$len.block)
}

mc_chain_subset <- function(ev, chainno){
    indx <- if(all(chainno>0))
                chainno
            else
                (1:length(ev$len.block))[chainno]   # need positive indx for chain_ind()

    if(length(indx)==0)    # empty subset
        return( list() )

    len.block <- ev$len.block[indx]
    evindx <- chain_ind(indx,ev$len.block)
    eigvec    <- ev$eigvec[, evindx, drop=FALSE]
    co <- if(is.null(ev$co))
              NULL
          else
              ev$co[, evindx, drop = FALSE]  # 2015-12-02 was: ev$co[, evindx]

    res <- list( mo        = ev$mo
               , mo.col    = ev$mo.col
               , eigval    = ev$eigval[indx]
               , len.block = len.block
               , eigvec    = eigvec
               , co        = co
                )
    res
}

mc_chain_merge <- function(ev1, ev2){                     # todo:??? merge more than 2 chains?
    if(identical(ev2, list()))
        return(ev1)
    if(identical(ev1, list()))
        return(ev2)

    mo        <- ev1$mo          # must be equal to ev2$mo
    mo.col    <- ev1$mo.col      # must be equal to ev2$mo.col
    eigval    <- c(ev1$eigval, ev2$eigval)
    len.block <- c(ev1$len.block, ev2$len.block)
    eigvec    <- cbind(ev1$eigvec, ev2$eigvec)


    co <- if(!is.null(ev1$co) && !is.null(ev2$co))    # merge the co's if both non-NULL
              cbind(ev1$co, ev2$co)
          else if(is.null(ev1$co) && is.null(ev2$co)) # keep co NULL if both NULL
              NULL
          else if(nrow(eigvec) < mo)               # co is  not usable here, so set it to NULL
              NULL                              # 2015-11-11 TODO: shouldn't this be an error?
          else  # 2015-12-02 was: eigvec[(nrow(eigvec)-mo+1):nrow(eigvec)]
                #                 (surely the intention is to get the bottom mo rows!)
              eigvec[(nrow(eigvec)-mo+1):nrow(eigvec), , drop = FALSE]
                                                    # set co to the bottom, is this ok?
                                                    # maybe do this only if asked explicitly?
                                                    # and signal error otherwise?
    res <- list(  mo        = mo
                , mo.col    = mo.col
                , eigval    = eigval
                , len.block = len.block
                , eigvec    = eigvec
                , co        = co
                )
    res
}

                            # 2015-12-26 removed arguments mo (redundant, use ev$mo) and F0bot
mc_chain_extend <- function(ev, newdim){  # function(ev, mo, newdim)
    indx0 <- which(ev$eigval == 0)       # need more careful test? even better maybe to
                                         # introduce an argument to suply a function for this.
    ev0    <- mc_chain_subset(ev, indx0)
    evnon0 <- mc_chain_subset(ev, if(length(indx0) > 0) -indx0 else 1:length(ev$eigval))

    chnon0 <- mC.non0chain.extend(evnon0, newdim)

    v0 <- chains_to_list(ev0$eigvec, ev0$len.block)
    ch0 <- mc_0chains(newdim, ev$mo, ev$mo.col, v0)

    mc_chain_merge(chnon0, ch0)
}

                                                                  # 2014-06-10 new arg. mo.col
                            # 2015-11-10 new arg. what.co for make_mcev() and make_mcgev(),
                            #            since '...'  is used also in the call of mc_0chains()
                          # 2015-11-10 dobavyam argument 'Mtop' i code za sluchaya mo.col < mo
                          # 2015-11-10 TODO: All this needs streamlining.
                          # 2015-12-25 removed arg. Mtop; use 'co' instead.
## make_mcchains() creates the chains using only make_mcev(), make_mcgev() and mc_0chains().
##    In particular, it doesn't call other low-level chain generating functions.
##    Also, if it calls  mc_0chains() with argument vec0, it always contains at least mo rows,
##      so argument F0bot is not passed on.
make_mcchains <- function(eigval, co, dim, len.block, eigval0 = FALSE, mo.col = NULL,
                          what.co = "bottom", ...){
    if(is(co, "SmallMultiCompanion")){# ignore args eigval, len.block and mo.col in this case
        Mch <- smc_chains(co)     # TODO: overwrite also what.co? (its value shouldn't matter)
        co <- Mch$co
        mo.col <- Mch$mo.col
        len.block <- Mch$len.block
        eigval <- Mch$eigval
    }else{
        if(is.vector(co))
            co <- as.matrix(co, ncol=1)
        if(missing(len.block)){
            len.block <- if(length(eigval)==1)
                             ncol(co)                # TODO: document this! Is this a feature?
                         else
                             rep(1,length(eigval))
        }
        if(length(eigval) != length(len.block))
            stop("Number of eigenvalues does not match number of chains.")
    }

    mo <- nrow(co)

    n.chain <- length(len.block)
    nc <- sum(len.block)
    if(nc > ncol(co))
        stop("Not enough seed coefficients.")
    else if(nc < ncol(co))
        warning("There are too many  seed coefficients, I ignore the excess.")

    ## generate the chains from the seeds using only make_mcev() and make_mcgev().
    ##     todo: for speed this chunk could be implemented in C/C++ (inlining make_xxx)
    xmat <- matrix(0, nrow = dim, ncol = nc)
    kcur <- 0
    for(i in 1:n.chain){
        kcur <- kcur + 1
        ev <- eigval[i]
                                          # 2015-11-10 remove '...' and use explicitly what.co
        xmat[ , kcur] <- make_mcev(ev, co[ , kcur], dim, what.co = what.co)
        if(len.block[i] > 1){
            for(j in 2:len.block[i]){
                v <- xmat[ , kcur]
                kcur <- kcur + 1
                                          # 2015-11-10 remove '...' and use explicitly what.co
                xmat[ , kcur] <- make_mcgev(ev, co[ , kcur], v, what.co = what.co)
            }
        }
    }

    if(is.null(mo.col))             # 2014-06-10 was unconditional
        mo.col <- ncol(xmat)        # 2015-11-11 was: if(missing(mo.col)) mo.col <- ncol(xmat)


    if(ncol(xmat) < dim  &&  eigval0){   # complete with structural  chains of zero eigenvalues
        eval0indx <- which(eigval == 0) # a crude test

        if(length(eval0indx) == 0){ # no zeroes in eigval
            if(mo.col < ncol(xmat))
                stop("Too many vectors (> mo.col) for non-zero eigenvalues.")
                                   # 2014-06-10 was: ... mc_0chains(dim, nrow(co), ncol(xmat))
            wrkvz <- mc_0chains(dim, mo, mo.col)
        }else{                      # zeroes in eigval
            if(sum(len.block[-eval0indx]) > mo.col)
                stop("Too many vectors (> mo.col) for non-zero eigenvalues.")

            vec0 <- vector("list", length(eval0indx))   # collect 0-chains in a list of chains
            for( i in seq(along = eval0indx)){ # 2015-11-10 was: for( i in eval0indx)
                indx0wrk <- chain_ind(eval0indx[i], len.block)
                vec0[[i]] <- xmat[ , indx0wrk, drop=FALSE]
            }
                 # 17/04/2007 was: flag0 <- check0chains(vec0,mo.col)
                 #                 if(!flag0)
                 #                   warning("echains for 0 eigenvalues are not good enough.")

            indx0all <- chain_ind(eval0indx, len.block)

            ## remove chains for 0 eval
            xmat <- xmat[ , -indx0all, drop = FALSE]   # 2015-11-11 xmat <- xmat[ , -indx0all]
            len.block <- len.block[-eval0indx]
            eigval <- eigval[-eval0indx]

                             # 2014-06-10 was: ... mc_0chains(dim, nrow(co), ncol(xmat), vec0)
                                                    # 2015-11-10 also pass "..." to mc_0chains
            wrkvz <- mc_0chains(dim, mo, mo.col, vec0, ...) # note arg. 'vec0' here!

        }
        ## merge the non0- and 0-chains
        xmat      <- cbind(xmat,  wrkvz$eigvec)
        eigval    <- c(eigval,    wrkvz$eigval)
        len.block <- c(len.block, wrkvz$len.block)
    }

    if(sum(len.block) != dim){     
        if(sum(len.block) > dim)     # todo: error, not warning?
            warning("The total length of the Jordan chains is greater than dim!")
        else if(eigval0) # here  sum(len.block) < dim
            warning("The total length of the Jordan chains is smaller than dim.")
    }

    list(eigval = eigval, len.block = len.block, mo = mo, eigvec = xmat, co = co,
         mo.col = mo.col )
}

                 # 18/04/2007 was: make_mcchains(eigval,co,dim,len.block,eigval0=TRUE,what.co)
                 # 2015-11-10 making eigval0 an argument to avoid error in the call to
                 #            make_mcchains() call when eigval0 is also in "..."

  # 2015-11-10 TODO: (..., type = "real", what.res = "matrix", eigval0)
  #                  need to check in pcts if and where this is called with unnamed arguments!
make_mcmatrix <- function(type = "real", what.res = "matrix", ..., eigval0){
    x    <- make_mcchains(eigval0 = TRUE, ...)
    jmat <- Jordan_matrix(x$eigval, x$len.block)
    res  <- from_Jordan(x$eigvec, jmat)

    if(type == "real")
        res <- Re(res)

    if(what.res == "list"){
        x[["mat"]] <- res      # if used together with type="real" ev should be in conj pairs.
        res <- x
    }

    res
}

                            # 2015-12-26 removing argument F0bot and disallowing nrow(ev) < mo
                            #            removing argument mo (it is redundant, use ev$mo)
mC.non0chain.extend <- function(ev, newdim){  # 04/05/2007 x0 => F0bot
    eigvalshort <- ev$eigval # 02/05/2007 ev$values
    eigvecshort <- ev$eigvec #            ev$vectors
    mo          <- ev$mo
    mo.col      <- ev$mo.col
    len.block   <- ev$len.block


    if(is.null(len.block))
        len.block <- rep(1, length(eigvalshort))

    if(is.null(mo.col))
        mo.col <- sum(len.block)

    stopifnot(newdim >= nrow(eigvecshort), # only  extend, not shrink; TODO: allow shrink?
              nrow(eigvecshort) >= mo
              )

    v <- matrix(NA, nrow = newdim, ncol = ncol(eigvecshort))
    v[1:nrow(eigvecshort), 1:ncol(eigvecshort)] <- eigvecshort

    mfr <- max(mo.col+1, mo+1)
    mfill <- if(mfr <= nrow(v))
                 mfr:nrow(v)
             else
                 numeric(0)

    ## # 2015-12-26  commenting this chunk out; see also comments for dropping arg. F0bot
    ##
    ## if(mo.col < mo){      # as.matrix is redundant but %*% may not be defined for its class
    ##     wrk <- # the else part should work right for the "if" as well (less efficiently)
    ##         if(max(len.block) == 1)   # only simple eigenvectors here
    ##             (as.matrix(F0bot) %*% eigvecshort) /
    ##                 matrix(rep(eigvalshort, each = nrow(F0bot)), nrow = nrow(F0bot))
    ##         else
    ##             (as.matrix(F0bot) %*% eigvecshort) %*%
    ##                 solve(Jordan_matrix(eigvalshort, len.block))
    ##                                                         # assumes nrow(F0bot)=mo-mo.col
    ##     v[nrow(eigvecshort)+ 1:nrow(F0bot), 1:ncol(eigvecshort)] <- wrk
    ## }

    ## TODO: if mfill is empty, this if/else chunk does nothing  - check and streamline.
    if( max(len.block)==1 ){   # only simple eigenvectors here
        for( j in mfill ){
            v[j,] <- v[j-mo,]/eigvalshort
        }
    }else{                     # some chains have length greater than 1 here.
        kcur <- 0
        for(i in 1:length(len.block)){
            kcur <- kcur + 1
            for( j in mfill ){                          # parvo zapalvam evector
                v[j,kcur] <- v[j-mo,kcur]/eigvalshort[i]
            }
            if(len.block[i]>1){         # ... then the remaining vectors  in the chain, if any
                for(k in 2:len.block[i]){
                    for( j in mfill ){  # parvo zapalvam evector
                        kcur <- kcur + 1
                        v[j,kcur] <- (v[j-mo,kcur] - v[j,kcur-1] )/eigvalshort[i]
                    }
                }
            }
        }
    }
                                                        # 2015-12-02 added  drop = FALSE below
    list(eigval = eigvalshort, len.block = len.block, mo = mo, eigvec = v,
         co = v[(nrow(v)-mo+1):nrow(v), , drop = FALSE], mo.col = mo.col )
}

## mc_0chains() is the main function here. It performs several steps which are implemented in
## separate functions for convenient development.

                                              # special Jordan chains for the zero eigenvalues
                                        # 2015-12-27 removing argument F0bot
mc_0chains <- function(dim, mo, mo.col, vec0, flagtriang = TRUE){ # , F0bot = NULL
    if(missing(vec0) || identical(vec0,list())){                     # only structural 0chains
        res <- mc.0chain.struct(dim, mo, mo.col)
    }else{                                                    # non-structural 0chains present
        nrvec0 <- nrow(vec0[[1]])
                                          # there is more to test here...  (TODO: this comment
                                          # is from ten years ago. Is it still relevant?)
                                          #
        ## 2015-12-27 commenting out since mc.0chain.dx() does not treat the case mo.col < mo
        ##            completely (for this, the non-0 eigenvectors may be needed).
        ##            argument F0bot is removed too, see above.
        ##
        ##                         # if (nrvec0 != mo.col) then the caller has set or
        ##                         #   calculated the e.v's for the mo x mo block, so we don't
        ##                         #   call mc.0chain.dx in this case even if mo.col < mo
        ## v0 <- if(mo.col < mo  &&  nrvec0 == mo.col)
        ##           mc.0chain.dx(mo, mo.col, chF0top = vec0, F0bot = F0bot)
        ##       else
        ##           vec0
        ##
        v0 <- vec0

        v0 <- if(flagtriang)
                  mc_chains_triangulate(v0, mo, mo.col)

        for(i in seq_along(v0))              # extend to dim the supplied chains, if necessary
            v0[[i]] <- mc.0chain.complete(dim, mo, v0[[i]]) # , F0bot = F0bot

        for( i in seq_along(v0))   # complete each chain with structural vectors, where needed
            v0[[i]] <- mc.0chain.structfill(mo, mo.col, v0[[i]])

                                                  # append whole structural 0chains
        res <- mc.0chain.struct(dim, mo, mo.col, v0)
    }

    res$eigvec <- do.call("cbind", res$chains)
    res
}

               # 2015-12-26 renamed from mc.0chain.triang() - not specific for eigenvalue zero
mc_chains_triangulate <- function(chains, mo, mo.col){
    m <- length(chains)
    stopifnot(m <= mo)                                     # for mc matrix we must have m<=mo
    if(m==1)
        return(chains)

    dim <- NROW(chains[[1]])
    len <- sapply(chains, NCOL)

    wrk <- chains[ sort(len, method = "sh", index = TRUE, decreasing = TRUE)$ix ]# stable sort
    for(i in 1:(m - 1)){
        evec <- wrk[[i]][ , 1]
        # evec[j] ==0 for j<=dim-mo, no za da izbyagna iznenadi vklyuchvam testa po-dolu. !!!
                                        #testing equality to zero, may be problematic
        ii <- match(TRUE, evec != 0 & 1:dim > dim - mo)
        for(j in (i + 1):m){                    # todo:  look for the largest abs() or similar
            a <- wrk[[j]][ii,1] / evec[ii]          # for stability?
            wrk[[j]] <- wrk[[j]] - a * wrk[[i]][,1:ncol(wrk[[j]])]
            wrk[[j]][ii,1] <- 0                      # to ensure comparison with zero works ok
        }
    }
    wrk
}

                                                     # 2015-12-27 removed arg. F0bot
mc.0chain.complete <- function(dim, mo, chain, alt0){# 2014-06-07 some clean up and
    wrk <- chain                                            # bug fixing
    nrold <- nrow(wrk)
    ncold <- ncol(wrk)
    alt0skip <- 0

    ## 2015-12-27 removing the code below for the case nrold < mo. Now require nrold >= mo.
    stopifnot(nrold >= mo)

    ## if(nrold < mo ){                  # dopalvam do mo x mo;    assume nrold == mo.col here
    ##     wrk <- rbind(wrk,
    ##                  cbind(if(ncold > 1)   # no 'else' here; cbind() ignores NULL
    ##                           F0bot %*% chain[,2:ncold],
    ##                        numeric(nrow(F0bot)) )
    ##                  )                          # nrow(F0bot) should be equal to mo - nrold
    ##     if(!missing(alt0)){
    ##         wrk[(nrold+1):mo,ncold] <- alt0[1:(mo-nrold)]
    ##         alt0skip <- 1 : (mo - nrold)  # 2014-06-07 was: mo-nrold; not sure about the
    ##     }                                 #  intention but the old value cannot be correct!
    ##     tmp <- F0bot %*% chain[,1]
    ##     if(any(tmp!=0))                # todo: a better check here?
    ##         wrk <- cbind( c(numeric(nrold),tmp), wrk )
    ##
    ##     nrold <- nrow(wrk)                  # updates nrold and ncold !!!
    ##     ncold <- ncol(wrk)                       # update alt0 as well?  ???
    ## }


    if(dim > nrold){     # extend
        nrdiff <- dim - nrold
        ncdiff <- ceiling(nrdiff/mo)     # 10/05/2007: nrold replaces dim below
                # 2014-06-07 was wrong:
                #          if( nrdiff %% mo  > 0 && all( wrk[nrold-mo + 1:ncdiff , 1] == 0 ) )
        if( nrdiff %% mo  > 0 && all( wrk[nrold-mo + 1:(nrdiff %% mo) , 1] == 0 ) )
            ncdiff <- ncdiff - 1   # shorter chain in this case

        res <- cbind(  matrix(0, nrow=dim, ncol=ncdiff)
                     , rbind(wrk,  matrix(0, nrow=nrdiff, ncol=ncold) ) )

        ncnew <- ncold+ncdiff   # = ncol(res)
        if(!missing(alt0))                            # alternative init for the free elements
            res[(nrold+1):dim,ncnew] <- alt0[-alt0skip]

        ## 2015-12-26 TODO: Tova e krapka sled vavezhdaneto na small multi-companion for
        ##                  mo.col<mo.  Tozi klon predi ne se e izpalnyaval veroyatno poradi
        ##                  strukturni 0 v smc.
        ##            Proveri i vzh dali mozhe struturni nuli pak da ne idvat tuk.
        if(ncnew > 1){
            wrkrows <- nrold+ 1:nrdiff
            for(i in (ncnew-1):(ncdiff+1) ){
                res[wrkrows,i] <- res[wrkrows - mo,i+1]
            }

            for(i in ncdiff:1 ){ # vsastnost tozi for mozhe da e ot (dim-1):1, praveyki
                                 # predishniya for izlishen. Tova e vazmozhno ponezhe ako
                                 # chain e naistina 0ev veriga tya udovletvoryava tezi
                                 # usloviya i za dadenite elementi.
                res[(mo+1):dim,i] <- res[1:(dim-mo),i+1]
            }
        }
    }else if(dim < nrold){   # shrink
        res <- wrk[1:dim, , drop = FALSE]
        while( all(res[ , 1] == 0) )     # drop leading columns of zeroes, if present.
            res <- res[ , -1, drop = FALSE]   # 2014-06-07 was: res[,-1]
    }else{ # dim == nrold
        res <- wrk
    }

    res
}

                                # v0 may be different for different gen.ev's, not implemented.
mc.0chain.structfill <- function(mo, mo.col, chain, v0 = rep(0,mo)){
    wrk <- cbind(chain)  # in case chain is a  vector
    if(nrow(wrk) <= mo)                  # dim <= mo:  if dim == mo, nothing to append;
        return(wrk)                      #             while dim < mo is probably an error.

    m <- ncol(wrk)  # m must be greater than 0,
    k <- 1:min(mo.col + mo, nrow(wrk))
    while(all(wrk[k, m] == 0) && any(wrk[-(1:mo), m] != 0)){
        wrk <- cbind(wrk, c(wrk[-(1:mo), m], v0))
        m <- m + 1
    }
    wrk
}

                                                       # append (structural) 0evecs, if needed
    # 04/05/2007 smenyam formata na rezultata, pravya go da e kato na mc.0chain.structObsolete
                                                                    # 2014-06-07 new arg. sort
mc.0chain.struct <- function(dim, mo, mo.col, chains = list(), sort = TRUE){
    m <- length(chains) # number of chains on input; if m == mo, then chains has the maximal
                        #     possible number of 0chains but we do not return as there may be
                        #     more 0vectors to be included.
    if(dim > mo.col){
        ## length(strupos) == min(mo, dim - mo.col), max number of structural 0chains
        if(m == 0){#patch; ensures largest blocks come first here, without changing other code
            strupos <- mo.col + (1:min(mo, dim - mo.col))
            wrkindx <- seq_along(strupos)   # 2014-05-31 was: strupos
        }else{
            strupos <- (max(mo.col, dim-mo) + 1) : dim

            moreindx <- numeric(0)
            for(i in 1:m){
                evec <- chains[[i]][ , 1]
                ix <- match(TRUE, evec != 0 ) # assumes triangulation; also. needs more care
                moreindx <- c(moreindx, ix)
            }

            wrk <- match(strupos, moreindx)
            wrk <- is.na(wrk)     # wrk[i] is TRUE  if strupos[i] is not found in moreindx.

            wrkindx <- which(wrk) # strupos[ wrkindx[i] ]  is not in moreindx.
        }

        ident <- diag(dim)
        moduli <- c(rep(-1, mo.col), ((mo.col+1):dim) %% mo)
        newchains <- lapply(wrkindx,
                            function(ind){
                                pos <- which(moduli  ==  strupos[ind] %% mo)
                                ident[ , rev(pos), drop = FALSE]
                            })
        chains <- c(chains, newchains)

        if(sort){            # 2014-06-07 sort the chains in descending order of their lengths
            indx <- order(sapply(chains, NCOL), decreasing = TRUE)
            chains <- chains[indx]
        }

    }else if(dim < mo.col){
        stop("dim must be >= mo.col")
    }#else dim == mo.col (nothing to add); # 2014-05-31 - return a list as in the other cases.

    eigval <- numeric(length(chains))
    len.block <- if(length(chains) > 0)        # 2014-10-31: inserted the 'if' clause
                     sapply(chains, NCOL)
                 else integer(0)   # sapply would give list() in this case

                                        # TODO: a check for the overall lengths of the chains?
                                        # TODO: insert mo and mo.col in the list?
    list(eigval = eigval, len.block = len.block, chains = chains)
}

.to_chains <- function(x, len.block){                                         # 2015-11-03 new
    pos <- c(0, cumsum(len.block)) # pos[i] + 1 is the index of the i-th eigvec
    lapply(1:length(len.block), function(i) x[ pos[i] + 1:len.block[i] ] )
}

.ev_ind <- function(x, len.block){
    pos <- c(0, cumsum(len.block)[-length(len.block)] )
    pos + 1  # pos[i] + 1 is the index of the i-th eigvec
}

Jordan_matrix <- function(eigval, len.block){
    if(missing(len.block))       # dali da obrabotvam otdelno sluchaya na skalaren eigval?
        return(diag(eigval))

    stopifnot(length(len.block) == length(eigval),  # matching lengths
              all(len.block > 0)                    # positive dimensions of jordan blocks
              )

    n <- sum(len.block) # dimension of the matrix

    res <- diag(rep(eigval, times = len.block), nrow = n, ncol = n)
    r <- cumsum(c(1, len.block))
    for(i in seq_along(eigval)){   # 2015-10-23 was: 1:length(eigval)
        if(len.block[i] > 1){
            rows <- r[i] + 0:(len.block[i] - 2)
            indmat <- matrix(c(rows, rows + 1), ncol = 2)
            res[indmat] <- 1
        }
    }
    res
}

Jordan_submatrix <- function(eigval, len.block, nrow, from.row = 1){
    jmat <- Jordan_matrix(eigval, len.block)
    to.row <- from.row + nrow(jmat) - 1
    stopifnot(from.row > 0, to.row <= nrow)

    res <- matrix(0, nrow, ncol(jmat))

    res[from.row:to.row, ] <- jmat

    res
}

from_Jordan <- function(x, jmat, ...){ # 2015-10-23 renamed and added arg. "..."
                           # F=res = XJX^(-1) => FX = XJ => X'F'=(XJ)' => F' = solve(X',(XJ)')
                           # res <- x %*% jmat %*% solve(x)
    res <- t(  solve( t(x), t(x %*% jmat        ) )  )

                                # Some tests of the difference between the two variants for F.
                                # print(res)
                                # print(zapsmall(Re(res)))
                                # print(x %*% diag(eigval) %*% solve(x))
                                #
                                # tmp <- res - x %*% diag(eigval) %*% solve(x)
                                # print(Mod(tmp)/Mod(res))
    res
}

j2mat <- function(x){  # seems unused; TODO: remove or rename
    j <- Jordan_matrix(x$eigval, x$len.block)
    from_Jordan(x$eigvec, j)
}

chain_ind <- function(chainno, len.block){                            # popravena na 18/04/2007
    tmp <- c(0, cumsum(len.block))
    indx <- numeric(0)
    for( i in chainno)
        indx <- c(indx, tmp[i] + 1:len.block[i])
    indx
}

chains_to_list <- function(vectors, heights){
    m <- length(heights)
    if(m == 0)
        return(list())

    prev <- c(0, cumsum(heights))
    res <- vector(m, mode="list")
    for( i in 1:m)
        res[[i]] <- vectors[ , prev[i]+ 1:heights[i], drop=FALSE ]

    res
}

               # 2015-12-26 renamed from mc.0chain.transf() - the algorithm is not specific
               #            to the zero-eigenvalues and to mc-chains. It assumes however that
               #            only the eigenvectors may be linearly dependent. The word
               #            "simple" in the name reflects this.
               # TODO: make a version, say reduce_chains(), which reduces also the
               #       generalised e.v.'s
                                                # 2015-11-07 complete overhaul and bug fixing.
reduce_chains_simple <- function(chains, sort = TRUE){        # 09/05/2007 - palna prerabotka.
    ev <- matrix(0, nrow = nrow(chains[[1]]), ncol = 0) # chains must have at least 1  element
    res <- list()
    while(length(chains) > 0){
        if(sort){                       # sort the chains in descending order of their lengths
            indx <- order(sapply(chains,NCOL), decreasing=TRUE)
            chains <- chains[indx, drop = FALSE]
            sort <- FALSE # once sorted, no need for further sort unless a chain is inserted
        }                 # back in 'chains'
        chnew <- chains[[1]]
        chains <- chains[-1]

        if(all(chnew[ , 1] == 0)){  # TODO: more refined test?
            if( NCOL(chnew) == 1 )
                next
            else
                chnew <- chnew[ , -1, drop = FALSE]
        }else if( ncol(ev) > 0 ){
                        ## qr of the transposed matrix is needed since if V is the matrix of
                        ## eigenvectors and V^T=QR, then Q^TV^T = R and each row of Q^TV^T is
                        ## a linear combination of the eigenvectors.  Each row of Q^T (or
                        ## column of Q) gives the coefficients of the corresponding linear
                        ## combination. Hence the change below. (but check!!!)
                        ## changed on 2/8/2007 tmp <- qr(cbind(ev,chnew[,1]))
            tmp <- qr(t(cbind(ev, chnew[,1])))                    # evcur <- chnew[,1]
            if(tmp$rank <= ncol(ev)){                      # evcur is linearly dependent on ev
                if( NCOL(chnew) == 1 ) # the chain consists of 1 ev, drop it,
                    next               #           lin.dep. on previous ev's

                chnew <- chnew[ , -1, drop = FALSE]                     # drop the ev
                r <-  qr.Q(tmp, complete = TRUE)[ , tmp$rank+1] # dobre li e complete=TRUE ???
                                        # 2015-11-07 TODO: maybe the last column when
                                        #                 complete=FALSE gives the same result
                nev <- ncol(ev)
                          ## 2015-11-07 TODO: shouldn't this be nev:1 and not (nev-1):1 ?!
                          ##                  even more clearly, nev is equal to the number of
                          ##                  rows of Q (check), so, the length of r is nev+1.
                          ## Attention: if this note is correct, we should have
                          ##       chnew <- r[nev+1] * chnew
                          #chnew <- r[nev] * chnew
                          #for(j in (nev-1):1)
                chnew <- r[nev+1] * chnew               # rotate chnew to make it proper chain
                for(j in (nev):1)
                    chnew <- chnew + r[j] * res[[j]][ , 2:(ncol(chnew)+1), drop = FALSE]

                if(ncol(chnew) < ncol(chains[[1]]) ){ # insert the current chain back
                    chains <- c(list(chnew), chains)
                    sort <- TRUE                      # needs sorting again...
                    next    # chnew has smaller number of columns, hence no infinite loop here
                }
            }
        }
        res <- c(res, list(chnew))
        ev <- cbind(ev, chnew[ , 1])
    }

    res
}

rblockmult <- function(x,b){  # 2014-05-24 generalise to non-square b
    m <- nrow(b)
    n <- ncol(b)
    stopifnot(ncol(x) %% m == 0)   # 2014-05-24
    r <- ncol(x)/m

    res <- matrix(0, nrow = nrow(x), ncol = r * ncol(b))
    for(i in 0:(r-1))
        res[ , i*n + 1:n] <- x[ , i*m + 1:m] %*% b
    res
}

## new: 2015-03-25
permute_var <- function(mat, perm = nrow(mat):1){   ## TODO: seems unused!
    res <- mat[perm, perm]

    if(mode(mat) == "numeric"){ # the above works for non-numeric matrices, as well.
        P <- as(perm, "pMatrix")  # lazy; todo: see also invPerm()
        res2 <- P %*% mat %*% t(P)
        stopifnot(all(res == res2))
    }

    res
}

permute_synch <- function(param, perm){
    if(missing(perm)){
        n <- .rnrow(param)
        perm = n:1
    }
    P <- as(perm, "pMatrix")  # lazy; todo: see also invPerm()

    fu <- function(x){
        if(is.list(x)){
            for(i in seq(along = x))  # 2015-12-30 was: 1:length(x)
                x[[i]] <- fu(x[[i]])
        }else if(is.matrix(x))
             x <- P %*% x %*% t(P)
        else
             x <- P %*% x  # in case some components are vectors
        x
    }

    fu(param)
}

.rnrow <- function(x){
    if(is.list(x))
        Recall(x[[1]])
    else
        NROW(x) # 2015-12-30 was: nrow(x)
}

## new: 2015-03-25
.ldl <- function(x){
    R <- chol(x)
    sqrtD <- diag(R)
    d <- sqrtD^2   # lowercase d to emphasise that this is only the diagonal.

             # todo: this may fail if x (or L) is (nearly) singular
    R <- R / sqrtD  # uses the recycling rule, i-th row of R is divided by sqrtD_i equivalent
                    # to dividing each row of L by sqrtD_i but slightly more convenient.
    L <- t(R) # t() since chol() returns L'
    diag(L) <- 1 # just to make sure that diagonal contains exact one's.
                                            # theoretically (but not numerically), we have:
                                            #     stopifnot(all(x == L %*% diag(d) %*% t(L) ))
    list(L = L, d = d)
}

.udu <- function(Sigma){
    perm <- seq(nrow(Sigma), 1, by = -1) # 2015-12-30 was nros(Sigma):1, guard agains 0 rows
                               # P  and t(P) are the same here, but for clarity use t(P) below
    P <- as(perm, "pMatrix")  # lazy
    S <- t(P) %*% Sigma %*% P
    wrk <- .ldl(S)

    U <- P %*% wrk$L %*% t(P)
    d <- wrk$d[perm]
                      # todo: the above is very lazy, could be done by simply permuting rows
                      #       and columns. A simple check:
                      #    D <- P %*% diag(wrk$d) %*% t(P)
                      #    stopifnot(all(d == diag(D)))
    list(U = U, d = d)
}

## 2013-11-26 - changing mCsim.pcfilter. This file had not been changed since 2007-07-24!

# n.root - number of non-zero roots. Stepenta (order) na filtara e ravna na n.root.
# po printzip order mozhe da bade vector, no v momenta tyabva da e skalar.

             # 2013-11-26 - new argument mo.col;
             #              allow n.root < order (before, it had been assumed equal to order)
             #
             # 2014-10-21 renamed mCsim.pcfilter to sim_pcfilter;
             #            keeping mCsim.pcfilter with a warning that it will be removed.
sim_pcfilter <- function(period, n.root, order=n.root, mo.col, ...){
  if(missing(n.root))
    n.root <- max(order)    # pretsiziray kogato vavedesh vazmozhnost order da e vektor.
                            # 2013-11-26 order => max(order)
    ## 2013-11-26
    #if(order <= period){
    #  mo.col <- order
    #  # 12/05/2007 m <- period + 1 # krapka, za da mozhe dim da e po-golyamo ot multi-order.
    #                     # programite na nisko nivo tryabva da se nagodyat da tretirat
    #                     # tazi vazmozhnost.!
    #  m <- period
    #}else{
    #  m <- max(order,period,n.root)
    #  mo.col <- n.root
    #}

  if(missing(mo.col))
      mo.col <- n.root

  m <- max(order, period, n.root)

  wrk <- sim_mc(m, period, mo.col, ...)
  a <- mc_factorize(wrk$mat, period, mo.col)

  wrk$pcfilter <- a[period:1, 1:mo.col, drop=FALSE] # reverse the order since F is factored
                                                    # as F=Ad*...*A2*A1 with Ai for season i.
  wrk
}

## 2014-10-21 moved sim_real, sim_complex and sim_numbers to gbutils.

## 2015-10-18  renamed mCsim.co to sim_mcseeds
## 2015-10-26 new: argarg with a default in (0,pi)
## 2015-12-02 renamed from sim_mcseeds() to sim_chains()

##            !!! Renamed arguments: mo => dim, co => vectors, len.block => heights
##                Now type, vectors and heights default to NULL and checks with missing() are
##                replaced by checks with is.null().
##
## TODO: dovarshi, proveryavay za non-singular, mozhe bi arg. za condition number;
##                 normalizatsiya, kanonizatsiya (e.g. za higher chains) i t. n.
sim_chains <- function(dim = nrow(vectors), type = NULL, heights = NULL, vectors = NULL,
                           argarg = list(0, pi), ... ){
    if(is.null(heights))
        heights <- rep(1, if(is.null(vectors)) length(type)
                            else                 ncol(vectors) )

    if(is.null(vectors))  # as.numeric() since sim_numbers() will return complex, if necessary
        vectors <- matrix(as.numeric(NA), nrow = dim, ncol = sum(heights))

    exttype <- if(is.null(type))
                   rep("cp", ncol(vectors))
               else
                   rep(type, times = heights)

    rwrk <- rep(as.numeric(NA), length(vectors))

    alltype <- rep(exttype, each = dim)

    sel <- which(is.na(vectors))
    wrk <- sim_numbers(alltype[sel], rwrk[sel], rwrk[sel], argarg = argarg, ...)
    vectors[sel] <- wrk$values

    ## TODO: additional processing

    vectors
}

                                                         # 2014-10-21 renamed mC.sim to sim_mc
sim_mc <- function(dim, mo, mo.col=dim, eigval, len.block, type.eigval=NULL,
                   co, eigabs, eigsign, type="real", value="real", value.type="", ... ){

  use.eigval <- !missing(eigval)

  if(is.null(type.eigval)){
    type.eigval <- if(missing(eigval)){
                     c( rep("r",mo.col %% 2), rep("cp", mo.col %/% 2) )
                   }else{
                     if(mode(eigval)=="character"){  # compatibility with the old version
                       use.eigval <- FALSE
                       eigval
                     }else
                       ifelse(Im(eigval)==0,"r","cp")
                   }
  }

  nr  <- sum(type.eigval=="r")      # number of real roots
  ncp <- sum(type.eigval=="cp")     # number of complex pairs
  ncn <- sum(type.eigval=="c")      # number of complex (non-paired) roots
  nc  <- ncn + 2*ncp
  n   <- nr  +   ncp + ncn

  if(missing(eigabs))
    eigabs <- rep(as.numeric(NA),n)

  if(missing(eigsign))
    eigsign <- rep(as.numeric(NA),n)

  if( missing(len.block) )
    len.block <- rep(1,length(type.eigval))

  ev <- if(use.eigval)
          # sim_numbers(type.eigval,eigabs,eigsign,absgen,csigngen,signprob,...)
          sim_numbers(type.eigval, eigabs, eigsign, values=eigval, ...)
        else
          sim_numbers(type.eigval, eigabs, eigsign, ...)

  co <- if(missing(co))
                     # 2015-12-02 was: sim_mcseeds(mo=mo,len.block=len.block,type=ev$type,...)
            sim_chains(dim = mo, heights = len.block, type = ev$type, ...)
        else
               # 2015-12-02 was: sim_mcseeds(mo=mo,len.block=len.block,co=co,type=ev$type,...)
            sim_chains(dim = mo, heights = len.block, vectors = co, type = ev$type, ...)

  eigval <- c(     ev$values[ev$type=="r"]  ,
                   ev$values[ev$type=="cp"] ,
              Conj(ev$values[ev$type=="cp"]),
                   ev$values[ev$type=="c"]  )

                            # 2014-06-27 was :   exttype <- rep(ev$type,times=len.block)
                            #      TODO: this is a quick fix! check! similar error in sim_mcseeds
  exttype <- rep(ev$type, times = len.block)

  co <- cbind(     co[,exttype=="r"]  ,
                   co[,exttype=="cp"] ,
              Conj(co[,exttype=="cp"]),
                   co[,exttype=="c"]  )

  len.block <- c(len.block[ev$type=="r"],
                 len.block[ev$type=="cp"],
                 len.block[ev$type=="cp"],
                 len.block[ev$type=="c"]  )

                                                          # 2014-06-10 pass on mo.col, as well
  res <- make_mcmatrix(eigval, co, dim, len.block, what.co="bottom", type=type, what.res="list"
                , mo.col = mo.col )

  if(value.type=="matrix")
    return(res$mat)
  else if(value.type=="list")
    return(res)

  res
}

sim_Jordan <- function(values, heights = rep(1, length(values)), vectors = NULL, type = NULL,
                       ... ){
    if(is.null(type)){  # deduce the types
        type <- rep("cp", length(values)) ## default is "cp", also for NA's in values
        type[which(Im(values) == 0)] <- "r"
    }

    dim <- if(!is.null(vectors))
               nrow(vectors)
           else if(is.null(dim))
               sum(type == "r") + 2 * sum(type == "cp") + sum(type == "c")

    na.flags <- is.na(values)
    if(any(na.flags))
        sim_numbers(type[na.flags], values[na.flags], values[na.flags], ...)

    vectors <- sim_chains(dim = dim, type = type, heights = heights, vectors = vectors, ...)

    ## TODO: unfinished!

    vectors
}

## Obsoleted 2015-12-02:
##
## ## 2015-10-18  renamed mCsim.co to sim_mcseeds
## ## 2015-10-26 new: argarg with a default in (0,pi)
sim_mcseeds <- function( mo=nrow(co), len.block, co, type, argarg = list(0, pi), ... ){
  if(missing(len.block))
    len.block <- if(missing(co))
                   rep(1, length(type))
                 else
                   rep(1, ncol(co)) # 2014-06-01 was: ncol(co)

  if(missing(co))                                             # 2014-06-01 was: as.complex(NA)
    co <- matrix(as.numeric(NA), nrow=mo, ncol=sum(len.block))


  exttype <- if(missing(type))
               rep("cp", ncol(co))
             else                     # 2014-06-27 was : rep(type, times=len.block)
                                      #      TODO: this is a quick fix! check!
               rep(type, times = len.block)

  rwrk <- rep(as.numeric(NA), length(co))

  alltype <- rep(exttype, each=mo)

  sel <- which(is.na(co))
  wrk <- sim_numbers(alltype[sel], rwrk[sel], rwrk[sel], argarg = argarg, ...)
  co[sel] <- wrk$values

  co
}

                                                                        # class MultiCompanion
           # 2014-11-23 "representation" is deprecated from R-3.0.0, now using 'slots' instead
setClass("MultiCompanion",
         slots = c(xtop   = "matrix",   # variable part
                   mo     = "numeric",  # number of non-trivial rows
                   ido    = "numeric",  # dimension of the identity part: nc-mo
                   mo.col = "numeric",  # nonzero columns in the top rows
                              # razni = "list",    # lazy! temporary...; macham na 31/10/2006.
                   pad    = "objectPad"
                   ),
         contains = c("ddenseMatrix", "generalMatrix")
         #, prototype=list(m=matrix(NA,nrow=4,ncol=9) )
         )

                                                                          # begin: As methods
setAs("MultiCompanion", "matrix",
      function(from){
        rbind(from@xtop, diag(1, nrow=from@ido, ncol=ncol(from)) )
      }
      )
                # need to define the S3 method since as.matrix doesn't see S4 methods for as()
as.matrix.MultiCompanion <-
    function(x, ...){
        as(x, "matrix") # rbind(x@xtop, diag(1,nrow=x@ido,ncol=ncol(x)) )
    }


setAs("matrix", "MultiCompanion",
      function(from) mCompanion(from, detect="mo") )

setAs("MultiCompanion", "dgeMatrix",
      function(from)  as(as(from, "matrix"), "dgeMatrix") )

setAs("dgeMatrix", "MultiCompanion",
      function(from)  as(as(from, "matrix"), "MultiCompanion") )
                                                                          #   end: As methods

                                                      #  begin: create MultiCompanion objects
setMethod("initialize", "MultiCompanion",
    function(.Object, xtop, mo, n, mo.col, ido, x, dimnames, detect="nothing", misc=list()) {
        ## function patched many times, hardly readable...

        ## xtop -  missing, vector, matrix or admits as.matrix(xtop)
        if( !missing(xtop) ){
            flag.xtop <- TRUE
            if( is.vector(xtop) ){    # class(x)=="numeric" fails for other types of vector
                                        # (integer, complex,...)
                xtop <- matrix(xtop, nrow=1)
            }else{
                if( !is.matrix(xtop) )
                    xtop <- as.matrix(xtop)
            }
            wrk.n <- ncol(xtop)
            wrk.mo <- nrow(xtop)
            if(missing(x) && wrk.n==wrk.mo){
                ## 02/05/2007 xtop is probably x in this case,
                ##            now check for consistency with mo.
                tmptmpmo <- mc_order(xtop)
                stopifnot(missing(mo)  ||  !is.numeric(mo) || tmptmpmo == mo)
                wrk.mo <- tmptmpmo
            }
            wrk.ido <- wrk.n - wrk.mo
                                        # todo: dimnames ...
        }else{
            flag.xtop <- FALSE
        }

        ## x -  missing, vector, matrix or admits as.matrix(x)
        if( !missing(x) ){
            flag.x <- TRUE
            if( is.vector(x) ){
                if( as.integer(sqrt(length(x)))^2 != length(x) )
                    stop("square root of length x  must be integer, if x is present")
                else
                    x <- matrix(as.numeric(x), nrow = as.integer(sqrt(length(x))) )
            }else{
                if( !is.matrix(x) )
                    x <- as.matrix(x)
            }
            xwrk.n <- ncol(x)

            xwrk.mo <- if(detect=="mo")  # should "mo" be default for detect?
                           mc_order(x)
                       else if( !missing(mo) )
                           mo
                       else if( flag.xtop )
                           wrk.mo
                       else
                           xwrk.n

            xwrk.ido <- xwrk.n - xwrk.mo

                                        # todo: dimnames ...
        }else{
            flag.x <- FALSE
        }

        ##  both xtop and x given - check for consistency
        if( flag.xtop && flag.x ){       # stop if x and xtop are not consistent
            stopifnot(xwrk.n == wrk.n,
                      xwrk.mo == wrk.mo,
                                        # all( xtop[1:length(xtop)] == x[1:length(xtop)] )
                      all( xtop[1:wrk.mo,] == x[1:wrk.mo,] )
                      )
        }else if( flag.x ){
            xtop <- x[1:xwrk.mo,1:xwrk.n,drop=FALSE]
            wrk.n <- xwrk.n
            wrk.mo <- xwrk.mo
            wrk.ido <- xwrk.ido
        }
        stopifnot(  missing(mo)  || mo  == wrk.mo
                  , missing(n)   || n   == wrk.n
                  , missing(ido) || ido == wrk.ido
                  )

        ## an additional check - a patch introduced together with tmptmpmo (see above)
        if( !flag.x ){
            if( nrow(xtop) < ncol(xtop) )
                x <- rbind(xtop, diag(1,nrow=wrk.ido,ncol=wrk.n))
            else{ # xtop is actually x here
                x <- xtop
                xtop <- xtop[1:wrk.mo,]
            }
        }
                               # todo: check validity of dimnames (or set up a validity check)
        ## set and validate mo.col
        missmo.col <- missing(mo.col)
        if(missmo.col || is.character(mo.col) ){                         # 03/12/2006
            wrk.mo.col <- wrk.n                                 # lazy, e.g. mo.col="detect"
                 # 20/03/2007  if(detect=="all" || detect=="mo.col" || is.character(mo.col) )
            if(detect=="all" || detect=="mo.col" || (!missmo.col && is.character(mo.col)) ){
                while(all(xtop[,wrk.mo.col]==0))
                    wrk.mo.col <- wrk.mo.col - 1
            }                                                    # give warning if xtop==0 ?
        }else
            wrk.mo.col <- mo.col

        ## initialise the pad
        wrk.pad <- new("objectPad")
        for( s in names(misc))
            pad(wrk.pad, s) <- misc[[s]]


        .Object@Dim      <- c(wrk.n, wrk.n)        # Dim, Dimnames and x are  inherited slots.
        .Object@Dimnames <- list(NULL, NULL) # lazy
        .Object@x        <- as.numeric(x) # todo: will not work e.g. for complex

        .Object@xtop   <- xtop
        .Object@mo     <- wrk.mo
        .Object@mo.col <- wrk.mo.col
        .Object@ido    <- wrk.ido

        .Object@pad    <- wrk.pad
        ## .Object@razni <- razni   31/10/2006

        .Object
    }
)

### setGeneric("MultiCompanion", def = function(x,...){standardGeneric("MultiCompanion")},
###            useAsDefault = FALSE
###            )

mCompanion <- function(x, detect = "nothing", misc = list(), ...){   # sig changes: 3/12/2006
    if(length(x) == 1 && x == "sim"){# here ... are for the generator, not new("multi...") !
        wrk <- sim_mc(...)
    }else if(length(x) == 1 && x == "gen"){
        ## TODO: assumes "..."  contains what.res = "list"
        ##       otherwise wrk$mat below raises an error!
        wrk <- make_mcmatrix(...)
    }else if(detect == "gen"){                      # x is from make_mcmatrix or sim_mc
        wrk <- x
    }else{
        wrk <- list()
    }

    if(length(wrk) > 0){
        xtop <- wrk$mat[1:wrk$mo, ]
        wrk$mat <- NULL             # remove mat from wrk
        mo.col <- wrk$mo.col
        xmisc <- c(misc, wrk)      # this will be put in the pad, some info here is redundant.
        new("MultiCompanion", xtop = xtop, detect = "nothing", mo.col = mo.col, misc = xmisc)
    }else if(detect == "mo"){
        new("MultiCompanion", x = x, detect = detect, misc = misc, ...)
    }else
        new("MultiCompanion", xtop = x, detect = detect, misc = misc, ...)
}
                                                        #   end: create MultiCompanion objects


                                                                         # begin: subscripting

################# Note: replacement is inherited from dgeMatrix, a method here would
################# be useful for cases when replacement of a row keeps the MultiCompanion type.

# "[" - modified from denseMatrix.R in Matrix

# get rows: result is not square, so cannot be multicompanion unless all rows are selected.
setMethod("[", signature(x = "MultiCompanion", i = "index", j = "missing",
			 drop = "logical"),
          function (x, i, drop) {

            r <- as(x, "matrix")[i, , drop=drop]
            if(is.null(dim(r)))
              r
            else if(nrow(r)==ncol(r))          # assumes nrow and ncol are defined for r
              mCompanion(r, detect="mo")
            else
              as(r, "dgeMatrix")
          })

setMethod("[", signature(x = "MultiCompanion",  i = "missing", j = "index",
			 drop = "logical"),
          function (x, j, drop) {
            r <- as(x, "matrix")[, j, drop=drop]
            if(is.null(dim(r)))
              r
            else if(nrow(r)==ncol(r))          # assumes nrow and ncol are defined for r
              mCompanion(r, detect="mo")
            else
              as(r, "dgeMatrix")
          })

setMethod("[", signature(x = "MultiCompanion",  i = "index", j = "index",
			 drop = "logical"),
          function (x, i, j, drop) {
            # v denseMatrix call'at za tozi sluchay e:
            #                 r <- callGeneric(x = as(x, "matrix"), i=i, j=j, drop=drop)
            # ne mi e mnogo yasno kakva e razlikata. Efektivnost?
            r <- as(x, "matrix")[i, j, drop=drop]
            if(is.null(dim(r)))
              r
            else if(nrow(r)==ncol(r))          # assumes nrow and ncol are defined for r
              mCompanion(r, detect="mo")
            else
              as(r, "dgeMatrix")
          })
                                                                         #   end: subscripting

                                                                                  # begin: %*%
setMethod("%*%", signature(x = "MultiCompanion", y = "MultiCompanion"),
          function(x,y){
              wrk <- x@xtop %*% as(y,"matrix")

              m <- min( x@ido, y@mo )
              if( m > 0 ){
                  wrk2 <- y@xtop[1:m,]
                  wrk <- rbind(wrk,wrk2)
              }
              res <- mCompanion(wrk)
              res
          },
          valueClass = "MultiCompanion"
          )

# special method for diagonal matrix? keep MultiCompanion type if mult by identity?

# needs specific implementation but is ok
setMethod("%*%", signature(x = "MultiCompanion", y = "ANY"),
          function(x,y){
              as(x, "dgeMatrix") %*% y   # use something like callGeneric instead?
          }
          )

## needs specific implementation but is ok
setMethod("%*%", signature( x = "ANY", y = "MultiCompanion"),
          function(x,y){
              x %*% as(y,"dgeMatrix")
          }
          )

## 2015-07-24 adding methods with signature "matrix" to resolve the following error and
##            warning from the last example in mCompanion:
##
## > m4 <- rbind(c(1,2,rep(0,4)),c(3,4,rep(0,4)))
## > x4a <- mCompanion(m4,mo=2,mo.col=2)
## > ev <- mc_eigen(x4a)
## > x4a %*% ev$vectors
## Note: method with signature 'ddenseMatrix#matrix chosen for function '%*%',
##  target signature 'MultiCompanion#matrix'.
##  "MultiCompanion#ANY" would also be valid
## Error in x4a %*% ev$vectors :
##   invalid class 'MultiCompanion' to dup_mMatrix_as_geMatrix
## Calls: %*% -> %*%
##
##  TODO: may need more extensive checking since something may have changed in Matrix package
##        that affects other computations without specific methods for MultiCompanion
##        matrices.

setMethod("%*%", signature(x = "MultiCompanion", y = "matrix"),
          function(x,y){
              as(x,"dgeMatrix") %*% y   # use something like callGeneric instead?
          }
          )

# needs specific implementation but is ok
setMethod("%*%", signature( x = "matrix", y = "MultiCompanion"),
          function(x,y){
              x %*% as(y,"dgeMatrix")
          }
          )
                                                                                  #   end: %*%


# change when other types of MultiCompanion are implemented.                       # transpose
setMethod("t", signature(x = "MultiCompanion"),
          function(x){
              t(as(x,"dgeMatrix") )
          }
          )

setMethod("mcStable", signature( x = "MultiCompanion" ),
          function(x){
              wrk <- mc_eigenvalues(x)
              all(abs(wrk) < 1)
          }
          )
                                                                    # end class MultiCompanion

                                                 # 2014-10-21 renamed mC.factors to mc_factors
mc_factors <- function(x,what="mc"){ # 15/05/2007 new  arg: "what" to vary type of result
    if(what == "mc"  &&  padcheck(x,"mC.factors"))
        return( pad(x,"mC.factors") )
    else if(what != "mc"  &&  padcheck(x,"mC.factorsmat"))
        return( pad(x,"mC.factorsmat") )

    if(padcheck(x,"mC.factorsmat"))
        wrk <- pad(x,"mC.factorsmat")
    else if(padcheck(x,"mC.factors")){
        tmp <- pad(x,"mC.factors")
        wrk <- tmp[[1]][1,]
        for(s in tmp[-1])
            wrk <- rbind(wrk,s[1,])
    }else{
        wrk <- if(x@mo == 1)
                   x
               else
                   mc_factorize(x,x@mo,x@mo.col)
    }

    if(what == "mc"){
        if(x@mo == 1)
            res <- list(wrk)
        else{
            xmocol <- x@mo.col
            res <- apply(wrk,1,function(y) mCompanion(y,mo.col=xmocol) )
        }
        pad(x,"mC.factors") <- res    # expects that the original x will be changed,
                                      # not the local copy supplied to this function.
    }else{
        res <- wrk
        pad(x,"mC.factorsmat") <- res
    }

    res
}

mc_eigenvalues <- function(x, ...){
    if( !is.null(pad(x, "eigval")) )
        pad(x, "eigval")
    else{
        wrk <- eigen(x, only.values = TRUE)
        wrk$values
    }
}

mc_eigen <- function(x, ...){
    if(!is(x, "MultiCompanion")) #2015-10-29 new check; TODO: should it process other classes?
        stop("x must be from class MultiCompanion")

    if(!is.null(pad(x, "eigval")) && !is.null(pad(x, "eigvec"))){
        res <- list(values = pad(x, "eigval"),
                    vectors = pad(x, "eigvec"),
                    len.block = if(!is.null(pad(x, "len.block")))
                                    pad(x, "len.block") # TODO: proveri dali tova se poddarzha
                                                        # ot MultiCompanion???
                                else
                                    rep(1, length(res$values))
                    )
    }else if(x@mo.col == ncol(x)){
        res <- eigen(x)
        res$len.block <- rep(1, length(res$values))
    }else{                # 10/05/2007 kombiniram sluchaite x@mo.col >= x@mo i x@mo.col < x@mo
        wrk <- x[1:x@mo.col, 1:x@mo.col, drop = FALSE] # 2015-12-26 added drop = ...
        wr2 <- eigen(wrk)

        evnew <- list(eigval    = wr2$values,
                      eigvec    = wr2$vectors,
                      len.block = rep(1, length(wr2$values)),
                      mo.col    = x@mo.col,
                      mo        = x@mo )

        if(x@mo.col < x@mo){# 2015-12-26 changing to use small multi-companion; was:
                            #   mc_chain_extend(evnew,x@mo,ncol(x),
                            #     F0bot=as.matrix(x[(x@mo.col+1):x@mo,1:x@mo.col,drop=FALSE]))
            smc <- new("SmallMultiCompanion", Mtop = as.matrix(wrk),
                       Mbot = as.matrix(x[(x@mo.col + 1):x@mo, 1:x@mo.col, drop = FALSE]),
                       jdMtop = evnew)
            smc_ch <- smc_chains(smc)
            evnew <- mc_chain_extend(smc_ch, ncol(x))
        }
        wrk3 <- mc_chain_extend(evnew, ncol(x))

        res <- list(values = wrk3$eigval, vectors = wrk3$eigvec, len.block = wrk3$len.block)
    }
    res      # vrasta list() kato eigen() + component len.block; TODO: da dobavya mo i mo.col?
}            #     c(res, list(mo = x@mo, mo.col = x@mo.col))

###                                                                         # class McVector
### setClass("McVector"
###          , representation(  mo     = "numeric"
###                           , eigval = "vector"
###                           , eigvec = "vector"
###                           , seed   = "vector"
###                           , seed.pos   = "numeric"
###                           , normalised = "character"
###                           )
###          #, contains = c("ddenseMatrix", "generalMatrix")
###          #, prototype=list(m=matrix(NA,nrow=4,ncol=9) )
###          )

##############################################################################################
# library(Matrix)
# source("c:\\Az\\Work\\R\\percorr\\pcts\\R\\pc990.r")
# m <- mCompanion(matrix(rnorm(8),nrow=2))

# class ? "Matrix"
# class ? "pMatrix"

# m + Matrix(diag(4))
# m %*% Matrix(diag(4))
# m + Matrix(1,nrow=4,ncol=4)
# m %*% Matrix(1,nrow=4,ncol=4)
# m %*% as(4:1,"pMatrix")
# as(4:1,"pMatrix")
#  as(4:1,"pMatrix")m %*% as(4:1,"pMatrix")
#  t(as(4:1,"pMatrix")) %*% m %*% as(4:1,"pMatrix")
# t(m)
# showMethods("t")
# expm(m)
# eigen(m)
# t(m)
# m

### numeric, dense, general matrices, see Matrix package.
### setClass("dgeMatrix", contains = c("ddenseMatrix", "generalMatrix"),
### 	 ## checks that length( @ x) == prod( @ Dim):
### 	 validity =
### 	 function(object) .Call(dgeMatrix_validate, object)
### 	 )

setClass("MultiFilter", # 2014-11-23 slots was: "representation" which is obsolete from R-3.0.0
         slots = list(
             mc = "MultiCompanion",
             coef = "matrix",
             order = "numeric",   #integer?
             sign = "numeric"
             ## , type = "character"   # "pc", "v", "vs"
             )
         ##, contains = c("ddenseMatrix", "generalMatrix")
         ##, prototype=list(m=matrix(NA,nrow=4,ncol=9) )
         )

setMethod("initialize", "MultiFilter",
          function(.Object, coef, mc, order, sign = 1) {
              if(missing(coef)){
                  coef <- mc_factors(mc,what="mat")
                                       # reverse the order of the factors for the filter form.
                  coef <- coef[nrow(coef):1,1:ncol(coef),drop=FALSE]
              }else if(missing(mc)){
                  xtop <- mc_from_filter(coef)
                                        # 2013-10-10 zapazvam coefficientite na filtara,
                                        #   t.e. companion factors. Obrastam reda
                  misc <- list(mC.factorsmat = coef[nrow(coef):1, ])
                  mc <- new("MultiCompanion", xtop = xtop, mo.col = "detect", misc=misc)
              }

              if(missing(order)){           # todo: with apply
                  order <- numeric(nrow(coef))
                  for(i in 1:length(order)){
                      order[i] <- max(which(coef[i,] != 0))
                  }
              }

              .Object@mc <- mc
              .Object@coef <- coef
              .Object@sign <- sign
              .Object@order <- order
              .Object
          }
          )

# "["
                                        # is TRUE for drop better (as with built-in indexing)?
# "what" may be one of "kc", "kk", "ck", "cc", k stands for "keep signs" and c for "change".
# form may be "pc" (per. correlated), "vs" (vector of seasons), or "v" (standard var).

# aditional arg "truncate"? - otdelen method, j tryabva da e missing za da ima smisal truncate
# oste, "form" tryabva da e "pc"

# dali da napravya da dopalva s nuli ako j e po-golyamo ot order? mozhe bi argument za tova?
setMethod("[", signature(x = "MultiFilter"),
          function(x, i, j, k, lag0 = FALSE, what = "kc", form = "pc", drop = FALSE){
              d <- mf_period(x)
              if(form == "pc"){
                  ## simply  calling   wrk <- x@coef[i=i,j=j,drop=drop]
                  ## does not work when i or j is missing.
                  ## It may have something  to do with .local, created by setMethod.
                  ## Also,  x@coef[j=j,drop=drop], etc  would not work properly.
                  wrk <- if(missing(i) && missing(j))
                             x@coef[drop = drop]
                         else if(missing(i))
                             x@coef[ , j = j, drop = drop]
                         else if(missing(j))
                             x@coef[i = i, , drop = drop]
                         else
                             x@coef[i = i, j = j, drop = drop]
                  if(x@sign < 0)
                      wrk <- -wrk

                  if(lag0){       # include 0 lag term
                      if(substr(what, 2, 2) == "c")
                          wrk <- -wrk
                      tmpone <- if(substr(what, 1, 1) == "k")
                                    1
                                else
                                    -1
                      wrk0 <- rep(tmpone, nrow(wrk))   # relies on drop==FALSE  !!!
                      wrk <- cbind(wrk0, wrk)
                  }
              }else if(form %in% c("vs","v")){ # TODO: izglezhda, che tova ne e updatevano
                  if(form == "vs")               # sled promyanata vav mf_VSform (I, U, L) !!!
                      vs <- mf_VSform(x)  #add argument "top" to pass down?
                  else
                      vs <- mf_VSform(x, form = "I")   #add argument "top" to pass down?

                  if(!missing(k)){
                      if(0 %in% k)
                          lag0 <- TRUE
                      else if(lag0)
                          k <- c(0, k)
                      if(0 %in% k)
                          k <- k + 1 # !!! when lag0 is TRUE, the first element is at index 0.
                                     # do not use k for anything else!!!
                  }
                  wrk <- vs$Phi
                  if(lag0){       # include 0 lag term
                      if(substr(what, 2, 2) == "c")
                          wrk <- -wrk
                      tmpone <- vs$Phi0
                      if(substr(what, 1, 1) != "k")
                          tmpone <- -tmpone
                      wrk0 <- tmpone
                      wrk <- cbind(wrk0, wrk)
                  }
                  wrk <- array(wrk, dim = c(d, d, length(wrk) / d^2))
                  ## do subsetting
                  if(!missing(k))
                      wrk <- wrk[ , , k, drop = FALSE]

                  wrk <- if(missing(i) && missing(j))
                             wrk
                         else if(missing(i))
                             wrk[ , j, , drop = FALSE]
                         else if(missing(j))
                             wrk[i, , , drop = FALSE]
                         else
                             wrk[i, j, , drop = FALSE]
                  if(all(dim(wrk) == c(1, 1, 1)))  # only one element
                      wrk <- wrk[ , , ]   # make it scalar
                  else{
                      tmp <- dim(wrk)
                      dim(wrk) <- c(tmp[1], tmp[2] * tmp[3])
                  }
                  if(drop)
                      wrk <- wrk[ , ]
              }else{
                  stop("Feature not yet implemented.")
              }
              res <- wrk

              res
          })

mf_period <- function(x){
    length(x@order)
}

.mF.invperm <- function(x){
    p <- as(x,"pMatrix")
    pt <- t(p)
    pt@perm
}

mf_order <- function(x, i = "max", form = "pc", perm){
    res <- switch(form,
                  pc = { if(is.numeric(i))
                             x@order[i]
                         else if(i=="all")
                             x@order
                         else          # i=="max"
                             max(x@order)
                     },
                  v  = ,               # obsolete (old terminology), use  "I" instead
                  vs = ,               # obsolete (old terminology), use  "U" instead
                  I  = ,  # todo: I is currently the same as U but it needs separate treatment
                  U  =
                      { if(missing(perm))
                            perm <- mf_period(x):1 # for "U" the default is last season on top
                        wrk <- x@order[perm] - (mf_period(x) - 1):0
                        wrk <- ifelse(wrk <= 0, 0, ceiling(wrk/mf_period(x)))

                        wrk <- wrk[.mF.invperm(perm)] # permute back

                        if(is.numeric(i)) #  does not make much sense but provide it.
                            wrk[i]
                        else if(i=="all")
                            wrk
                        else          # i=="max"
                            max(wrk)
                    },
                  L  =
                      { if(missing(perm))
                            perm <- 1:mf_period(x)  # for "L" the default is 1st season on top
                        wrk <- x@order[perm] - 0:(mf_period(x) - 1)
                        wrk <- ifelse(wrk <= 0, 0, ceiling(wrk/mf_period(x)))

                        wrk <- wrk[.mF.invperm(perm)] # permute back

                        if(is.numeric(i)) #  does not make much sense but provide it.
                            wrk[i]
                        else if(i=="all")
                            wrk
                        else          # i=="max"
                            max(wrk)
                    },
                  ## default
                  stop("argument \"form\" must be one of \"pc\", \"I\", \"U\", or \"L\".")
                  )
    res
}

mf_poles <- function(x, blocks = FALSE){
    wrk <- mc_eigen(x@mc)
    if(blocks)
        cbind(wrk$values, wrk$len.block)
    else
        rep(wrk$values, times = wrk$len.block)
}

mf_VSform <- function(x, first = 1, form = "U", perm){
    d <- mf_period(x)                        # First prepare the U form

    top <- if(first == 1)
               d
           else
               first - 1

    s <- d:1
    while(s[1] != top)               # rotate
        s <- c(s[d], s[-d])

    p <- mf_order(x, i = "all")           # orders of individual seasons (vector)
    P <- mf_order(x, form = "vs", perm = s)         # order of the VS representation (scalar)
    m <- P * d
    Phi0 <- diag(d)                    # VS_0
    Phi <- matrix(0, nrow=d, ncol=m)     # remaining coef for VS
    phi <- x[]                   # pc coef; note: this is a recursive call when
                                 # mf_VSform is called  from  [..form="vs"].
                                 # but x[] calls "[" with form="pc", so no further  recursion.
    q <- p[s]
    for(i in seq_len(d - 1)){
        jmax <- min(q[i], d - i)
        if(jmax > 0)
            Phi0[i, i+ 1:jmax] <- -phi[s[i], 1:jmax]
        if(jmax < q[i])
            Phi[i, 1:(q[i]-jmax)] <- phi[s[i], (jmax+1):q[i]]
    }
    Phi[d, 1:q[d]] <- phi[s[d], 1:q[d]] # bottom row

    vs <- list(Phi0 = Phi0, Phi = Phi)                        # the U form

    res <- switch(form,                                   # now modify as required
                  U = vs,
                  L = { perm0 <- as(d:1,"pMatrix")
                        tperm0 <- perm0  #this particular permu. coincides with its inverse
                        list(Phi0 = perm0 %*% vs$Phi0 %*% tperm0,
                             Phi  = rblockmult(perm0 %*% vs$Phi, tperm0)
                             )
                    },
                  I = { list(Phi0 = diag(nrow(vs$Phi0)),
                             Phi  = solve(vs$Phi0,vs$Phi),
                             Phi0inv = solve(vs$Phi0)
                             )
                    },
                  stop("argument \"form\" must be one of \"I\", \"U\", or \"L\".")
                  )

    if(!missing(perm)){                  # Finally, permute the result if `perm' is given
        perm  <- as(perm, "pMatrix")
        perm0 <- as(d:1, "pMatrix")
        permP <- switch(form,
                        U = perm %*% perm0,  # tay kato redat e d:1 v momenta
                        L = perm,            # tay kato veche e v red 1:d
                        I = perm %*% perm0,  # tay kato redat e d:1 v momenta
                        stop("argument \"form\" must be one of \"I\", \"U\", or \"L\".")
                        )
        tpermP <- t(permP)

        res$Phi0 <- permP %*% res$Phi0 %*% tpermP
        res$Phi  <- rblockmult(permP %*% res$Phi, tpermP)
        if(!is.null(res$Phi0inv)) # 2015-02-11 corrected, was wrong for form = "I"
                                  #       was: res$Phi0inv <- solve(res$Phi0)
            res$Phi0inv <- permP %*% res$Phi0inv %*% tpermP
    }

    res
}

setMethod("mcStable", signature( x = "MultiFilter" ),
          function(x){
              wrk <- mf_poles(x)   # may be done more  efficiently.
              all(abs(wrk) < 1)
          }
          )

# 2014-05-21; last modified: 2015-03-26                               # TODO: , trim = TRUE
VAR2pcfilter <- function(phi, ..., Sigma, Phi0, Phi0inv, D, what = "coef", perm){
    perm.flag <- missing(perm)
    Phi0.flag <- missing(Phi0)
    Phi0inv.flag <- missing(Phi0inv)
    Sigma.flag <- missing(Sigma)

    co <- cbind(phi, ...)

    if(!perm.flag){
        if(Sigma.flag){
            if(Phi0inv.flag){
                Phi0inv <- solve(Phi0)
                e.var <- D
            }
            Sigma <- Phi0inv %*% diag(D) %*% t(Phi0inv)
        }

        user.perm <- nrow(co) + 1 - perm
        wrk <- permute_synch(list(co,Sigma), user.perm)
        co <- wrk[[1]]
        Sigma <- wrk[[2]]
        Sigma.flag <- FALSE
    }else{
        perm <- nrow(co):1
    }

    if(!Sigma.flag){
        wrk <- .udu(Sigma)
        Phi0inv <- wrk$U
        Phi0 <- solve(wrk$U)
        e.var <- wrk$d
    }else if(!Phi0inv.flag){
        Phi0 <- solve(Phi0inv)
        e.var <- D
    }else if(!Phi0.flag){
        Phi0inv <- solve(Phi0)
        e.var <- D
    }else{
        stop("One of Sigma, Phi0, Phi0inv must be specified.")
    }

    m <- Phi0 %*% co

    pcfilter <- matrix(0, nrow = nrow(Phi0), ncol = ncol(Phi0) - 1 + ncol(co))
    for(i in 1:nrow(Phi0)){
         perco <- c( - Phi0[i , -(1:i)], m[i, ])
         pcfilter[i, seq_along(perco)] <- perco
    }
    pcfilter <- pcfilter[nrow(Phi0):1, ] # put first season on top

    ## 2015-03-26 making the output more consistent
    if(what == "coef")
        pcfilter
    else if(what == "coef.and.var")
        list(pcfilter = pcfilter,
             var = e.var[nrow(Phi0):1] # 2015-03-26: now permute to correspond to the order in
             )                         #            pcfilter
    else
        list(pcfilter = pcfilter,
             var = e.var[nrow(Phi0):1],
             Uform = list(              # 2015-03-26 note that the permutation of the
                 Sigma = e.var,         #         rows in pcfilter is different from the rest.
                 U0 = Phi0,             # U0, U correspond to A0, A in Boshnakov/Iqelan(2009)
                 U = m,
                 U0inv = Phi0inv,
                 perm = perm
             ))
}

## "JordanDecomposition" is a virtual class but there is a generic function
## JordanDecomposition() which creates suitable Jordan decomposition objects from some
## derived non-virtual class.

setClass("JordanDecomposition", contains = "VIRTUAL")

## The basic non-virtual Jordan decomposition class
setClass("JordanDecompositionDefault",
         slots = c(values = "number", heights = "integer", vectors = "matrix"),
         contains = "JordanDecomposition"
         )

# not set as a validity function for the class since can't control when it is called.
.validJD <- function(object){
    if(   length(object@values) == length(object@heights)
       && ncol(object@vectors) == sum(object@heights))
        return(TRUE)

    err <- character(0)
    if(length(object@values) != length(object@heights))
        err <- c(err, "'values' and 'heights' must have equal lengths")
    if(ncol(object@vectors) != sum(object@heights))
        err <- c(err, "the number of vectors must equal sum(heights)")
    err
}




setMethod("initialize",
          "JordanDecompositionDefault",
          function(.Object, heights, ...){
              .Object <- callNextMethod(.Object, ...)
              if(missing(heights))
                  .Object@heights <- rep(1L, length(.Object@values))
              else{
                  .Object@heights <- as.integer(heights)
              }

              status <- .validJD(.Object)
              if(is.character(status))
                  stop(paste0(status, collapse="\n"))
              .Object
          }
          )


setAs("JordanDecompositionDefault", "matrix",
      function(from){
          j <- Jordan_matrix(from@values, from@heights)
          from_Jordan(from@vectors, j)
      }
      )

as.matrix.JordanDecompositionDefault <-
    function(x, ...){
        as(x, "matrix")
    }

## Generator function for Jordan decomposition objects

JordanDecomposition <- function(values, vectors, heights, ...){
    stop("No default method yet.")
}

setGeneric("JordanDecomposition")

setMethod("JordanDecomposition", c(values = "number", vectors = "matrix"),
          function(values, vectors, heights){
              new("JordanDecompositionDefault",
                  values = values, vectors = vectors, heights = heights)
          }
          )

setMethod("JordanDecomposition", c(values = "missing", vectors = "matrix"),
          function(values, vectors, heights){
              new("JordanDecompositionDefault",
                  values = rep(NA_real_, ncol(vectors)),
                  vectors = vectors, heights = heights)
          }
          )

setMethod("JordanDecomposition", c(values = "number", vectors = "missing"),
          function(values, vectors, heights){
              nc <- sum(heights)
              vectors <- matrix(NA_real_, nrow = nc, ncol = nc )
              new("JordanDecompositionDefault",
                  values = values, vectors = vectors, heights = heights)
          }
          )

setMethod("JordanDecomposition", c(values = "missing", vectors = "missing"),
          function(values, vectors, heights){
              if(missing(heights))
                  new("JordanDecompositionDefault")
              else{
                  n <- length(heights)
                  values <- rep(NA_real_, n)
                  vectors <- matrix(NA_real_, n, n)
                  new("JordanDecompositionDefault",
                      values = values, vectors = vectors, heights = heights)
              }
          }
          )


## methods for which values provides all the information or i sthe matrix to be decomposed.

setMethod("JordanDecomposition", c(values = "list", vectors = "missing"),
          function(values, names){
              if(missing(names)){ # note: assignment to 'values' must be after the others!
                  heights <- values[["heights"]]
                  vectors <- values[["vectors"]]
                  values <-  values[["values"]]
              }else{
                  heights <- values[[names["heights"]]]
                  vectors <- values[[names["vectors"]]]
                  values <-  values[[names["values" ]]]
              }
              new("JordanDecompositionDefault",
                  values = values, vectors = vectors, heights = heights)
          }
          )

setMethod("JordanDecomposition", c(values = "JordanDecomposition", vectors = "missing"),
          function(values){
              values
          }
          )

## new file 2015-12-22

              # 2015-11-07 changed the check that chbot[ , 1] is zero, since
              #            mc.0chain.transf() takes care of (approx.) linear dependence.
              #
              #            also, when chbot[ ,1] was zero, chbot was not used for the results,
              #            not quite correct.
              # TODO: after this change 'tol0' is not used any more.
     # 2015-12-22  mc.0chain.dx moved here from mc01zero.R
## mc.0chain.dx should become redundant after testing (see eg smc_0chain_transformed).
mc.0chain.dx <- function(mo, mo.col, chF0top, F0bot, tol0 = 1e-12){ #arbitrary constant here!?
    nch <- length(chF0top)
    nbr <- mo - mo.col
    stopifnot(nbr > 0)

    wrk <- vector(nch, mode = "list")
    for(i in 1:nch){
        chbot <-  F0bot %*% chF0top[[i]]
        chlen <- ncol(chF0top[[i]])
                         # 2015-11-07 this gives the same result as tmp below
                         #            TODO: Delete tmp and the code computing it after testing
        wrk[[i]] <- rbind(cbind(0, chF0top[[i]]),
                          cbind(chbot, 0))

                  tmp <- matrix(0, nrow = mo, ncol = 1 + chlen)
                  tmp[1:mo.col, -1] <- chF0top[[i]]
                  if(chlen>1)
                      tmp[(mo.col+1):mo, 2:chlen] <- chbot[,-1]
                  tmp[, 1] <- c(numeric(mo.col), chbot[ , 1])
                  ## wrk[[i]] <- tmp

                  stopifnot(identical(wrk[[i]], tmp))

        if(all(chbot[ , 1] == 0))
            wrk[[i]] <- wrk[[i]][ , -1, drop = FALSE]
    }

    res <- reduce_chains_simple(wrk)

    res
}

.smc_struct_0chains <- function(mo, mo.col){# must have mo >= mo.col
    if(mo.col == mo)
        return(list())

    #else mo.col < mo
    dm <- diag(nrow = mo) # struct 0vectors are columns mo.col + 1, ..., mo
    lapply((mo.col+1):mo, function(i) dm[  , i, drop = FALSE])
}

                                   # 2015-12-22 generalises mc.0chain.dx but also adds the
                                   #     structural 0vectors, since in general this cannot be
                                   #     done completely independently.

                                   # F0 corresponds to M in my latest manuscripts.
smc_0chain_transformed <- function(mo, mo.col, chF0top, F0bot.chF0top = NULL, F0bot){
    stopifnot(mo - mo.col > 0)
    if(is.null(F0bot.chF0top))
        F0bot.chF0top <- lapply(chF0top, function(x) F0bot %*% x)

                     # no, easier to do it in the loop; think about speed later, if important.
                     #    len0 <- sapply(chF0top, function(x) NCOL(x))
                     #    jc <- Jordan_submatrix(0, len0, mo, mo.col - sum(len0))

    chlen.all <- sapply(chF0top, ncol)

    cur.start <- mo.col - sum(chlen.all) + 1 # first column corresponding to 0vector

    wrk <- vector(length(chF0top), mode = "list")
    for(i in seq(along = wrk)){
        chlen <- chlen.all[i]

        curtop <- rbind(matrix(0, cur.start - 1, chlen),
                        diag(chlen))

        chbot <- F0bot.chF0top[[i]]  #  F0bot %*% chF0top[[i]]

        wrk[[i]] <- rbind(cbind(0, curtop),
                          cbind(chbot, 0))

        if(all(chbot[ , 1] == 0))
            wrk[[i]] <- wrk[[i]][ , -1, drop = FALSE]

        cur.start <- cur.start + chlen
    }

    dm <- diag(nrow = mo)                    # struct 0vectors are columns mo.col + 1, ..., mo
    ch.struct <- lapply((mo.col+1):mo, function(i) dm[  , i, drop = FALSE])

    wrk <- c(wrk, ch.struct) # append the struct 0vectors

    res <- reduce_chains_simple(wrk)

    # Not possible to do the reverse transform of the top.
    # This chunk doesn't work since chF0top contains only the 0vectors, but the transf. needs
    # the rest.
    #
    # chF0top.mat <- do.call("cbind", chF0top)    # convert chF0top to matrix
    # col.top <- seq(length = mo.col)
    # res <- lapply(res, function(x){x[col.top, ] <- chF0top.mat %*% x[col.top, , drop = FALSE]
    #                                x})
    # # equivalently:
    # # for(i in seq(along = res)){
    # #     res[[i]][col.top, ] <- chF0top.mat %*% res[[i]][col.top, , drop = FALSE]
    # #
    # # }

    res
}


smc_chains <- function(smc){  # smc is "SmallMultiCompanion"
    eval <- smc@jdMtop@values    # rename 'eval'
    flag.non0 <- eval != 0
    tot.non0 <- sum(smc@jdMtop@heights[flag.non0])

    ## TODO: currently assuming non-zero values are before zeroes.
    ind.non0 <- seq(length=tot.non0)
    Xtop.non0 <- smc@jdMtop@vectors[ , ind.non0]
    J.non0 <- Jordan_matrix(eval[ind.non0], smc@jdMtop@heights[seq(ind.non0)])

    mo <- nrow(smc@Mtop) + nrow(smc@Mbot)
    mo.col <- nrow(smc@Mtop)

    ind0 <- chain_ind(which(!flag.non0), smc@jdMtop@heights)

    ## 0chains
    ch0 <- lapply(which(!flag.non0),
                  function(ind) smc@jdMtop@vectors[ , chain_ind(ind, smc@jdMtop@heights)
                                                    , drop = FALSE])

              # allch0 <- mc_0chains(dim, mo, mo.col, ch0, F0bot = smc@Mbot)
              # allch0 <- c(list(mo = mo, mo.col = mo.col), allch0, list(co = allch0$eigvec))

    if(length(ch0) == 0){# only structural 0chains
        ch0.lst <- .smc_struct_0chains(mo, mo.col)
    }else{
        ch0.transf <- smc_0chain_transformed(mo, mo.col, ch0, F0bot = smc@Mbot)

        col.top <- seq(length = mo.col)
        ch0.lst <- lapply(ch0.transf,
                          function(x){
                              x[col.top, ] <- smc@jdMtop@vectors %*% x[col.top, , drop = FALSE]
                              x})
    }

    allch0 <- list(mo = mo, mo.col = mo.col,
                   eigval = rep(0, length(ch0.lst)),
                   len.block = sapply(ch0.lst, ncol),
                   eigvec = do.call("cbind", ch0.lst),
                   co     = do.call("cbind", ch0.lst)
                   )

    ## non-0 chains
    Xbot.non0 <- if(length(ind.non0) > 0)
                     smc@Mbot %*% Xtop.non0 %*% solve(J.non0)
                 else
                      matrix(nrow = nrow(smc@Mbot), ncol = 0)

    eigvec.non0 <- rbind(Xtop.non0, Xbot.non0)

    allchnon0 <- list(mo = mo, mo.col = mo.col,
                      eigval = eval[flag.non0],
                      len.block = smc@jdMtop@heights[flag.non0],
                      eigvec = eigvec.non0,
                      co = eigvec.non0 )

    ## combine non-0 and 0 chains
    res <- mc_chain_merge(allchnon0, allch0)

    res
}

smc_eigen <- function(smc){
    chains <- smc_chains(smc)

    list(values = chains$eigval, vectors = chains$eigvec, len.block = chains$eigval)
}

setClass("SmallMultiCompanion",
         slots = c(jdMtop = "JordanDecomposition", # Xbot = "numberMatrix",
                   Mtop = "matrix", Mbot = "matrix", MbotXtop = "matrix"
                   )
         )


setMethod("initialize",
          "SmallMultiCompanion",
          function(.Object, Mtop, Mbot, jdMtop, MbotXtop) {
              if(missing(jdMtop)) {
                  ev <- eigen(Mtop)  ## TODO: process the possibility for ev's with height > 1
                                     ##       Maybe simply give an error in that case?
                  jdMtop <- new("JordanDecompositionDefault",
                                values = ev$values, vectors = ev$vectors,
                                heights = rep(1L, length(ev$values))
                                )
              } else if(is.list(jdMtop)) { ## compatibility
                  values  <- jdMtop$eigval
                  heights <- jdMtop$len.block
                  vectors <- jdMtop$eigvec
                  jdMtop <- new("JordanDecompositionDefault",
                                values = values, vectors = vectors, heights = heights)
              }

              if(missing(Mtop))
                  Mtop <- as.matrix(jdMtop)

              Xtop <- jdMtop@vectors
              if(missing(MbotXtop))    # one of MbotXtop or Mbot must be provided
                  MbotXtop <- Mbot %*% Xtop
              else
                  Mbot <- MbotXtop %*% solve( as.matrix(Xtop)) # TODO: compute this more carefully.

              .Object@Mtop   <- Mtop
              .Object@Mbot   <- Mbot
              .Object@jdMtop <- jdMtop
              .Object@MbotXtop  <- MbotXtop
              .Object
          }
          )

setAs("SmallMultiCompanion", "matrix",
      function(from){
          mat <- rbind(from@Mtop, from@Mbot)
          cbind(mat, matrix(0, nrow = nrow(mat), ncol = nrow(mat) - ncol(mat)))
      }
      )


as.matrix.SmallMultiCompanion <-
    function(x, ...){
        as(x, "matrix")
    }

setMethod("JordanDecomposition", c(values = "SmallMultiCompanion", vectors = "missing"),
          function(values){
              chains <- smc_chains(values)
              new("JordanDecompositionDefault",
                  values = chains$eigval, vectors = chains$eigvec, heights = chains$len.block)
          }
          )

setClassUnion("optionalMatrix", c("matrix", "NULL"))   # 2014-06-08

                                        # new 2013-10-10
mcSpec <-
setClass("mcSpec"      # 2014-11-23 slots was: "representation" which is obsolete from R-3.0.0
         , slots = list(  dim     = "numeric"     # a single number
                          , mo      = "numeric"     # multi-companion order; period in ts
                          , ev.type = "character"   # currently "r" and "cp"
                          , co.type = "character"   # "top" or "bottom, not used currently
                          , order = "numeric"  # orders of the factors, currently set to
                                               # rep(dim, mo) but may be used to deduce
                                               # mo.col
                          , n.root = "numeric" # number of non-zero roots; currently = dim

                          , ev.abs = "numeric"
                          , ev.arg = "numeric"
                          , block.length = "numeric"

                          , co.abs = "matrix"
                          , co.arg = "matrix"

                          , mo.col = "numeric"   # 2014-06-08 new slots
                          , F0bot = "optionalMatrix"

                          )
         #, prototype=list(m=matrix(NA,nrow=4,ncol=9) )
         )

.Hz_real <- function(x){
    ifelse(x >= 0, 0, 1/2) # 0 for positive real; 1/2 for negative (Hz) !!!
}

spec_root1 <- function(mo, root1 = numeric(0), iorder = 0, siorder = 0){
    wrk <- rep(siorder, mo)
    wrk[1] <- wrk[1] + iorder

    wrk <- if(length(root1) == mo)
               wrk + root1
           else
               c(wrk, root1)

    wrk <- wrk[wrk > 0]
    if(length(wrk) > mo)
        stop("Conflicting specifications of the unit roots.")

    if(length(wrk) == 0){
        list()
    }else{
        co1 <- spec_seeds1(wrk, mo)     # co parameters for roots = 1

        stopifnot(sum(wrk) == ncol(co1))  # todo: for testing

        list(mo = mo
             , ev.type = rep("r", length(wrk))  # roots  = 1 are real
             , co.type = rep("r", length(wrk))
                  #, order
             , n.root = sum(wrk)
             , ev.abs = rep(1, length(wrk))
             , ev.arg = rep(0, length(wrk))   # 0 for positive ev
             , block.length = wrk
             , co.abs = abs(co1)
             , co.arg = .Hz_real(co1)         # 0 for positive; 1/2 for negative

             , co1 = co1 # temporary
            )
    }
}

spec_seeds1 <- function(len.block, mo){           # Specify the "co" things for the unit roots
    resnew <- spec_core(mo, 1, len.block)
    resnew$co
}

spec_root0 <- function(dim, mo, mo.col){
    stopifnot(mo.col <= dim)

    if(mo.col == dim)
        return(list())

    ## mo.col < dim

    wrk <- mc_0chains(dim, mo, mo.col) # structural zero-chains
    n.blocks <- length(wrk$len.block)

                                        # 2014-06-27 - use argument drop
                                        # 2014-07-21 - bug fix - need two commas!  [ , ,]
                # was: co0 <- wrk$eigvec[(dim - mo + 1) : dim, drop = FALSE]  # bottom mo rows
    co0 <- wrk$eigvec[(dim - mo + 1) : dim, , drop = FALSE]  # bottom mo rows

    ev.type <- rep("r", n.blocks)
                                      # todo: is there a need to include mo.col in the result?
                                      #       or rather, why not include it?
    list(mo = mo
         , ev.type = ev.type
         , co.type = ev.type
                  #, order
         , n.root = 0
         , ev.abs = numeric(n.blocks)
         , ev.arg = numeric(n.blocks)   # 0 for positive ev
         , block.length = wrk$len.block
         , co.abs = abs(co0)
         , co.arg = .Hz_real(co0)         # 0 for positive; 1/2 for negative

         , co0 = co0 # redundant but keep it for now.
         )
}

.adjust_mo_col <- function(mo.col, n.roots, order, unit.roots){
    if(!identical(n.roots, mo.col)  && is.null(mo.col))
        mo.col <- n.roots

    if(is.null(mo.col))
        max(order)
    else if(identical(mo.col, "+ones"))
        max(order) + unit.roots$n.roots
    else if(is.numeric(mo.col) && length(mo.col) == 1)
        mo.col
    else
        stop("'mo.col' can be a number, the string '+ones', or NULL")
}


.bind <- function(len, x, y, z){
    if(is.null(z))
        z <- numeric(0)
    len.na <- len - (length(x) + length(y) + length(z))
    stopifnot(len.na >= 0)
    c(x, y, z, rep(NA_real_, len.na))
}

.cbind <- function(nr, nc, x, y, z){
    if(is.null(x))
        x <- matrix(NA_real_, ncol = 0, nrow = nr)
    if(is.null(y))
        y <- matrix(NA_real_, ncol = 0, nrow = nr)
    if(is.null(z))
        z <- matrix(NA_real_, ncol = 0, nrow = nr)

                                 # 2014-06-27 was: nc.na <- nc - (ncol(x) + ncol(y) + ncol(z))
                                 #            TODO: tova e krapka, vzh lina/wrk23 and
                                 #                  zero.roots in mcSpec
    nc.na <- nc - (NCOL(x) + NCOL(y) + NCOL(z))
    stopifnot(nc.na >= 0)
    m <- matrix(NA_real_, nrow = nr, ncol = nc.na)
    cbind(x, y, z, m)
}


               # Note:  n.roots and mo.col are not necessarilly equal; TODO: think about this!
setMethod("initialize",        # 2014-05-26 significant updates and bug fixes to this function
          "mcSpec",
          function(.Object, dim, mo,
                   root1 = numeric(0), iorder = 0, siorder = 0,
                   order = rep(dim, mo), evtypes = NULL,
                   mo.col = NULL, # new 2013-10-29 (oversight that there is a slot n.roots?)
                   n.roots = mo.col,  # new 2014-05-27
                   ## 2014-05-26 TODO: argument block.length?
                   ... ){
              dots <- list(...)

              F0bot <- dots$F0bot

                                                             # special treatment for roots = 1
              unit.roots <- spec_root1(mo, root1, iorder, siorder) # process root = 1 specs
                                       # root1, iorder, siorder are not used after this point.

              mo.col <- .adjust_mo_col(mo.col, n.roots, order, unit.roots)
              stopifnot(mo.col <= dim)

              zero.roots <- spec_root0(dim, mo, mo.col)

              if(!is.null(evtypes)){   # 2014-06-05 evtypes => ev.type; deprecate arg. evtypes
                  print("Argument 'evtypes' is deprecated; use 'ev.type' instead.")
                  if(!is.null(dots$ev.type))
                      stop("Only one of 'evtypes' and 'ev.type' can be specified.")
                  dots$ev.type <- evtypes
              }

                      # character(0) to ensure "character" result, even if the others are NULL
              ev.type <- c(character(0),
                           unit.roots$ev.type, zero.roots$ev.type,
                           dots$ev.type # additional specs specified by arg. dots$ev.type
                           )

              block.length <- c(numeric(0),
                                unit.roots$block.length, zero.roots$block.length,
                                rep(1, length(dots$ev.type)) # dots$ev.type specifies simple
                                                             # roots
                                )                       # todo: allow multiple roots?

              root.count <- sum(block.length[ev.type == "r"]) +
                            2 * sum(block.length[ev.type == "cp"])

              stopifnot(root.count <= dim)

              if(root.count < dim){
                  # 2014-11-28 this was totally wrong
                  #
                  #     old.len.ev.type <- length(ev.type)
                  #     ev.type <- c(ev.type,
                  #                  rep("r", (dim - length(ev.type)) %% 2),  # 0 or 1 times
                  #                  rep("cp", (dim - length(ev.type)) %/% 2)
                  #                  )
                  ## 2014-06-27 was: block.length <- c(block.length, rep(1, dim - root.count))
                  #     block.length <- c(block.length,rep(1,length(ev.type)-old.len.ev.type))
                  # }

                             # for now assume that all other roots are simple and unspecified.
                  old.len.ev.type <- length(ev.type)
                  ev.type <- c(ev.type,
                               rep("r", (dim - root.count) %% 2),  # 0 or 1 times
                               rep("cp", (dim - root.count) %/% 2)
                               )
                  block.length <- c(block.length, rep(1, length(ev.type) - old.len.ev.type))
              }


              evlen <- length(ev.type)
              ncol <- sum(block.length)

              ev.abs <- .bind(evlen, unit.roots$ev.abs, zero.roots$ev.abs, dots$ev.abs)
              ev.arg <- .bind(evlen, unit.roots$ev.arg, zero.roots$ev.arg, dots$ev.arg)

              co.abs <- .cbind(mo, ncol, unit.roots$co.abs, zero.roots$co.abs, dots$co.abs)
              co.arg <- .cbind(mo, ncol, unit.roots$co.arg, zero.roots$co.arg, dots$co.arg)

              ## todo: co.type not assigned and not used currently

              .Object@dim          <- dim
              .Object@mo           <- mo
              .Object@ev.type      <- ev.type
              .Object@order        <- order
              .Object@ev.abs       <- ev.abs
              .Object@ev.arg       <- ev.arg
              .Object@block.length <- block.length
              .Object@co.abs       <- co.abs
              .Object@co.arg       <- co.arg

                                                     # broy na nelulevi koreni, often = mo.col
                                      # 2014-08-19 bug: wasn't accounting for complex pairs
              .Object@n.root       <- #  was: sum(block.length) - sum(zero.roots$block.length)
                  sum( (1 + (ev.type == "cp")) * block.length ) - sum(zero.roots$block.length)

              .Object@mo.col <- mo.col # 2014-06-08
              .Object@F0bot = F0bot

              .Object
          }
          )
