[{"path":"https://geobosh.github.io/mcompanion/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Georgi N. Boshnakov. Author, maintainer.","code":""},{"path":"https://geobosh.github.io/mcompanion/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” Journal Time Series Analysis, 30(3), 349-368. doi:10.1111/j.1467-9892.2009.00617.x. Boshnakov, N. G (2002). “Multi-companion matrices.” Linear Algebra Applications, 354, 53-83. doi:10.1016/S0024-3795(01)00475-X.","code":"@Article{,   title = {Generation of time series models with given spectral properties},   author = {Georgi N. Boshnakov and Bisher M. Iqelan},   journal = {Journal of Time Series Analysis},   volume = {30},   number = {3},   year = {2009},   pages = {349-368},   doi = {10.1111/j.1467-9892.2009.00617.x}, } @Article{,   title = {Multi-companion matrices},   author = {{Boshnakov} and Georgi N.},   author = {{Boshnakov} and Georgi N.},   journal = {Linear Algebra and its Applications},   volume = {354},   year = {2002},   pages = {53-83},   doi = {10.1016/S0024-3795(01)00475-X}, }"},{"path":"https://geobosh.github.io/mcompanion/index.html","id":"installing-mcompanion","dir":"","previous_headings":"","what":"Objects and Methods for Multi-Companion Matrices","title":"Objects and Methods for Multi-Companion Matrices","text":"latest stable version CRAN. can install development version mcompanion Github:","code":"install.packages(\"mcompanion\") remotes::install_github(\"GeoBosh/mcompanion\")"},{"path":"https://geobosh.github.io/mcompanion/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Objects and Methods for Multi-Companion Matrices","text":"Package “mcompanion” provides class multi-companion matrices methods arithmetic factorization. method generation multi-companion matrices prespecified spectral properties provided, well utilities periodically correlated multivariate time series models. See Boshnakov (2002) Boshnakov & Iqelan (2009). Package “mcompanion” implements multi-companion matrices discussed Boshnakov (2002) Boshnakov Iqelan (2009). main feature provided parsimonious parameterisation matrices based eigenvalues seeds eigenvectors. can used specification parameterisation models time series dynamical systems terms spectral characteristics, poles associated filters transition matrices. See also web site mcompanion.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecomposition.html","id":null,"dir":"Reference","previous_headings":"","what":"Create objects representing Jordan decompositions — JordanDecomposition","title":"Create objects representing Jordan decompositions — JordanDecomposition","text":"Create objects representing Jordan decompositions.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecomposition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create objects representing Jordan decompositions — JordanDecomposition","text":"","code":"JordanDecomposition(values, vectors, heights, ...)"},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecomposition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create objects representing Jordan decompositions — JordanDecomposition","text":"values eigenvalues, vector length equal number Jordan chains. vectors (generalised) eigenvectors, matrix. heights vector positive integers, heights[] height     values[]. ... arguments may needed methods.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecomposition.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create objects representing Jordan decompositions — JordanDecomposition","text":"JordanDecomposition S4 generic function. creates   objects representing Jordan decompositions. Dispatch first   two arguments, values vectors. names arguments correspond slots class   \"JordanDecompositionDefault\", class objects   created methods package mcompanion inherits   virtual class \"JordanDecomposition\".","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecomposition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create objects representing Jordan decompositions — JordanDecomposition","text":"object inheriting \"JordanDecomposition\"","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecomposition.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create objects representing Jordan decompositions — JordanDecomposition","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecomposition.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Create objects representing Jordan decompositions — JordanDecomposition","text":"signature(values = \"\", vectors = \"\") default method; currently raises error. signature(values = \"JordanDecomposition\", vectors = \"missing\") simply returns values. signature(values = \"list\", vectors = \"missing\") case values can list components \"values\",   \"vectors\" \"heights\". method additional   argument \"names\" can used components   list different, e.g. names = c(values = \"eigval\", vectors = \"eigvec\", heights = \"len.block\"). signature(values = \"missing\", vectors = \"matrix\") equivalent case values = \"number\" values   set vector missing values. signature(values = \"missing\", vectors = \"missing\") values (vectors) set vector (matrix) missing   values. dimensions deduced argument heights,   heights missing signature. signature(values = \"number\", vectors = \"matrix\") equivalent calling new class   \"JordanDecompositionDefault\" arguments values,   vectors heights. signature(values = \"number\", vectors = \"missing\") equivalent case vectors = \"matrix\" vectors   set matrix missing values. signature(values = \"SmallMultiCompanion\", vectors = \"missing\") computes Jordan decomposition object class   \"SmallMultiCompanion\".","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecomposition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create objects representing Jordan decompositions — JordanDecomposition","text":"","code":"m <- matrix(c(1,2,4,10), nrow = 2) m <- matrix(c(1,2,4,10), nrow = 2) m <- matrix(c(5, 12, 3, 4), nrow = 2)  JordanDecomposition(values = rep(0,2), vectors = m) #> An object of class \"JordanDecompositionDefault\" #> Slot \"values\": #> [1] 0 0 #>  #> Slot \"heights\": #> [1] 1 1 #>  #> Slot \"vectors\": #>      [,1] [,2] #> [1,]    5    3 #> [2,]   12    4 #>  jd <- JordanDecomposition(values = c(0.9, 0.3), vectors = m) as(jd, \"matrix\") #>       [,1]   [,2] #> [1,] -0.45 0.5625 #> [2,] -1.80 1.6500 eigen(jd) #> eigen() decomposition #> $values #> [1] 0.9 0.3 #>  #> $vectors #>            [,1] [,2] #> [1,] -0.3846154 -0.6 #> [2,] -0.9230769 -0.8 #>  ## the eigenvectors are scaled versions of m's columns: eigen(jd)$vectors %*% diag(c(5 / eigen(jd)$vectors[1,1], -5)) #>      [,1] [,2] #> [1,]    5    3 #> [2,]   12    4 ## == m  ## eigenvalues are not supplied, so set to  NA's here: JordanDecomposition(vectors = m) #> An object of class \"JordanDecompositionDefault\" #> Slot \"values\": #> [1] NA NA #>  #> Slot \"heights\": #> [1] 1 1 #>  #> Slot \"vectors\": #>      [,1] [,2] #> [1,]    5    3 #> [2,]   12    4 #>   ## eigenvectors are set to vectors of NA's here: JordanDecomposition(values = rep(0,2), height = c(1,1)) #> An object of class \"JordanDecompositionDefault\" #> Slot \"values\": #> [1] 0 0 #>  #> Slot \"heights\": #> [1] 1 1 #>  #> Slot \"vectors\": #>      [,1] [,2] #> [1,]   NA   NA #> [2,]   NA   NA #>"},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecompositionDefault-class.html","id":null,"dir":"Reference","previous_headings":"","what":"A basic class for Jordan decompositions — JordanDecompositionDefault-class","title":"A basic class for Jordan decompositions — JordanDecompositionDefault-class","text":"basic class Jordan decompositions.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecompositionDefault-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A basic class for Jordan decompositions — JordanDecompositionDefault-class","text":"Class \"JordanDecompositionDefault\" represents Jordan   decompositions. inherits virtual class   \"JordanDecomposition\", serves base class Jordan   decompositions. classes considered internal.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecompositionDefault-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"A basic class for Jordan decompositions — JordanDecompositionDefault-class","text":"Objects class \"JordanDecompositionDefault\" can created    call  JordanDecomposition(). Objects can created calls form   new(\"JordanDecompositionDefault\", heights, ...).","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecompositionDefault-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"A basic class for Jordan decompositions — JordanDecompositionDefault-class","text":"values: Object class \"number\",       vector eigenvalues (one value Jordan chain). heights: Object class \"integer\",       heights Jordan chains. vectors: Object class \"matrix\",       (generalised) eigenvectors (similarity matrix).","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecompositionDefault-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"A basic class for Jordan decompositions — JordanDecompositionDefault-class","text":"Class \"JordanDecomposition\", directly.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecompositionDefault-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"A basic class for Jordan decompositions — JordanDecompositionDefault-class","text":"coerce signature(= \"JordanDecompositionDefault\", \t= \"matrix\"): gives matrix represented Jordan decomposition, .e.       \\(XJX^{-1}\\). coerce methods, use       (obj, \"matrix\"), obj Jordan       decomposition object.  initialize signature(.Object = \"JordanDecompositionDefault\"): ...","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecompositionDefault-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A basic class for Jordan decompositions — JordanDecompositionDefault-class","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/JordanDecompositionDefault-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A basic class for Jordan decompositions — JordanDecompositionDefault-class","text":"","code":"showClass(\"JordanDecompositionDefault\") #> Class \"JordanDecompositionDefault\" [package \"mcompanion\"] #>  #> Slots: #>                                #> Name:   values heights vectors #> Class:  number integer  matrix #>  #> Extends: \"JordanDecomposition\"  m <- matrix(c(1,2,4,3), nrow = 2) new(\"JordanDecompositionDefault\", values = rep(0,2), vectors = m) #> An object of class \"JordanDecompositionDefault\" #> Slot \"values\": #> [1] 0 0 #>  #> Slot \"heights\": #> [1] 1 1 #>  #> Slot \"vectors\": #>      [,1] [,2] #> [1,]    1    4 #> [2,]    2    3 #>"},{"path":"https://geobosh.github.io/mcompanion/reference/MultiCompanion-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"Objects methods multi-companion matrices","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiCompanion-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class ","text":"ordinary usage objects class behave matrices   need access slots directly. Objects can created function mCompanion.   functions mcompanion package also produce   MultiCompanion objects. possible also call new() directly: Arguments:  xtop top matrix. mo multi-companion order matrix. n dimension. mo.col top order, meaniing columns       mo.col+1,...,n top matrix zeros. mo.col       may also set \"detect\", case determined       scanning xtop x. ido dimension identity sub-matrix. x whole matrix. dimnames used currently. detect controls whether automatic detection       mo mo.col attempted. values tested       \"mo\", \"mo.col\", \"\", \"nothing\" obvious meanings. misc todo: describe argument! Normally one xtop x supplied ,   checked consistency, including elements matrix   (equality tested ==).  facilitate calls one   unnamed argument, xtop square matrix taken   entire matrix (provided x missing). Aside xtop (x), remaining arguments   can deduced automatically.  number rows columns   xtop give multi-companion order dimension   matrix, respectively. vector xtop taken stand   matrix one row. x needs square vector length   equal exact square. mo mo.col may determined   contents x xtop. harm   ignoring mo.col useful applications. Note   default set number columns   determined scanning matrix. contents  misc argument  stored pad   new object.","code":"new(\"MultiCompanion\", xtop, mo, n, mo.col, ido, x, dimnames,         detect, misc)"},{"path":"https://geobosh.github.io/mcompanion/reference/MultiCompanion-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class ","text":"xtop: top matrix, object class \"matrix\" mo: Multi-companion order, object class \"numeric\" ido: dimension identity submatrix, object class \"numeric\" mo.col: number non-zero columns top rows, object class \"numeric\" pad: storage additional info, object class \"objectPad\" x: inherited, object class \"numeric\" Dim: inherited, object class \"integer\" Dimnames: inherited, object class \"list\" factors: inherited, object class \"list\"","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiCompanion-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"Class ","text":"Class \"ddenseMatrix\", directly. Class \"generalMatrix\", directly. Class \"dMatrix\", class \"ddenseMatrix\". Class \"denseMatrix\", class \"ddenseMatrix\". Class \"Matrix\", class \"ddenseMatrix\". Class \"Matrix\", class \"ddenseMatrix\". Class \"compMatrix\", class \"generalMatrix\". Class \"Matrix\", class \"generalMatrix\".","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiCompanion-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class ","text":"%*% signature(x = \"\", y = \"MultiCompanion\"): ... %*% signature(x = \"MultiCompanion\", y = \"MultiCompanion\"): ... %*% signature(x = \"MultiCompanion\", y = \"\"): ... [ signature(x = \"MultiCompanion\", = \"index\", j = \"index\",         drop = \"logical\"): ... [ signature(x = \"MultiCompanion\", = \"index\", j = \"missing\", drop = \"logical\"): ... [ signature(x = \"MultiCompanion\", = \"missing\", j =         \"index\", drop = \"logical\"): ... coerce signature(= \"dgeMatrix\", = \"MultiCompanion\"): ... coerce signature(= \"matrix\", = \"MultiCompanion\"): ... coerce signature(= \"MultiCompanion\", = \"matrix\"): ... coerce signature(= \"MultiCompanion\", = \"dgeMatrix\"): ... initialize signature(.Object = \"MultiCompanion\"):       method called implicitly user calls       new(\"MultiCompanion\",...). mcStable signature(x = \"MultiCompanion\"): ... t signature(x = \"MultiCompanion\"): ... %*% signature(x = \"matrix\", y = \"MultiCompanion\"): ... %*% signature(x = \"MultiCompanion\", y = \"matrix\"): ... [ signature(x = \"MultiCompanion\", = \"index\", j = \"index\", drop = \"missing\"): ... [ signature(x = \"MultiCompanion\", = \"index\", j = \"missing\", drop = \"missing\"): ... [ signature(x = \"MultiCompanion\", = \"missing\", j = \"index\", drop = \"missing\"): ... %*% signature(x = \"MultiCompanion\", y = \"vector\"): ... %*% signature(x = \"vector\", y = \"MultiCompanion\"): ...","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiCompanion-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Class ","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X . Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiCompanion-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class ","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiCompanion-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class ","text":"implementation rather redundant, class probably   inherit different way classes Matrix package may   inherit . Methods get multi-order, mo.col, others, useful   first terminology needs made consistent. matrix arithmetic operations? Argument n called dim functions.","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/MultiCompanion-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"a1 <- matrix(1:12,nrow=2) mc1 <- new(\"MultiCompanion\",xtop=a1) new(\"MultiCompanion\",a1)   # same #> 6 x 6 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    3    5    7    9   11 #> [2,]    2    4    6    8   10   12 #> [3,]    1    0    0    0    0    0 #> [4,]    0    1    0    0    0    0 #> [5,]    0    0    1    0    0    0 #> [6,]    0    0    0    1    0    0  a2 <- matrix(c(1:6,rep(0,4)),nrow=2)   # 1st 3 columns of a2 are non-zero mc2 <- new(\"MultiCompanion\",a2) mc2 #> 5 x 5 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    3    5    0    0 #> [2,]    2    4    6    0    0 #> [3,]    1    0    0    0    0 #> [4,]    0    1    0    0    0 #> [5,]    0    0    1    0    0 mc2@mo.col     # =5, because the default is to set mo.col to ncol #> [1] 5  mc2a <- new(\"MultiCompanion\",a2,detect=\"mo.col\") mc2a@mo.col   # =3, compare with above #> [1] 3  b <- as(mc2,\"matrix\")  # b is ordinary R matrix mcb <- new(\"MultiCompanion\",x=b)        new(\"MultiCompanion\",b)   # same as mcb #> 5 x 5 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    3    5    0    0 #> [2,]    2    4    6    0    0 #> [3,]    1    0    0    0    0 #> [4,]    0    1    0    0    0 #> [5,]    0    0    1    0    0  mcb@mo        # 2 (mo detected) #> [1] 5 mcb@mo.col    # 5 (no attempt to detect mo.col) #> [1] 5  mcba <- new(\"MultiCompanion\",b,detect=\"all\") mcba@mo        # 2 (mo detected) #> [1] 2 mcba@mo.col    # 3 (mo.col detected) #> [1] 3"},{"path":"https://geobosh.github.io/mcompanion/reference/MultiFilter-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"Objects methods  filters one set   coefficients.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiFilter-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class ","text":"Objects can created calls form   new(\"MultiFilter\", coef, mc, order, sign). Objects class represent periodic filters.   \\(d\\)-periodic filter relates input series   \\(\\varepsilon_{t}\\) output series   \\(y_t\\) following formula:   $$ y_t     =   \\sum_{=1}^{p_t} \\phi  _t()y          _{t-}       % + \\sum_{=1}^{q_t} \\theta_t()\\varepsilon_{t-}       + \\varepsilon_t       ,     $$   coefficients \\(\\phi_t()\\) \\(d\\)-periodic   \\(t\\), .e. \\(\\phi_{t+d}()=\\phi_t()\\)   \\(p_{t+d} = p_{t}\\). periodicity means sufficient store coefficients   \\(d \\times p\\) matrix,   \\(p=\\max(p_1,\\dots,p_t)\\).   Slot coef contains matrix. filter may specified either coefficients   multi-companion form.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiFilter-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class ","text":"mc: multi-companion form filter, object       class \"MultiCompanion\" coef: coefficients filter, object       class \"matrix\", whose \\(s\\)th row contains       coefficients \\(t=k \\times d +s\\). order: periodic order filter,       numeric vector giving orders individual seasons. sign: 1 -1. default value, 1, corresponds       formula given section \"Objects Class\". can also       -1, sum right-hand side formula       preceded minus (usual convention signal processing).","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiFilter-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class ","text":"[ signature(x = \"MultiFilter\", = \"\", j = \"\", \tdrop = \"\"):       take subset coefficients filter various forms. : function needs work! Document function       additional arguments! initialize signature(.Object = \"MultiFilter\"):       function called implicitly new, see       signature new .       One mc  coef must supplied,       arguments optional. mc missing computed coef.       case, component mC.factorsmat slot misc       mc set companion factorisation mc       (essentially reversed rows coef). coef missing computed mc, see       mc_factors. mcStable signature(x = \"MultiFilter\"):       Check filter stable.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiFilter-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Class ","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X . Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/MultiFilter-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class ","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/MultiFilter-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"showClass(\"MultiFilter\") #> Class \"MultiFilter\" [package \"mcompanion\"] #>  #> Slots: #>                                                                    #> Name:              mc           coef          order           sign #> Class: MultiCompanion         matrix        numeric        numeric  m <- mCompanion(\"sim\",dim=3,mo=2)   # simulate a 3x3 2-comp. matrix flt <- new(\"MultiFilter\", mc = m ) flt[] #>               [,1]        [,2]         [,3] #> [1,] -5875.9721878 -631.372583 2.419001e+03 #> [2,]    -0.1073817    0.411227 4.924808e-05 mf_period(flt) #> [1] 2 mf_poles(flt) #> [1]  0.2534562+0.0000000i -0.1213882-0.6747531i -0.1213882+0.6747531i abs(mf_poles(flt)) #> [1] 0.2534562 0.6855850 0.6855850  mf_VSform(flt,form=\"U\") #> $Phi0 #>      [,1]      [,2] #> [1,]    1 0.1073817 #> [2,]    0 1.0000000 #>  #> $Phi #>              [,1]          [,2]     [,3] [,4] #> [1,]     0.411227  4.924808e-05    0.000    0 #> [2,] -5875.972188 -6.313726e+02 2419.001    0 #>  mf_VSform(flt,form=\"L\") #> $Phi0 #> 2 x 2 Matrix of class \"dgeMatrix\" #>           [,1] [,2] #> [1,] 1.0000000    0 #> [2,] 0.1073817    1 #>  #> $Phi #>               [,1]         [,2] [,3]     [,4] #> [1,] -6.313726e+02 -5875.972188    0 2419.001 #> [2,]  4.924808e-05     0.411227    0    0.000 #>  mf_VSform(flt,form=\"I\") #> $Phi0 #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> $Phi #>            [,1]       [,2]      [,3] [,4] #> [1,]   631.3833   67.79793 -259.7565    0 #> [2,] -5875.9722 -631.37258 2419.0014    0 #>  #> $Phi0inv #>      [,1]       [,2] #> [1,]    1 -0.1073817 #> [2,]    0  1.0000000 #>    # try arguments \"coef\" and \"mc\", for comparison rfi <- sim_pcfilter(2,3) # period=2, order=c(3,3) # per. filter from a multi-companion matrix flt1 <- new(\"MultiFilter\",mc=  mCompanion(zapsmall(rfi$mat)) ) flt1[] #>             [,1]        [,2]        [,3] #> [1,]  3.18695500  0.49882400 -0.20376100 #> [2,] -0.07323776 -0.08911954 -0.01817525 mf_period(flt1) #> [1] 2 mf_poles(flt1) #> [1]  0.2443024+0.0000000i -0.0340017+0.1183342i -0.0340017-0.1183342i abs(mf_poles(flt1)) #> [1] 0.2443024 0.1231223 0.1231223  mf_VSform(flt1,form=\"U\") #> $Phi0 #>      [,1]       [,2] #> [1,]    1 0.07323776 #> [2,]    0 1.00000000 #>  #> $Phi #>             [,1]        [,2]      [,3] [,4] #> [1,] -0.08911954 -0.01817525  0.000000    0 #> [2,]  3.18695500  0.49882400 -0.203761    0 #>  mf_VSform(flt1,form=\"L\") #> $Phi0 #> 2 x 2 Matrix of class \"dgeMatrix\" #>            [,1] [,2] #> [1,] 1.00000000    0 #> [2,] 0.07323776    1 #>  #> $Phi #>             [,1]        [,2] [,3]      [,4] #> [1,]  0.49882400  3.18695500    0 -0.203761 #> [2,] -0.01817525 -0.08911954    0  0.000000 #>  mf_VSform(flt1,form=\"I\") #> $Phi0 #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> $Phi #>           [,1]      [,2]      [,3] [,4] #> [1,] -0.322525 -0.054708  0.014923    0 #> [2,]  3.186955  0.498824 -0.203761    0 #>  #> $Phi0inv #>      [,1]        [,2] #> [1,]    1 -0.07323776 #> [2,]    0  1.00000000 #>   # per. filter from coefficients, should be the same (numerically) flt2 <- new(\"MultiFilter\",coef=rfi$pcfilter) flt2[] #>             [,1]        [,2]        [,3] #> [1,]  3.18695503  0.49882399 -0.20376089 #> [2,] -0.07323984 -0.08911246 -0.01817423 mf_period(flt2) #> [1] 2 mf_poles(flt2) #> [1]  0.2443007+0.0000000i -0.0340006+0.1183314i -0.0340006-0.1183314i abs(mf_poles(flt2)) #> [1] 0.2443007 0.1231193 0.1231193  mf_VSform(flt2,form=\"U\") #> $Phi0 #>      [,1]       [,2] #> [1,]    1 0.07323984 #> [2,]    0 1.00000000 #>  #> $Phi #>             [,1]        [,2]       [,3] [,4] #> [1,] -0.08911246 -0.01817423  0.0000000    0 #> [2,]  3.18695503  0.49882399 -0.2037609    0 #>  mf_VSform(flt2,form=\"L\") #> $Phi0 #> 2 x 2 Matrix of class \"dgeMatrix\" #>            [,1] [,2] #> [1,] 1.00000000    0 #> [2,] 0.07323984    1 #>  #> $Phi #>             [,1]        [,2] [,3]       [,4] #> [1,]  0.49882399  3.18695503    0 -0.2037609 #> [2,] -0.01817423 -0.08911246    0  0.0000000 #>  mf_VSform(flt2,form=\"I\") #> $Phi0 #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> $Phi #>            [,1]        [,2]        [,3] [,4] #> [1,] -0.3225245 -0.05470802  0.01492341    0 #> [2,]  3.1869550  0.49882399 -0.20376089    0 #>  #> $Phi0inv #>      [,1]        [,2] #> [1,]    1 -0.07323984 #> [2,]    0  1.00000000 #>"},{"path":"https://geobosh.github.io/mcompanion/reference/SmallMultiCompanion-class.html","id":null,"dir":"Reference","previous_headings":"","what":"A class for small multi-companion matrices — SmallMultiCompanion-class","title":"A class for small multi-companion matrices — SmallMultiCompanion-class","text":"class internal use work small   multi-companion matrices.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/SmallMultiCompanion-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"A class for small multi-companion matrices — SmallMultiCompanion-class","text":"class internal use. Objects can created calls form   new(\"SmallMultiCompanion\", Mtop, Mbot, jdMtop, MbotXtop).","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/SmallMultiCompanion-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"A class for small multi-companion matrices — SmallMultiCompanion-class","text":"jdMtop: Object class \"JordanDecomposition\" ~~ Mtop: Object class \"matrix\" ~~ Mbot: Object class \"matrix\" ~~ MbotXtop: Object class \"matrix\" ~~","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/SmallMultiCompanion-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"A class for small multi-companion matrices — SmallMultiCompanion-class","text":"coerce signature(= \"SmallMultiCompanion\", = \"matrix\"): ... initialize signature(.Object = \"SmallMultiCompanion\"): ... JordanDecomposition signature(values = \"SmallMultiCompanion\", vectors = \"missing\"): ...","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/SmallMultiCompanion-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A class for small multi-companion matrices — SmallMultiCompanion-class","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/SmallMultiCompanion-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A class for small multi-companion matrices — SmallMultiCompanion-class","text":"","code":"mat2 <- make_mcmatrix(eigval = c(1), co = cbind(c(1,1,1,1), c(0,1,0,0)), dim = 4, len.block = c(2)) mat2 #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    0    0 #> [2,]   -1    2    0    0 #> [3,]    0    1    0    0 #> [4,]    0    1    0    0 ## Jordan decomp. of mat2[1:2,1:2]: x2 <- matrix(c(1,1,-1,0), ncol =2) jd <- matrix(c(1,0,1,1), ncol = 2) mat2[1:2,1:2] - x2 %*% jd %*% solve(x2) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 jdobj <- JordanDecomposition(values = 1, vectors = x2, heights = 2)  m1 <- new(\"SmallMultiCompanion\", mat2[1:2, 1:2], Mbot = mat2[3:4, 1:2], jdMtop = jdobj) m1a <- new(\"SmallMultiCompanion\", Mbot = mat2[3:4, 1:2], jdMtop = jdobj) as.matrix(m1) - as.matrix(m1a)  # (approx.) 0's #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0"},{"path":"https://geobosh.github.io/mcompanion/reference/VAR2pcfilter.html","id":null,"dir":"Reference","previous_headings":"","what":"PAR representations of VAR models — VAR2pcfilter","title":"PAR representations of VAR models — VAR2pcfilter","text":"Give univariate periodic autoregression representation VAR   model. Several arrangements supported discussed   Boshnakov Iqelan (2009) . VAR model   contains unit roots unit circle, univariate model   periodically integrated.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/VAR2pcfilter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PAR representations of VAR models — VAR2pcfilter","text":"","code":"VAR2pcfilter(phi, ..., Sigma, Phi0, Phi0inv, D, what = \"coef\", perm)"},{"path":"https://geobosh.github.io/mcompanion/reference/VAR2pcfilter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PAR representations of VAR models — VAR2pcfilter","text":"phi VAR coefficients, matrix, see Details. ... alternative way specify VAR coefficients giving matrix     lag separate arguments, see section ‘Details’. Sigma covariance matrix innovations. Phi0 coefficient matrix lag 0 (alternative Sigma). Phi0inv inverse Phi0 (alternative Sigma     Phi0). Phi0inv lower triangular,     Cholesky factor Sigma (Sigma\\({} = LDL'\\)). D diagonal matrix corresponding Phi0, used     Sigma specified. return, string. equal \"coef\",     return PAR coefficients (matrix one row     ``season''); equal \"coef..var\" return also     innovation variances. Otherwise return additional quantities (useful     exploration). perm permutation specifying ordering variables treated     ``seasons''. default, d:1, corresponds U-form,     see section ‘Details’.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/VAR2pcfilter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"PAR representations of VAR models — VAR2pcfilter","text":"VAR2pcfilter converts VAR model scalar periodic   autoregressive (PAR) model. various ways specify VAR   model associate variables seasons scalar   representation, see Boshnakov Iqelan (2009)    detailed discussion terminology used .  VAR coefficients phi,... standard form   VAR model (e.g., see Boshnakov Iqelan 2009) .   two ways specify . first put side   side matrix \\([\\Phi_1, \\ldots, \\Phi_p]\\) give matrix   argument phi. Alternatively, matrices \\(\\Phi_i\\) may   given directly arguments VAR2pcfilter,   VAR2pcfilter(Phi1, Phi2, Phi3, Sigma = Sigma). specification model can completed giving   covariance matrix, Sigma, innovations.  Alternatively,   possible give components \\(UDU'\\) decomposition   Sigma. case argument D vector giving   diagonal matrix \\(D\\), Phi0inv represents   upper triangular matrix \\(U\\). option use argument   Phi0 specify inverse \\(U\\). summary, give either   Sigma D one Phi0inv Phi0. Phi0 can e interpreted coefficient lag zero   U-form (Boshnakov Iqelan 2009)  VAR model.   diag(D) variance matrix innovations   form. D also gives variances innovations PAR   (periodic autoregression) form. default, VAR2pcfilter constructs U-form VAR model   extracts coefficients PAR filter . means   variables multivariate vector given ``seasons''   reverse order (first variable takes last season, ).   reasons behind default, see   Boshnakov Iqelan (2009) .  Another   arrangement can chosen help argument   perm. perm permutation specifying   desired allocation variables seasons. default corresponds   perm=d:1, d number   seasons. perm=1:d used request ``natural''   order. D Phi0inv (Phi0) given,   matrix Sigma computed argument perm missing   perm present. means perm = d:1   may used force formation Sigma recomputation   Phi0 Phi0inv. redundant latter two   unit upper-triangular (assumed checked) may   handy , example, Cholesky decomposition lower   triangular matrix available.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/VAR2pcfilter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PAR representations of VAR models — VAR2pcfilter","text":"=\"coef\", matrix containing periodic model   coefficients (one row season). =\"coef..var\", list containing coefficients   innovations' variances: pcfilter PAR coefficients, matrix var innovation variances, vector Otherwise returned list contains additional component,  Uform, list components: Sigma covariance matrix innovations, U0 coefficient lag zero, U remaining AR coefficients, U0inv inverse U0, perm permutation giving season variable. Note: U0 U correspond \\(A0\\) \\(\\)   reference (Boshnakov Iqelan 2009).","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/VAR2pcfilter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"PAR representations of VAR models — VAR2pcfilter","text":"Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/VAR2pcfilter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"PAR representations of VAR models — VAR2pcfilter","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/VAR2pcfilter.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"PAR representations of VAR models — VAR2pcfilter","text":"function uses non-exported internal functions: .ldl Computes LDL' Cholesky decomposition unit       lower-triangular matrix L, .udu Computes UDU' Cholesky decomposition unit       upper-triangular matrix U. export deemed widely useful.","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/VAR2pcfilter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PAR representations of VAR models — VAR2pcfilter","text":"","code":"## create a pc filter rfi <- sim_pcfilter(2,3) rfi$pcfilter #>             [,1]         [,2]        [,3] #> [1,] -1.61809255 -0.008816587 -1.27341988 #> [2,]  0.07787874 -0.796469949  0.06076921  ## turn it into VAR form flt <- new(\"MultiFilter\", coef = rfi$pcfilter) I1 <- mf_VSform(flt, form=\"I\") I1 #> $Phi0 #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> $Phi #>            [,1]         [,2]        [,3] [,4] #> [1,] -0.9224849  0.060082584 -0.09917233    0 #> [2,] -1.6180926 -0.008816587 -1.27341988    0 #>  #> $Phi0inv #>      [,1]       [,2] #> [1,]    1 0.07787874 #> [2,]    0 1.00000000 #>   ## from VAR to scalar form flt2 <- VAR2pcfilter(I1$Phi, Sigma = I1$Phi0inv %*% t(I1$Phi0inv)) flt2 #>             [,1]         [,2]        [,3]        [,4] [,5] #> [1,] -1.61809255 -0.008816587 -1.27341988 0.00000e+00    0 #> [2,]  0.07787874 -0.796469949  0.06076921 6.30978e-18    0  ## confirm that we are back to the original ##   (VAR2pcfilter doesn't drop redundant zeroes, so we do it manually)     all.equal(flt2[ , 1:3], rfi$pcfilter) ## TRUE #> [1] TRUE"},{"path":"https://geobosh.github.io/mcompanion/reference/jordan.html","id":null,"dir":"Reference","previous_headings":"","what":"Utilities for Jordan matrices — jordan","title":"Utilities for Jordan matrices — jordan","text":"Utility functions work Jordan decompositions matrices:   create block diagonal matrix Jordan blocks,   restore matrix Jordan decomposition,   locate specific chains.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/jordan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utilities for Jordan matrices — jordan","text":"","code":"Jordan_matrix(eigval, len.block) from_Jordan(x, jmat, ...) chain_ind(chainno, len.block) chains_to_list(vectors, heights)"},{"path":"https://geobosh.github.io/mcompanion/reference/jordan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utilities for Jordan matrices — jordan","text":"eigval eigenvalues, numeric complex vector. len.block lengths Jordan chains, vector positive integers. x generalised eigenvectors, matrix one column     (generalised) eigenvector. jmat Jordan matrix. chainno vector positive integers 1 length(eigval)     specifying Jordan chains locate, see Details. ... arguments pass solve. vectors matrix generalised eigenvectors matrix. heights vector chain lengths, heights[] length     -th chain.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/jordan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Utilities for Jordan matrices — jordan","text":"Jordan_matrix creates Jordan matrix (block-diagonal matrix   Jordan blocks diagonal) whose -th diagonal block   corresponds eigval[] size len.block[].   len.block missing, Jordan_matrix returns   diag(eigenvalues). from_Jordan computes matrix whose Jordan decomposition   represented arguments X (chains) J (Jordan   matrix). Conceptually, result equivalent \\(XJX^{-1}\\)   without explicitly inverting matrices (currently result   transpose solve(t(x), t(x %*% jmat), ...)). chain_ind computes columns specified Jordan chains   matrix generalised eigenvectors. mostly internal function.   x matrix whose columns generalised eigenvectors   -th Jordan chain length len.block[],   function gives column numbers x containing specified   chains.   Note chain_ind able deduce total number   eigenvalues. therefore error omit argument   len.block calling . chains_to_list converts matrix vectors list   matrices. -th element list matrix whose columns   vectors -th chain.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/jordan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utilities for Jordan matrices — jordan","text":"Jordan_matrix, matrix specified Jordan blocks   diagonal. from_Jordan, matrix specified Jordan   decomposition. chain_ind, vector positive integers giving columns   requested chains. chains_to_list, list matrices.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/jordan.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Utilities for Jordan matrices — jordan","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/jordan.html","id":"level","dir":"Reference","previous_headings":"","what":"Level","title":"Utilities for Jordan matrices — jordan","text":"0","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/jordan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utilities for Jordan matrices — jordan","text":"","code":"## single Jordan blocks Jordan_matrix(4, 2)  #>      [,1] [,2] #> [1,]    4    1 #> [2,]    0    4 Jordan_matrix(5, 3) #>      [,1] [,2] [,3] #> [1,]    5    1    0 #> [2,]    0    5    1 #> [3,]    0    0    5 Jordan_matrix(6, 1) #>      [,1] #> [1,]    6 ## a matrix with the above 3 blocks Jordan_matrix(c(4, 5, 6), c(2, 3, 1)) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    4    1    0    0    0    0 #> [2,]    0    4    0    0    0    0 #> [3,]    0    0    5    1    0    0 #> [4,]    0    0    0    5    1    0 #> [5,]    0    0    0    0    5    0 #> [6,]    0    0    0    0    0    6  ## a matrix with a 2x2 Jordan block for eval 1 and two simple 0 eval's m <- make_mcmatrix(eigval = c(1), co = cbind(c(1,1,1,1), c(0,1,0,0)),                      dim = 4, len.block = c(2)) m #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    0    0 #> [2,]   -1    2    0    0 #> [3,]    0    1    0    0 #> [4,]    0    1    0    0 m.X <- cbind(c(1,1,1,1), c(0,1,0,0), c(0,0,1,0), c(0,0,0,1)) m.X #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    1    1    0    0 #> [3,]    1    0    1    0 #> [4,]    1    0    0    1 m.J <- cbind(c(1,0,0,0), c(1,1,0,0), rep(0,4), rep(0,4)) m.J #>      [,1] [,2] [,3] [,4] #> [1,]    1    1    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0  from_Jordan(m.X, m.J)          # == m #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    0    0 #> [2,]   -1    2    0    0 #> [3,]    0    1    0    0 #> [4,]    0    1    0    0 m.X %*% m.J %*% solve(m.X) # == m #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    0    0 #> [2,]   -1    2    0    0 #> [3,]    0    1    0    0 #> [4,]    0    1    0    0 all(m == from_Jordan(m.X, m.J)) && all(m == m.X %*% m.J %*% solve(m.X)) #> [1] TRUE ## TRUE  ## which column(s) in m.X correspond to 1st Jordan block? chain_ind(1, c(2,1,1)) # c(1, 2) since 2x2 Jordan block #> [1] 1 2      ## which column(s) in m.X correspond to 2nd Jordan block? chain_ind(2, c(2,1,1)) # 3, simple eval #> [1] 3  ## which column(s) in m.X correspond to 1st and 2nd Jordan blocks? chain_ind(c(1, 2), c(2,1,1)) # c(1,2,3) #> [1] 1 2 3 ## non-contiguous subset are ok: chain_ind(c(1, 3), c(2,1,1)) # c(1,2,4) #> [1] 1 2 4  ## split the chains into a list of matrices chains_to_list(m.X, c(2,1,1)) #> [[1]] #>      [,1] [,2] #> [1,]    1    0 #> [2,]    1    1 #> [3,]    1    0 #> [4,]    1    0 #>  #> [[2]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    1 #> [4,]    0 #>  #> [[3]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    1 #>       m.X %*% m.J #>      [,1] [,2] [,3] [,4] #> [1,]    1    1    0    0 #> [2,]    1    2    0    0 #> [3,]    1    1    0    0 #> [4,]    1    1    0    0 m %*% m.X    # same #>      [,1] [,2] [,3] [,4] #> [1,]    1    1    0    0 #> [2,]    1    2    0    0 #> [3,]    1    1    0    0 #> [4,]    1    1    0    0 all(m.X %*% m.J == m %*% m.X)    # TRUE #> [1] TRUE          m %*% c(1,1,1,1)    # = c(1,1,1,1),  evec for eigenvalue 1 #>      [,1] #> [1,]    1 #> [2,]    1 #> [3,]    1 #> [4,]    1 m %*% c(0,1,0,0)    # gen.e.v. for eigenvalue 1 #>      [,1] #> [1,]    1 #> [2,]    2 #> [3,]    1 #> [4,]    1 ## indeed: all( m %*% c(0,1,0,0) == c(0,1,0,0) + c(1,1,1,1) ) # TRUE     #> [1] TRUE  ## m X = X jordan.block cbind(c(1,1,1,1), c(0,1,0,0)) %*% cbind(c(1,0), c(1,1)) #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    2 #> [3,]    1    1 #> [4,]    1    1 m %*% cbind(c(1,1,1,1), c(0,1,0,0)) #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    2 #> [3,]    1    1 #> [4,]    1    1"},{"path":"https://geobosh.github.io/mcompanion/reference/mCompanion.html","id":null,"dir":"Reference","previous_headings":"","what":"Create objects from class MultiCompanion — mCompanion","title":"Create objects from class MultiCompanion — mCompanion","text":"Create, generate, simulate objects class \"MultiCompanion\"   specifying matrix several ways.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mCompanion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create objects from class MultiCompanion — mCompanion","text":"","code":"mCompanion(x, detect = \"nothing\", misc = list(), ...)  # S4 method for MultiCompanion initialize(.Object, xtop, mo, n, mo.col, ido, x, dimnames,            detect = \"nothing\", misc = list())"},{"path":"https://geobosh.github.io/mcompanion/reference/mCompanion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create objects from class MultiCompanion — mCompanion","text":"x matrix , mCompanion , top     matrix character string, see section ‘Details’. misc information stored object's pad. ... arguments passed generator functions, see     section ‘Details’. xtop top matrix. mo multi-companion order matrix. n dimension. mo.col top order, meaniing columns mo.col+1,...,n top     matrix zeros. mo.col may also set \"detect\",     case determined scanning xtop x. ido dimension identity sub-matrix. dimnames used currently. detect controls whether automatic detection mo mo.col     attempted. values tested \"mo\", \"mo.col\", \"\",     \"nothing\" obvious meanings. .Object set implicitly package \"methods\".","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mCompanion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create objects from class MultiCompanion — mCompanion","text":"Objects class \"MultiCompanion\" can created calling   mCompanion() new(\"MultiCompanion\", ...).   latter case “...” arguments   initialize method, except .Object. call   initialize directly. mCompanion can generate multi-companion matrices spectral   information, full partial, using methodology developed   Boshnakov Iqelan (2009) .   specification given full, missing information filled   suitably simulated values. example, unspecifies eigenvalues   generated inside unit circle, sim_mc. argument x string \"sim\" \"gen\",   mCompanion calls sim_mc   make_mcmatrix, respectively, arguments   ... converts result class MultiCompanion.  See   documentation functions details examples.   conversion may main reason use mCompanion   way rather call sim_mc make_mcmatrix directly. Otherwise, x numeric taken specify top   matrix unless detect=\"mo\" case whole   matrix.  cases arguments passed new,   (less) change x passed   xtop=x x=x, respectively, see   MultiCompanion. detect==\"gen\" signifies x format   output sim_mc make_mcmatrix, mCompanion   may use additional information objects. multi-companion order determined automatically content   matrix detect==\"mo\".","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mCompanion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create objects from class MultiCompanion — mCompanion","text":"multi-companion matrix, object class \"MultiCompanion\"","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mCompanion.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create objects from class MultiCompanion — mCompanion","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X . Boshnakov GN (2007). “Singular value decomposition multi-companion matrices.” Linear Algebra Appl., 424(2-3), 393--404. ISSN 0024-3795, doi:10.1016/j.laa.2007.02.010 . Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mCompanion.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create objects from class MultiCompanion — mCompanion","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mCompanion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create objects from class MultiCompanion — mCompanion","text":"","code":"# simulate a 6x6 mc matrix with 2 non-trivial rows mCompanion(\"sim\", dim = 4, mo = 2) #> 4 x 4 Matrix of class \"MultiCompanion\" #>           [,1]       [,2]         [,3]       [,4] #> [1,] 1.5092280 -3.0564474 -0.293248784 -1.7595102 #> [2,] 0.1098053 -0.1363559 -0.007133413 -0.3663064 #> [3,] 1.0000000  0.0000000  0.000000000  0.0000000 #> [4,] 0.0000000  1.0000000  0.000000000  0.0000000 # simulate a 6x6 mc matrix with 4 non-trivial rows mCompanion(\"sim\", dim = 6, mo = 4) #> 6 x 6 Matrix of class \"MultiCompanion\" #>             [,1]        [,2]       [,3]        [,4]        [,5]       [,6] #> [1,]  0.41159240 -0.22210746  0.3498662  0.10692371 -0.19887327 -0.2591039 #> [2,]  0.44069985  0.41638184  1.8504165  0.77332571 -0.16433009 -1.4628614 #> [3,]  0.06343582  0.72076884  0.2117861  0.17418626 -0.01172951 -0.1452245 #> [4,] -0.09718819 -0.03045778 -1.6078018 -0.08477042  0.73799344  0.6211021 #> [5,]  1.00000000  0.00000000  0.0000000  0.00000000  0.00000000  0.0000000 #> [6,]  0.00000000  1.00000000  0.0000000  0.00000000  0.00000000  0.0000000 # similar to above but top rows with 2 non-zero columns mCompanion(\"sim\", dim = 6, mo = 4, mo.col = 2) #> 6 x 6 Matrix of class \"MultiCompanion\" #>            [,1]        [,2] [,3] [,4] [,5] [,6] #> [1,] 0.42946844 -1.16753667    0    0    0    0 #> [2,] 0.46482636 -0.61366545    0    0    0    0 #> [3,] 0.08406247  0.11630894    0    0    0    0 #> [4,] 0.61198488  0.09714687    0    0    0    0 #> [5,] 1.00000000  0.00000000    0    0    0    0 #> [6,] 0.00000000  1.00000000    0    0    0    0  ## specify the non-trivial top rows (as a matrix): m1 <- matrix(1:24, nrow = 4) mCompanion(m1)            # mc matrix with m1 on top #> 6 x 6 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    5    9   13   17   21 #> [2,]    2    6   10   14   18   22 #> [3,]    3    7   11   15   19   23 #> [4,]    4    8   12   16   20   24 #> [5,]    1    0    0    0    0    0 #> [6,]    0    1    0    0    0    0  m2 <- rbind(c(1, 2, 0, 0), c(3, 4, 0, 0)) x2a <- mCompanion(m2)     # mc matrix with m2 on top x2a@mo.col                #  = 4 #> [1] 4  x2 <- mCompanion(m2, mo.col = \"detect\") x2@mo.col                #  = 2,  detects the 0 columns in m2 #> [1] 2 mCompanion(m2, mo.col = 2)  # same #> 4 x 4 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    0    0 #> [2,]    3    4    0    0 #> [3,]    1    0    0    0 #> [4,]    0    1    0    0  # create manually an mc matrix (m3 <- rbind(m1, c(1, rep(0, 5)), c(0, 1, rep(0, 4)))) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    5    9   13   17   21 #> [2,]    2    6   10   14   18   22 #> [3,]    3    7   11   15   19   23 #> [4,]    4    8   12   16   20   24 #> [5,]    1    0    0    0    0    0 #> [6,]    0    1    0    0    0    0 # turn it into a MultiCompanion object x3 <- mCompanion(x = m3, detect = \"mo\") x3@mo #> [1] 4 x3 <- mCompanion(m3) x3@mo #> [1] 4  m4 <- rbind(c(1, 2, rep(0, 4)), c(3, 4, rep(0, 4)))  x4 <- mCompanion(m4, mo = 2) x4@mo.col    #  = 6, #> [1] 6 ## special structure not incorporated in x4, ##   eigen and mc_eigen are equiv. in this case eigen(x4) #> eigen() decomposition #> $values #> [1]  5.3722813 -0.3722813  0.0000000  0.0000000  0.0000000  0.0000000 #>  #> $vectors #>             [,1]        [,2] [,3]           [,4] [,5]           [,6] #> [1,] -0.40871213 -0.10620629    0   0.000000e+00    0   0.000000e+00 #> [2,] -0.89350221  0.07287246    0   0.000000e+00    0   0.000000e+00 #> [3,] -0.07607795  0.28528504    0  6.012505e-292    0   0.000000e+00 #> [4,] -0.16631709 -0.19574567    0   0.000000e+00    0  6.012505e-292 #> [5,] -0.01416120 -0.76631576    1  -1.000000e+00    0   0.000000e+00 #> [6,] -0.03095837  0.52580040    0   0.000000e+00    1  -1.000000e+00 #>  mc_eigen(x4) #> eigen() decomposition #> $values #> [1]  5.3722813 -0.3722813  0.0000000  0.0000000  0.0000000  0.0000000 #>  #> $vectors #>             [,1]        [,2] [,3]           [,4] [,5]           [,6] #> [1,] -0.40871213 -0.10620629    0   0.000000e+00    0   0.000000e+00 #> [2,] -0.89350221  0.07287246    0   0.000000e+00    0   0.000000e+00 #> [3,] -0.07607795  0.28528504    0  6.012505e-292    0   0.000000e+00 #> [4,] -0.16631709 -0.19574567    0   0.000000e+00    0  6.012505e-292 #> [5,] -0.01416120 -0.76631576    1  -1.000000e+00    0   0.000000e+00 #> [6,] -0.03095837  0.52580040    0   0.000000e+00    1  -1.000000e+00 #>  #> $len.block #> [1] 1 1 1 1 1 1 #>   x4a <- mCompanion(m4, mo = 2, mo.col = 2) x4a@mo.col    #  = 2,  has Jordan blocks of size > 1 #> [1] 2 ## the eigenvectors do not span the space: eigen(x4a) #> eigen() decomposition #> $values #> [1]  5.3722813 -0.3722813  0.0000000  0.0000000  0.0000000  0.0000000 #>  #> $vectors #>             [,1]        [,2] [,3]           [,4] [,5]           [,6] #> [1,] -0.40871213 -0.10620629    0   0.000000e+00    0   0.000000e+00 #> [2,] -0.89350221  0.07287246    0   0.000000e+00    0   0.000000e+00 #> [3,] -0.07607795  0.28528504    0  6.012505e-292    0   0.000000e+00 #> [4,] -0.16631709 -0.19574567    0   0.000000e+00    0  6.012505e-292 #> [5,] -0.01416120 -0.76631576    1  -1.000000e+00    0   0.000000e+00 #> [6,] -0.03095837  0.52580040    0   0.000000e+00    1  -1.000000e+00 #>  ## mc_eigen exploits the Jordan structure, e.g.2x2 Jordan blocks, ## and gives the generalised eigenvectors: (ev <- mc_eigen(x4a)) #> $values #> [1]  5.3722813 -0.3722813  0.0000000  0.0000000 #>  #> $vectors #>             [,1]       [,2] [,3] [,4] [,5] [,6] #> [1,] -0.41597356 -0.8245648    0    0    0    0 #> [2,] -0.90937671  0.5657675    0    0    0    0 #> [3,] -0.07742959  2.2148971    0    1    0    0 #> [4,] -0.16927198 -1.5197310    0    0    0    1 #> [5,] -0.01441280 -5.9495253    1    0    0    0 #> [6,] -0.03150840  4.0822112    0    0    1    0 #>  #> $len.block #> [1] 1 1 2 2 #>   x4a %*% ev$vectors #> 6 x 6 Matrix of class \"dgeMatrix\" #>             [,1]       [,2] [,3] [,4] [,5] [,6] #> [1,] -2.23472698  0.3069701    0    0    0    0 #> [2,] -4.88542751 -0.2106247    0    0    0    0 #> [3,] -0.41597356 -0.8245648    0    0    0    0 #> [4,] -0.90937671  0.5657675    0    0    0    0 #> [5,] -0.07742959  2.2148971    0    1    0    0 #> [6,] -0.16927198 -1.5197310    0    0    0    1  ## construct the Jordan matrix of x4a from eigenvalues and eigenvectors (x4a.j <- Jordan_matrix(ev$values,  ev$len.block)) #>          [,1]       [,2] [,3] [,4] [,5] [,6] #> [1,] 5.372281  0.0000000    0    0    0    0 #> [2,] 0.000000 -0.3722813    0    0    0    0 #> [3,] 0.000000  0.0000000    0    1    0    0 #> [4,] 0.000000  0.0000000    0    0    0    0 #> [5,] 0.000000  0.0000000    0    0    0    1 #> [6,] 0.000000  0.0000000    0    0    0    0  ## check that AX = XJ and A = XJX^-1, up to numerical precision: x4a %*% ev$vectors  -  ev$vectors %*% x4a.j #> 6 x 6 sparse Matrix of class \"dgCMatrix\" #>                                         #> [1,] -4.440892e-16 .            . . . . #> [2,]  .            5.551115e-17 . . . . #> [3,]  .            .            . . . . #> [4,]  .            .            . . . . #> [5,]  .            .            . . . . #> [6,]  .            .            . . . . x4a  -  ev$vectors %*% x4a.j %*% solve(ev$vectors) #> 6 x 6 sparse Matrix of class \"dgCMatrix\" #>                                                                #> [1,] 2.220446e-16  4.440892e-16 . .  .            .            #> [2,] .             4.440892e-16 . .  .            .            #> [3,] .             9.915992e-17 . .  .            .            #> [4,] 3.309340e-17  .            . .  .            .            #> [5,] 4.440892e-16 -2.220446e-16 . . -7.703720e-34 .            #> [6,] 2.220446e-16  .            . . -2.397072e-17 3.330669e-17"},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcev.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a multi-companion eigenvector — make_mcev","title":"Create a multi-companion eigenvector — make_mcev","text":"Creates eigenvector multicompanion matrix eigenvalue   seed parameters.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcev.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a multi-companion eigenvector — make_mcev","text":"","code":"make_mcev(eigval, co, dim, what.co = \"bottom\") make_mcgev(eigval, co, v, what.co = \"bottom\")"},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcev.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a multi-companion eigenvector — make_mcev","text":"eigval eigenvalue. co bottom (default) top seed elements vector. dim size matrix. .co type co: \"bottom\" \"top\". v previous vector chain.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcev.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a multi-companion eigenvector — make_mcev","text":"make_mcev computes eigenvector multi-companion   dim x dim matrix filling top bottom part   co completing remaining elements using general   pattern eigenvectors matrices   (Boshnakov 2002) . Similarly, make_mcgev computes next generalised   eigenvector chain whose previous element v. .co \"top\" eigenvalue   0. Generalised eigenvectors corresponding zero eigenvalue   specifics, better use specialised functions   case.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcev.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a multi-companion eigenvector — make_mcev","text":"make_mcev returns required eigenvector.  make_mcgev returns required generalised eigenvector.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcev.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a multi-companion eigenvector — make_mcev","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcev.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a multi-companion eigenvector — make_mcev","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a multi-companion eigenvector — make_mcev","text":"","code":"v1 <- make_mcev(0.5, c(1, 1), dim = 4) v1 #> [1] 0.5 0.5 1.0 1.0 make_mcev(0.5, c(1, 1), dim = 4, what.co = \"top\") #> [1] 1 1 2 2  v2 <- make_mcgev(0.5, c(0, 1), v = v1, what.co = \"top\") v2 #> [1]  0  1 -2  0 make_mcgev(0.5, c(0, 1), v = v2, what.co = \"top\") #> [1] 0 1 4 2"},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a multi-companion matrix from spectral description — make_mcmatrix","title":"Generate a multi-companion matrix from spectral description — make_mcmatrix","text":"Generate multi-companion matrix Jordan decomposition   spectral parameters.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a multi-companion matrix from spectral description — make_mcmatrix","text":"","code":"make_mcmatrix(type = \"real\", what.res = \"matrix\", ..., eigval0)  make_mcchains(eigval, co, dim, len.block, eigval0 = FALSE,               mo.col = NULL, what.co = \"bottom\", ...)"},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcmatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a multi-companion matrix from spectral description — make_mcmatrix","text":"eigval eigenvalues, numeric vector co seeding parameters eigenvectors, matrix dim dimension matrix, positive integer len.block lengths Jordan chains,     len.block[] eigval[]  type mode matrix, real complex .res format result, see details eigval0 TRUE completes matrix square matrix, see     details. eigval0 ignored make_mcmatrix (    always sets TRUE). ... make_mcmatrix, additional arguments passed      make_mcchains. make_mcchains, arguments               \"...\" passed  mc_0chains. mo.col last non-zero column top mc-matrix. default     dim. .co character string equal \"bottom\" (default)     \"top\", specifying whether 'co' parameters give last     first elements (generalised) eigenvectors.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcmatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a multi-companion matrix from spectral description — make_mcmatrix","text":"make_mcmatrix creates multi-companion matrix specified   spectral parameters. make_mcchains creates matrix   eigenvectors generalised eigenvectors given spectral   parameters. make_mcmatrix passes spectral parameters   make_mcchains generate (generalised) eigenvectors.   calls Jordan_matrix create corresponding Jordan   matrix.  results combined produce multicompanion   matrix.  default, real part returned, appropriate   complex spectral parameters come complex conjugate   pairs. may changed argument type. list containing   matrix Jordan factors returned .res =   \"list\". closely related function sim_mc like   make_mcmatrix need complete specification   matrix - completes   missing information (eigenvalues, co) randomly generated   entries. result functions list ordinary matrix,   use mCompanion obtain MultiCompanion object   directly. make_mcchains constructs eigensystem, make_mcmatrix   calls make_mcchains (passing ... arguments )   forms matrix. make_mcchains passes ...   arguments mc_0chains. make_mcchains creates full eigenvectors co   parameters. number vectors smaller dim   eigval0 TRUE  completes system chains   zero eigenvalue. specifically, assumes number   given chains mo.col,  takes chains corresponding   zero eigenvalue, , adds additional eigenvectors   /generalised eigenvectors construct complete system. mc-order determined dimension 'co'   parameters. equal dim, mc-matrix actually   general matrix. TODO: cover case mo < mo.col?","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a multi-companion matrix from spectral description — make_mcmatrix","text":"make_mcmatrix normally returns multi-companion matrix (  ordinary matrix) given spectral properties  .res = \"list\", returns list containing matrix   spectral information: eigval eigenvalues, vector len.block lengths Jordan chains, vector mo multi-companion order, positive integer eigvec generalied eigenvectors, matrix co seeding parameters mo.col top order mat multi-companion matrix, matrix make_mcchains returns similar list without component  mat.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcmatrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate a multi-companion matrix from spectral description — make_mcmatrix","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X . Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcmatrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate a multi-companion matrix from spectral description — make_mcmatrix","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcmatrix.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate a multi-companion matrix from spectral description — make_mcmatrix","text":"result ordinary matrix. Also, entries   0 may non-zero due numerical error. get MultiCompanion object use mCompanion.","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/make_mcmatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a multi-companion matrix from spectral description — make_mcmatrix","text":"","code":"make_mcmatrix(eigval = c(1, 0.5), co = cbind(c(1,1), c(1, -1)), dim = 4,               mo.col = 2,               len.block = c(1, 1)) #>      [,1] [,2] [,3] [,4] #> [1,] 0.75 0.25    0    0 #> [2,] 0.25 0.75    0    0 #> [3,] 1.00 0.00    0    0 #> [4,] 0.00 1.00    0    0  ## one unit root, one root = 0.5 make_mcmatrix(eigval = c(1, 0.5), co = cbind(c(1,1), c(1, -1)), dim = 6,               mo.col = 2,               len.block = c(1, 1)) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,] 0.75 0.25    0    0    0    0 #> [2,] 0.25 0.75    0    0    0    0 #> [3,] 1.00 0.00    0    0    0    0 #> [4,] 0.00 1.00    0    0    0    0 #> [5,] 0.00 0.00    1    0    0    0 #> [6,] 0.00 0.00    0    1    0    0  ## two simple unit roots, one root = 0.5 make_mcmatrix(eigval = c(1, 1, 0.5), co = cbind(c(1,1), c(1, -1), c(1, 1)), dim = 6,               mo.col = 3,               len.block = c(1, 1, 1)) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]  1.5    0 -0.5    0    0    0 #> [2,]  0.5    1 -0.5    0    0    0 #> [3,]  1.0    0  0.0    0    0    0 #> [4,]  0.0    1  0.0    0    0    0 #> [5,]  0.0    0  1.0    0    0    0 #> [6,]  0.0    0  0.0    1    0    0  ## two unit roots with a single Jordan chain, one root = 0.5 make_mcmatrix(eigval = c(1, 0.5), co = cbind(c(1,1), c(0, 1), c(1, 1)), dim = 6,               len.block = c(2, 1)) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1  0.5 -0.5    0    0    0 #> [2,]    0  1.5 -0.5    0    0    0 #> [3,]    1  0.0  0.0    0    0    0 #> [4,]    0  1.0  0.0    0    0    0 #> [5,]    0  0.0  1.0    0    0    0 #> [6,]    0  0.0  0.0    1    0    0   ## make_mcchains make_mcchains(c(1, 0.5), co = cbind(c(1,1), c(1, 1)), dim = 4,               len.block = c(1, 1), eigval0 = TRUE) #> $eigval #> [1] 1.0 0.5 0.0 0.0 #>  #> $len.block #> [1] 1 1 1 1 #>  #> $mo #> [1] 2 #>  #> $eigvec #>      [,1] [,2] [,3] [,4] #> [1,]    1  0.5    0    0 #> [2,]    1  0.5    0    0 #> [3,]    1  1.0    1    0 #> [4,]    1  1.0    0    1 #>  #> $co #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 #>  #> $mo.col #> [1] 2 #>   ## one unit root, one root = 0.5 make_mcchains(c(1, 0.5), co = cbind(c(1,1), c(1, 1)), dim = 6,               len.block = c(1, 1), eigval0 = TRUE) #> $eigval #> [1] 1.0 0.5 0.0 0.0 #>  #> $len.block #> [1] 1 1 2 2 #>  #> $mo #> [1] 2 #>  #> $eigvec #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1 0.25    0    0    0    0 #> [2,]    1 0.25    0    0    0    0 #> [3,]    1 0.50    0    1    0    0 #> [4,]    1 0.50    0    0    0    1 #> [5,]    1 1.00    1    0    0    0 #> [6,]    1 1.00    0    0    1    0 #>  #> $co #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 #>  #> $mo.col #> [1] 2 #>   ## two simple unit roots, one root = 0.5 make_mcchains(c(1, 1, 0.5), co = cbind(c(1,1), c(1, -1), c(1, 1)), dim = 6,               len.block = c(1, 1, 1), eigval0 = TRUE) #> $eigval #> [1] 1.0 1.0 0.5 0.0 0.0 #>  #> $len.block #> [1] 1 1 1 2 1 #>  #> $mo #> [1] 2 #>  #> $eigvec #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    1 0.25    0    0    0 #> [2,]    1   -1 0.25    0    0    0 #> [3,]    1    1 0.50    0    0    0 #> [4,]    1   -1 0.50    0    1    0 #> [5,]    1    1 1.00    0    0    1 #> [6,]    1   -1 1.00    1    0    0 #>  #> $co #>      [,1] [,2] [,3] #> [1,]    1    1    1 #> [2,]    1   -1    1 #>  #> $mo.col #> [1] 3 #>   ## two unit roots with a single Jordan chain, one root = 0.5 make_mcchains(c(1, 0.5), co = cbind(c(1,1), c(1, -1), c(1, 1)), dim = 6,               len.block = c(2, 1), eigval0 = TRUE) #> $eigval #> [1] 1.0 0.5 0.0 0.0 #>  #> $len.block #> [1] 2 1 2 1 #>  #> $mo #> [1] 2 #>  #> $eigvec #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    3 0.25    0    0    0 #> [2,]    1    1 0.25    0    0    0 #> [3,]    1    2 0.50    0    0    0 #> [4,]    1    0 0.50    0    1    0 #> [5,]    1    1 1.00    0    0    1 #> [6,]    1   -1 1.00    1    0    0 #>  #> $co #>      [,1] [,2] [,3] #> [1,]    1    1    1 #> [2,]    1   -1    1 #>  #> $mo.col #> [1] 3 #>     ## examples with mc-order = dim make_mcchains(c(1), co = cbind(c(1,1,1,1), c(1,2,1,1)), dim = 4,               len.block = c(2), eigval0 = TRUE) #> $eigval #> [1] 1 0 0 #>  #> $len.block #> [1] 2 1 1 #>  #> $mo #> [1] 4 #>  #> $eigvec #>      [,1] [,2] [,3] [,4] #> [1,]    1    1    0    0 #> [2,]    1    2    0    0 #> [3,]    1    1    1    0 #> [4,]    1    1    0    1 #>  #> $co #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    2 #> [3,]    1    1 #> [4,]    1    1 #>  #> $mo.col #> [1] 2 #>  ## do not complete with chians for the 0 eigval: make_mcchains(c(1), co = cbind(c(1,1,1,1), c(1,2,1,1)), dim = 4,               len.block = c(2), eigval0 = FALSE) #> $eigval #> [1] 1 #>  #> $len.block #> [1] 2 #>  #> $mo #> [1] 4 #>  #> $eigvec #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    2 #> [3,]    1    1 #> [4,]    1    1 #>  #> $co #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    2 #> [3,]    1    1 #> [4,]    1    1 #>  #> $mo.col #> [1] 2 #>   make_mcmatrix(eigval = c(1), co = cbind(c(1,1,1,1), c(1,2,1,1)), dim = 4,               len.block = c(2)) #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    0    0 #> [2,]   -1    2    0    0 #> [3,]    0    1    0    0 #> [4,]    0    1    0    0 make_mcmatrix(eigval = c(1), co = cbind(c(1,1,1,1), c(1,2,3,4)), dim = 4,               len.block = c(2)) #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    0    0 #> [2,]   -1    2    0    0 #> [3,]   -2    3    0    0 #> [4,]   -3    4    0    0"},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.complete.html","id":null,"dir":"Reference","previous_headings":"","what":"Extend or shrink eigenchains of 0 eigenvalues — mc.0chain.complete","title":"Extend or shrink eigenchains of 0 eigenvalues — mc.0chain.complete","text":"Takes Jordan chain 0 eigenvalue multi-companion   matrix modifies Jordan chain larger smaller   multi-companion matrix.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extend or shrink eigenchains of 0 eigenvalues — mc.0chain.complete","text":"","code":"mc.0chain.complete(dim, mo, chain, alt0)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extend or shrink eigenchains of 0 eigenvalues — mc.0chain.complete","text":"dim size new matrix, number. mo multi-companion order matrix. chain chain new chain derived. alt0 optional alternative initialisation free     elements, see Details.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.complete.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extend or shrink eigenchains of 0 eigenvalues — mc.0chain.complete","text":"number rows chain larger equal   mo, chain represents Jordan chain source   mc-matrix eigenvector first column. Otherwise (nrow(chain) < mo) number rows taken   mo.col Jordan chain top mo.col   x mo.col corner. case, chain extended first chain   top left mo x mo corner. Argument F0bot allows   accomplished. provides [(mo.col+1):mo, 1:mo]   block mc-matrix. dim specifies dimension modified matrix. number elements new chain may different   original eigenvector may shrunk version   original eigenvector. new Jordan chain returned matrix dim rows   number columns determined automatically. new matrix larger original, elements   last vector new chain arbitrary. default   elements set zero. Argument alt0 can used change   . vector length dim - nrow(chain).","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extend or shrink eigenchains of 0 eigenvalues — mc.0chain.complete","text":"matrix","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.complete.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extend or shrink eigenchains of 0 eigenvalues — mc.0chain.complete","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.complete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extend or shrink eigenchains of 0 eigenvalues — mc.0chain.complete","text":"","code":"x1 <- cbind(c(1,1), c(1,2)) j1 <- diag(c(0.8, 0.5)) m1 <- x1 %*% j1 %*% solve(x1) bo1 <- rbind(c(0.5, 0.8), c(0.256, 0.512))  j1a <- diag(c(0, 0.5)) m1a <- x1 %*% j1a %*% solve(x1) f1a <- cbind( rbind(m1a, bo1), 0, 0 )"},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.dx.html","id":null,"dir":"Reference","previous_headings":"","what":"Extend chains for the top — mc.0chain.dx","title":"Extend chains for the top — mc.0chain.dx","text":"Extend 0chains top left corner chains top left square   corner, internal function.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.dx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extend chains for the top — mc.0chain.dx","text":"","code":"mc.0chain.dx(mo, mo.col, chF0top, F0bot, tol0 = 1e-12)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.dx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extend chains for the top — mc.0chain.dx","text":"mo mc order mo.col mc column order, must less mo chF0top 0chains top mc matrix, list one     matrix chain F0bot bottom top mc matrix, matrix tol0 tolerance declaring vector 0","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.dx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extend chains for the top — mc.0chain.dx","text":"0chains top left mo x mo corner derived chF0top","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.dx.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extend chains for the top — mc.0chain.dx","text":"chain chF0top two possibilities.  Let   \\(v\\) eigenvector chain, .e. F0top \\(\\times   v=0\\).  F0bot \\(\\times v\\) zero vector,   corresponding chain larger matrix obtained   extending vector size mo x mo arbitrarily,   naturally 0s.  Otherwise, F0bot \\(\\times v\\)   zero vector, new eigenvector (0,...,0,F0bot   \\(\\times v\\)) (mo.col zeroes ) remaining   members chain obtained given chain   .... Notice eigenvector chF0top (  extension) becomes second member resulting chain, etc. eigenvectors (0,...0,F0bot \\(\\times v_i\\))   linearly independent job done. may linearly   dependent. case need dropped   transformation performed obtain proper Jordan chains.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.dx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extend chains for the top — mc.0chain.dx","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.struct.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute structural Jordan chains for zero eigenvalues — mc.0chain.struct","title":"Compute structural Jordan chains for zero eigenvalues — mc.0chain.struct","text":"Compute structural Jordan chains zero eigenvalues,","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.struct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute structural Jordan chains for zero eigenvalues — mc.0chain.struct","text":"","code":"mc.0chain.struct(dim, mo, mo.col, chains = list(), sort = TRUE)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.struct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute structural Jordan chains for zero eigenvalues — mc.0chain.struct","text":"dim dimension mc-matrix, positive integer mo multi-companion order mo.col top order chains list Jordan chains zero eigenvalues sort TRUE sort chains descending order lengths.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.struct.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute structural Jordan chains for zero eigenvalues — mc.0chain.struct","text":"Structural Jordan chains 0 eigenvalues present   mo.col < dim. chains empty, function assumes   structural chains span space corresponding 0 eigenvalues   (equivalently, mo.col x mo.col principal submatrix   full rank). Otherwise, chains given chains amended   structural chains. given chains usually changed   process. (Actually, mc.0chain.struct change existing   chains. adds new ones needed, since assumes   triangulation already done.) Note multi-companion matrix mo   chains corresponding eigenvalue. particular,   appropriate ignore possibility chains length larger   1, normal numerical computations, see references   details.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.struct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute structural Jordan chains for zero eigenvalues — mc.0chain.struct","text":"list following components: eigval eigenvalues (0 ), one chain len.block lengths  chains chains list one element (matrix) Jordan chain","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.struct.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute structural Jordan chains for zero eigenvalues — mc.0chain.struct","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.struct.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Compute structural Jordan chains for zero eigenvalues — mc.0chain.struct","text":"obscure particular cases need testing.","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.struct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute structural Jordan chains for zero eigenvalues — mc.0chain.struct","text":"","code":"y742t <- mc.0chain.struct(7, 4, 2) # sort = TRUE is default y742f<- mc.0chain.struct(7, 4, 2, sort = FALSE)  o <- order(y742f[[2]], decreasing = TRUE) y742fa <- lapply(y742f, function(x) x[o]) stopifnot(identical(y742t, y742fa))"},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.structfill.html","id":null,"dir":"Reference","previous_headings":"","what":"Add structural vectors to a 0eigenchain, internal function — mc.0chain.structfill","title":"Add structural vectors to a 0eigenchain, internal function — mc.0chain.structfill","text":"Add structural (generalised) eigenvectors 0eigenchain, possible.   vectors depend  elements   non-trivial part mc matrix. particular, first mo.col   elements zeroes.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.structfill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add structural vectors to a 0eigenchain, internal function — mc.0chain.structfill","text":"","code":"mc.0chain.structfill(mo, mo.col, chain, v0 = rep(0, mo))"},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.structfill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add structural vectors to a 0eigenchain, internal function — mc.0chain.structfill","text":"mo mc order mo.col mc column order chain matrix eigenvector first column successive      generalised eigenvectors following columns.  vector may      stand matrix one column. v0 vector use bottom  new vectors","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.structfill.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add structural vectors to a 0eigenchain, internal function — mc.0chain.structfill","text":" chain, possibly appended additional vectors","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.structfill.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add structural vectors to a 0eigenchain, internal function — mc.0chain.structfill","text":"size matrix deduced length vector(s)   chain. Structural chains associated zero eigenvalue appear   mo.col smaller dimension matrix. chains   depend actual values non-structural part   matrix. size, multi-companion order   mo.col fixed.  core matrix singular   structural chains describe  completely space   associated zero eigenvalue. quite straight-forward generate structural chain associated   given eigenvector complete partially given   chain. However, attempt made check supplied chain may   indeed beginning structural chain.  check   straightforward implemented since function internal   called  functions know (hopefully)   .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.0chain.structfill.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add structural vectors to a 0eigenchain, internal function — mc.0chain.structfill","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.non0chain.extend.html","id":null,"dir":"Reference","previous_headings":"","what":"Extend multi-companion eigenvectors(non0) — mC.non0chain.extend","title":"Extend multi-companion eigenvectors(non0) — mC.non0chain.extend","text":"Extend eigenchains corresponding non-zero eigenvalues   multi-companion matrix higher dimension.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.non0chain.extend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extend multi-companion eigenvectors(non0) — mC.non0chain.extend","text":"","code":"mC.non0chain.extend(ev, newdim)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc.non0chain.extend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extend multi-companion eigenvectors(non0) — mC.non0chain.extend","text":"ev eigenvalues eigenvectors, list components ???     (mc_chain_subset, etc) newdim new dimension vectors","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.non0chain.extend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extend multi-companion eigenvectors(non0) — mC.non0chain.extend","text":"eigenvectors multi-companion  matrix special   structure. function extends supplied eigenvectors   eigenvectors higher-dimensional multi-companion matrix   multi-companion order top rows extended zeroes. function handles also case first mo.col   columns top original multi-companion matrix   non-zero. may specified component mo.col   ev (otherwise mo.col set number   eigenvalues). component len.block ev may used specify   lengths Jordan chains, default 1. mo.col smaller multi-companion order,   information eigenvectors sufficient extend .   missing entries must  supplied via argument x0.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.non0chain.extend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extend multi-companion eigenvectors(non0) — mC.non0chain.extend","text":"eigenvectors extended new dimension.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.non0chain.extend.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extend multi-companion eigenvectors(non0) — mC.non0chain.extend","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc.non0chain.extend.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extend multi-companion eigenvectors(non0) — mC.non0chain.extend","text":"mostly internal function. user function mc_chain_extend.","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec-class.html","id":null,"dir":"Reference","previous_headings":"","what":"A class for spectral specifications of multi-companion matrices — mcSpec-class","title":"A class for spectral specifications of multi-companion matrices — mcSpec-class","text":"class spectral specifications multi-companion matrices.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"A class for spectral specifications of multi-companion matrices — mcSpec-class","text":"Objects can created calls one following equivalent   forms: mcSpec(dim, mo, root1, iorder, siorder, order, evtypes, ...), new(\"mcSpec\", dim, mo, root1, iorder, siorder, order, evtypes, ...).  object class \"mcSpec\" holds spectral specification square   multi-companion matrix. specification may partial.   case unspecified components set NA. Eigenvalues represented modulus complex argument.   argument cycles per unit time. , negative real number   argument 0.5. complex eigenvalues come pairs one needs   specified. eigenvalue simple,   repeated. Rather, size corresponding Jordan   block specified. types eigenvalues may \"r\" (real) \"cp\" (complex   pair). See mcSpec full details initialization   function class mcSpec.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"A class for spectral specifications of multi-companion matrices — mcSpec-class","text":"dim: dimension matrix, positive integer. mo: multi-companion order, positive integer. ev.type: Types eigenvalues, \"r\" \"cp\",       character vector. co.type: Types co parameters,       character vector. order: orders factors, default       rep(dim,mo). n.root: number nonzero roots. ev.abs: absolute values (moduli) roots. ev.arg: complex arguments roots (cycles per       unit time). particular, zero positive reals, 0.5       negative reals. (TODO: check functions use       specification know !) block.length: sizes Jordan blocks corresponding       eigenvalues, vector positive integers. default       eigenvalues simple. co.abs: moduli co parameters, matrix. co.arg: arguments co parameters,       matrix. mo.col: Object class \"numeric\". F0bot: Object class \"optionalMatrix\".","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"A class for spectral specifications of multi-companion matrices — mcSpec-class","text":"initialize signature(.Object = \"mcSpec\"):         see mcSpec.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A class for spectral specifications of multi-companion matrices — mcSpec-class","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"A class for spectral specifications of multi-companion matrices — mcSpec-class","text":"initialization function mcSpec class incomplete,   sense cover cases.","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A class for spectral specifications of multi-companion matrices — mcSpec-class","text":"","code":"mcSpec(dim = 5, mo = 4, root1 = c(1,1), order = rep(3,4)) #> An object of class \"mcSpec\" #> Slot \"dim\": #> [1] 5 #>  #> Slot \"mo\": #> [1] 4 #>  #> Slot \"ev.type\": #> [1] \"r\" \"r\" \"r\" \"r\" \"r\" #>  #> Slot \"co.type\": #> character(0) #>  #> Slot \"order\": #> [1] 3 3 3 3 #>  #> Slot \"n.root\": #> [1] 3 #>  #> Slot \"ev.abs\": #> [1]  1  1  0  0 NA #>  #> Slot \"ev.arg\": #> [1]  0  0  0  0 NA #>  #> Slot \"block.length\": #> [1] 1 1 1 1 1 #>  #> Slot \"co.abs\": #>      [,1] [,2] [,3] [,4] [,5] #> [1,]   NA   NA    0    0   NA #> [2,]   NA   NA    0    0   NA #> [3,]   NA   NA    1    0   NA #> [4,]   NA   NA    0    1   NA #>  #> Slot \"co.arg\": #>      [,1] [,2] [,3] [,4] [,5] #> [1,]   NA   NA    0    0   NA #> [2,]   NA   NA    0    0   NA #> [3,]   NA   NA    0    0   NA #> [4,]   NA   NA    0    0   NA #>  #> Slot \"mo.col\": #> [1] 3 #>  #> Slot \"F0bot\": #> NULL #>  mcSpec(dim = 5, mo = 4, root1 = c(1,1,1), order = rep(5,4)) #> An object of class \"mcSpec\" #> Slot \"dim\": #> [1] 5 #>  #> Slot \"mo\": #> [1] 4 #>  #> Slot \"ev.type\": #> [1] \"r\"  \"r\"  \"r\"  \"cp\" #>  #> Slot \"co.type\": #> character(0) #>  #> Slot \"order\": #> [1] 5 5 5 5 #>  #> Slot \"n.root\": #> [1] 5 #>  #> Slot \"ev.abs\": #> [1]  1  1  1 NA #>  #> Slot \"ev.arg\": #> [1]  0  0  0 NA #>  #> Slot \"block.length\": #> [1] 1 1 1 1 #>  #> Slot \"co.abs\": #>      [,1] [,2] [,3] [,4] #> [1,]   NA   NA   NA   NA #> [2,]   NA   NA   NA   NA #> [3,]   NA   NA   NA   NA #> [4,]   NA   NA   NA   NA #>  #> Slot \"co.arg\": #>      [,1] [,2] [,3] [,4] #> [1,]   NA   NA   NA   NA #> [2,]   NA   NA   NA   NA #> [3,]   NA   NA   NA   NA #> [4,]   NA   NA   NA   NA #>  #> Slot \"mo.col\": #> [1] 5 #>  #> Slot \"F0bot\": #> NULL #>  mcSpec(dim = 5, mo = 4, root1 = c(1,1,1,1), order = rep(5,4)) #> An object of class \"mcSpec\" #> Slot \"dim\": #> [1] 5 #>  #> Slot \"mo\": #> [1] 4 #>  #> Slot \"ev.type\": #> [1] \"r\" \"r\" \"r\" \"r\" \"r\" #>  #> Slot \"co.type\": #> character(0) #>  #> Slot \"order\": #> [1] 5 5 5 5 #>  #> Slot \"n.root\": #> [1] 5 #>  #> Slot \"ev.abs\": #> [1]  1  1  1  1 NA #>  #> Slot \"ev.arg\": #> [1]  0  0  0  0 NA #>  #> Slot \"block.length\": #> [1] 1 1 1 1 1 #>  #> Slot \"co.abs\": #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    0    0    0   NA #> [2,]    0    1    0    0   NA #> [3,]    0    0    1    0   NA #> [4,]    0    0    0    1   NA #>  #> Slot \"co.arg\": #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    0    0   NA #> [2,]    0    0    0    0   NA #> [3,]    0    0    0    0   NA #> [4,]    0    0    0    0   NA #>  #> Slot \"mo.col\": #> [1] 5 #>  #> Slot \"F0bot\": #> NULL #>"},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate objects of class mcSpec — mcSpec","title":"Generate objects of class mcSpec — mcSpec","text":"Generate objects class mcSpec.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate objects of class mcSpec — mcSpec","text":"","code":"mcSpec(...)  # S4 method for mcSpec initialize(.Object, dim, mo, root1 = numeric(0), iorder = 0,            siorder = 0, order = rep(dim, mo), evtypes = NULL,            mo.col = NULL, n.roots = mo.col, ...)"},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate objects of class mcSpec — mcSpec","text":"dim dimension, positive integer. mo multi-companion order, .k.. number seasons. root1 roots equal one, vector positive integers     length mo. iorder integration order, non-negative integer. siorder seasonal integration order, non-negative integer. order order periodic filter, vector length            mo. evtypes types additional eigenvalues, see Details. mo.col number non-zero columns top part     multicompanion matrix, see Details. n.roots number non-zero roots ... arguments passed . .Object object. argument used calls     mcSpec new, see details section.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate objects of class mcSpec — mcSpec","text":"mcSpec(...) new(\"mcSpec\", ...) create objects   class mcSpec. two calls equivalent may contain   arguments initialize method described , except   .Object generated automatically.   cases initialize method called passed   arguments. Several ways provided specification unit roots   may combined, long specification consistent. roots1 specifies eigenvalues equal 1 size   Jordan chains. iorder siorder provide convenient   shortcuts special cases cover. iorder specifies integration order. corresponds   operator \\((1-B)\\) applied iorder times. Similarly, siorder specifies seasonal integration order,   corresponds operator \\((1-B^s)\\) applied siorder   times, \\(s\\) equal mo. argument generates   mo unit roots, height (dimension Jordan chain)   siorder. possible use combinations arguments specify   unit roots specifications combined. Care must taken   exceed dim. mo.col missing, set max(order).   mo.col may also character string \"+ones\". case   dimension unit roots added max(order).   mo.col may also set directly giving appropriate   integer value. TODO: Need checks consistency ! TODO: describe roots eigenvectors! specified quantities prepared, rest set NA's. eigenvalues specified, additional eigenvalues   introduced reach dimension dim. default, even   number eigenvalues needed, specified complex   pairs, \"cp\". number odd, one real eigenvalue specified   rest set \"cp\". Argument evtypes can used select different setting   additional eigenvalues.  character vector \"r\"   stands real eigenavalues \"cp\" stands complex pair.   example, two \"free\" eigenvalues, automatic choice   complex pair, \"cp\". two real eigenvalues desired set   evtypes c(\"r\",\"r\"). Note: evtypes types additional eigenvalues.   specify types eigenvalues equal one zero.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate objects of class mcSpec — mcSpec","text":"object class mcSpec","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate objects of class mcSpec — mcSpec","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X . Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate objects of class mcSpec — mcSpec","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mcSpec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate objects of class mcSpec — mcSpec","text":"","code":"spec2 <- mcSpec(21, 4, siorder=2, iorder=1) spec4 <- mcSpec(11, 4, siorder=1, iorder=1) spec.co2 <- mcSpec(dim = 5, mo = 4, siorder = 1) spec.co2new <- mcSpec(dim = 5, mo = 4, siorder = 1) # after correcting ev.arg spec.co2alt <- mcSpec(dim = 6, mo = 4, siorder = 1)  spec.co3 <- mcSpec(dim = 5, mo = 4, root1 = c(1,1,1))  spec.coz1 <- mcSpec(dim = 4, mo = 4, root1 = c(1,1), order = rep(2,4)) # test0 roots spec.coz2 <- mcSpec(dim = 5, mo = 4, root1 = c(1,1), order = rep(2,4)) # test0 roots spec.coz3 <- mcSpec(dim = 4, mo = 4, root1 = c(1), order = rep(2,4)) # test0 roots spec.co4 <- mcSpec(dim = 4, mo = 4, root1 = c(1,1,1))"},{"path":"https://geobosh.github.io/mcompanion/reference/mcStable.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an object is stable — mcStable","title":"Check if an object is stable — mcStable","text":"Check object stable.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcStable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an object is stable — mcStable","text":"","code":"mcStable(x)"},{"path":"https://geobosh.github.io/mcompanion/reference/mcStable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an object is stable — mcStable","text":"x object checked","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcStable.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check if an object is stable — mcStable","text":"stable matrix matrix whose eigenvalues moduli less   one. objects stable associated matrix   stable. generic function. default method works follows.   x square matrix, method checks eigenvalues   satisfy stability condition returns result. Otherwise, x rectangular matrix columns   rows, assumed top multi-companion matrix.   x vector, assumed represent top row   companion matrix. cases x converted matrix   .matrix(x). result square matrix whose   eigenvalues checked.   error matrix rows columns.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcStable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an object is stable — mcStable","text":"TRUE object stable  FALSE otherwise","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcStable.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check if an object is stable — mcStable","text":"argument ... may good idea since methods may wish   provide options. example, continuous   time systems, stability condition real parts   eigenvalues negative. example, option choose left half-plane stable   region, instead unit circle, handle stability   continuous time systems.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcStable.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check if an object is stable — mcStable","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcStable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an object is stable — mcStable","text":"","code":"## a simulated matrix (it is stable by default) mc <- mCompanion(\"sim\", dim=4, mo=2) mcStable(mc) #> [1] TRUE  ## a square matrix m <- matrix(1:9, nrow=3) eigen(m)$values #> [1]  1.611684e+01 -1.116844e+00 -1.576734e-16 mcStable(m) #> [1] FALSE  ## a 2x4 matrix, taken to be the top of an mc matrix m <- matrix(1:8, nrow=2) mcStable(m) #> [1] FALSE mCompanion(m) #> 4 x 4 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] #> [1,]    1    3    5    7 #> [2,]    2    4    6    8 #> [3,]    1    0    0    0 #> [4,]    0    1    0    0  ## a vector, taken to be the top row of an mc matrix v <- 1:4 mcStable(v) #> [1] FALSE mCompanion(v) #> 4 x 4 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    3    4 #> [2,]    1    0    0    0 #> [3,]    0    1    0    0 #> [4,]    0    0    1    0 abs(mc_eigen(mCompanion(v))$values) #> [1] 2.517996 1.179913 1.179913 1.141051  co1 <- cbind(c(1,1,1,1), c(0,1,0,0))  ## a matrix with eigenvalues equal to 1 mat2 <- make_mcmatrix(eigval = c(1), co = co1, dim = 4, len.block = c(2)) ## mat2 is ordinary matrix, eigenvalues are computed numerically eigen(mat2) #> eigen() decomposition #> $values #> [1] 1 1 0 0 #>  #> $vectors #>      [,1] [,2] [,3] [,4] #> [1,]  0.5 -0.5    0    0 #> [2,]  0.5 -0.5    0    0 #> [3,]  0.5 -0.5    1    0 #> [4,]  0.5 -0.5    0    1 #>  mcStable(mat2)  # FALSE but in general depends on floating point arithmetic #> [1] FALSE  mat2a <- mCompanion(x=\"gen\", eigval = c(1), co = co1, dim = 4, len.block = c(2), what.res = \"list\") mc_eigen(mat2a) #> $values #> [1] 1 0 0 #>  #> $vectors #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    1    1    0    0 #> [3,]    1    0    1    0 #> [4,]    1    0    0    1 #>  #> $len.block #> [1] 2 1 1 #>  mcStable(mat2a) #> [1] FALSE   mat2b0 <- make_mcmatrix(eigval = c(1), co = co1, dim = 4, len.block = c(2), what = \"list\") mat2b <- mCompanion(mat2b0, \"gen\") mc_eigen(mat2b) #> $values #> [1] 1 0 0 #>  #> $vectors #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    1    1    0    0 #> [3,]    1    0    1    0 #> [4,]    1    0    0    1 #>  #> $len.block #> [1] 2 1 1 #>  mcStable(mat2b) #> [1] FALSE  ## mat2c is a MultiCompanion object with the eigenvalues stored in it mat2c <- mCompanion(x=\"sim\", eigval = c(1,0,0), co = cbind(co1, c(0,0,1,0), c(0,0,0,1)),                     dim = 4, len.block = c(2,1,1)) mat2c #> 4 x 4 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    0    0 #> [2,]   -1    2    0    0 #> [3,]    0    1    0    0 #> [4,]    0    1    0    0 ## since the eigenvalues are directly available here, no need to compute them mc_eigen(mat2c) # contains a 2x2 Jordan block. #> $values #> [1] 1 0 0 #>  #> $vectors #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    1    1    0    0 #> [3,]    1    0    1    0 #> [4,]    1    0    0    1 #>  #> $len.block #> [1] 2 1 1 #>  mcStable(mat2c) #> [1] FALSE"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_0chains.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate eigenchains for zero eigenvalues — mc_0chains","title":"Generate eigenchains for zero eigenvalues — mc_0chains","text":"Generate eigenchains zero eigenvalues multi-companion matrices","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_0chains.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate eigenchains for zero eigenvalues — mc_0chains","text":"","code":"mc_0chains(dim, mo, mo.col, vec0, flagtriang = TRUE)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_0chains.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate eigenchains for zero eigenvalues — mc_0chains","text":"dim dimension matrix mo multi-companion order mo.col number (non-zero) structural columns vec0 list Jordan chains non-structural zero     eigenvalues, see details  flagtriang triangulase vectors?","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_0chains.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate eigenchains for zero eigenvalues — mc_0chains","text":"Non-structural eigenvectors zero eigenvalues may specified   vec0 argument. list one element   non-structural 0 eigenvalue. element matrix seeding   chain corresponding chain (!!! edit !!!) enough   number rows (least multi-companion order). often   zero chain mc matrix smaller larger size. case   vectors chain extended shrinked, respectively. However,   extending shrinking 0-chains different ordinary   case non-zero eigenvalues involves increasing decreasing   number vectors chain. vec0 missing equal list() function   assumes 0 eigenvalues structural ones, .e.   0 eigenvalues among remaining eigenvalues.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_0chains.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate eigenchains for zero eigenvalues — mc_0chains","text":"list elements eigval, len.block, eigvec,   chains. may easily merged output  make_mcev.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_0chains.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate eigenchains for zero eigenvalues — mc_0chains","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_0chains.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate eigenchains for zero eigenvalues — mc_0chains","text":"function covers possibilities tested   properly case non-structural 0 eigenvalues present. TODO: Prepare meaningful examples tests. 2015-12-27: dropped argument F0bot. old signature   mc_0chains(dim, mo, mo.col, vec0, F0bot = NULL, flagtriang = TRUE).","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mc_0chains.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate eigenchains for zero eigenvalues — mc_0chains","text":"","code":"mc_0chains(6, 4, 1) #> $eigval #> [1] 0 0 0 0 #>  #> $len.block #> [1] 2 1 1 1 #>  #> $chains #> $chains[[1]] #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    1 #> [3,]    0    0 #> [4,]    0    0 #> [5,]    0    0 #> [6,]    1    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    1 #> [4,]    0 #> [5,]    0 #> [6,]    0 #>  #> $chains[[3]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    1 #> [5,]    0 #> [6,]    0 #>  #> $chains[[4]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #>  #> $eigvec #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    0    0    0 #> [2,]    0    1    0    0    0 #> [3,]    0    0    1    0    0 #> [4,]    0    0    0    1    0 #> [5,]    0    0    0    0    1 #> [6,]    1    0    0    0    0 #>  mc_0chains(6, 4, 2) #> $eigval #> [1] 0 0 0 0 #>  #> $len.block #> [1] 1 1 1 1 #>  #> $chains #> $chains[[1]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    1 #> [4,]    0 #> [5,]    0 #> [6,]    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    1 #> [5,]    0 #> [6,]    0 #>  #> $chains[[3]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #> $chains[[4]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    0 #> [6,]    1 #>  #>  #> $eigvec #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    1    0    0    0 #> [4,]    0    1    0    0 #> [5,]    0    0    1    0 #> [6,]    0    0    0    1 #>  mc_0chains(6, 4, 3) #> $eigval #> [1] 0 0 0 #>  #> $len.block #> [1] 1 1 1 #>  #> $chains #> $chains[[1]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    1 #> [5,]    0 #> [6,]    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #> $chains[[3]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    0 #> [6,]    1 #>  #>  #> $eigvec #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #> [4,]    1    0    0 #> [5,]    0    1    0 #> [6,]    0    0    1 #>  mc_0chains(6, 4, 4) #> $eigval #> [1] 0 0 #>  #> $len.block #> [1] 1 1 #>  #> $chains #> $chains[[1]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    0 #> [6,]    1 #>  #>  #> $eigvec #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    0 #> [5,]    1    0 #> [6,]    0    1 #>   mc_0chains(6, 2, 2) #> $eigval #> [1] 0 0 #>  #> $len.block #> [1] 2 2 #>  #> $chains #> $chains[[1]] #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    1 #> [4,]    0    0 #> [5,]    1    0 #> [6,]    0    0 #>  #> $chains[[2]] #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    1 #> [5,]    0    0 #> [6,]    1    0 #>  #>  #> $eigvec #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    1    0    0 #> [4,]    0    0    0    1 #> [5,]    1    0    0    0 #> [6,]    0    0    1    0 #>  mc_0chains(6, 2, 4) #> $eigval #> [1] 0 0 #>  #> $len.block #> [1] 1 1 #>  #> $chains #> $chains[[1]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    0 #> [6,]    1 #>  #>  #> $eigvec #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    0 #> [5,]    1    0 #> [6,]    0    1 #>  mc_0chains(6, 2, 3) #> $eigval #> [1] 0 0 #>  #> $len.block #> [1] 2 1 #>  #> $chains #> $chains[[1]] #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    1 #> [5,]    0    0 #> [6,]    1    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #>  #> $eigvec #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #> [4,]    0    1    0 #> [5,]    0    0    1 #> [6,]    1    0    0 #>  mc_0chains(6, 2, 3, list(matrix(1,              ncol=1, nrow=6))) #> $eigval #> [1] 0 0 0 #>  #> $len.block #> [1] 2 1 1 #>  #> $chains #> $chains[[1]] #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    1 #> [5,]    0    0 #> [6,]    1    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    1 #> [2,]    1 #> [3,]    1 #> [4,]    1 #> [5,]    1 #> [6,]    1 #>  #> $chains[[3]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #>  #> $eigvec #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    1    0 #> [2,]    0    0    1    0 #> [3,]    0    0    1    0 #> [4,]    0    1    1    0 #> [5,]    0    0    1    1 #> [6,]    1    0    1    0 #>  mc_0chains(6, 2, 3, list(matrix(c(1,0,0,0,0,0), ncol=1, nrow=6))) #> $eigval #> [1] 0 0 0 #>  #> $len.block #> [1] 2 1 1 #>  #> $chains #> $chains[[1]] #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    1 #> [5,]    0    0 #> [6,]    1    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    1 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    0 #> [6,]    0 #>  #> $chains[[3]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #>  #> $eigvec #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    1    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    1    0    0 #> [5,]    0    0    0    1 #> [6,]    1    0    0    0 #>  mc_0chains(6, 2, 3, list(matrix(c(0,1,0,0,0,0), ncol=1, nrow=6))) #> $eigval #> [1] 0 0 0 #>  #> $len.block #> [1] 2 1 1 #>  #> $chains #> $chains[[1]] #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    1 #> [5,]    0    0 #> [6,]    1    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    0 #> [2,]    1 #> [3,]    0 #> [4,]    0 #> [5,]    0 #> [6,]    0 #>  #> $chains[[3]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #>  #> $eigvec #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    1    0 #> [3,]    0    0    0    0 #> [4,]    0    1    0    0 #> [5,]    0    0    0    1 #> [6,]    1    0    0    0 #>  mc_0chains(6, 2, 3, list(matrix(c(0,0,0,0,0,1), ncol=1, nrow=6))) #> $eigval #> [1] 0 0 #>  #> $len.block #> [1] 2 1 #>  #> $chains #> $chains[[1]] #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    1 #> [5,]    0    0 #> [6,]    1    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #>  #> $eigvec #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #> [4,]    0    1    0 #> [5,]    0    0    1 #> [6,]    1    0    0 #>  mc_0chains(6, 2, 3, list(matrix(c(0,0,0,0,1,0), ncol=1, nrow=6))) #> $eigval #> [1] 0 0 #>  #> $len.block #> [1] 2 1 #>  #> $chains #> $chains[[1]] #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    1 #> [5,]    0    0 #> [6,]    1    0 #>  #> $chains[[2]] #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    1 #> [6,]    0 #>  #>  #> $eigvec #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #> [4,]    0    1    0 #> [5,]    0    0    1 #> [6,]    1    0    0 #>   mc_0chains(2, 2, 2,list(matrix(c(0,1),ncol=1,nrow=2))) #> $eigval #> [1] 0 #>  #> $len.block #> [1] 1 #>  #> $chains #> $chains[[1]] #>      [,1] #> [1,]    0 #> [2,]    1 #>  #>  #> $eigvec #>      [,1] #> [1,]    0 #> [2,]    1 #>   mc_0chains(12,4,2) #> $eigval #> [1] 0 0 0 0 #>  #> $len.block #> [1] 3 3 2 2 #>  #> $chains #> $chains[[1]] #>       [,1] [,2] [,3] #>  [1,]    0    0    0 #>  [2,]    0    0    0 #>  [3,]    0    0    1 #>  [4,]    0    0    0 #>  [5,]    0    0    0 #>  [6,]    0    0    0 #>  [7,]    0    1    0 #>  [8,]    0    0    0 #>  [9,]    0    0    0 #> [10,]    0    0    0 #> [11,]    1    0    0 #> [12,]    0    0    0 #>  #> $chains[[2]] #>       [,1] [,2] [,3] #>  [1,]    0    0    0 #>  [2,]    0    0    0 #>  [3,]    0    0    0 #>  [4,]    0    0    1 #>  [5,]    0    0    0 #>  [6,]    0    0    0 #>  [7,]    0    0    0 #>  [8,]    0    1    0 #>  [9,]    0    0    0 #> [10,]    0    0    0 #> [11,]    0    0    0 #> [12,]    1    0    0 #>  #> $chains[[3]] #>       [,1] [,2] #>  [1,]    0    0 #>  [2,]    0    0 #>  [3,]    0    0 #>  [4,]    0    0 #>  [5,]    0    1 #>  [6,]    0    0 #>  [7,]    0    0 #>  [8,]    0    0 #>  [9,]    1    0 #> [10,]    0    0 #> [11,]    0    0 #> [12,]    0    0 #>  #> $chains[[4]] #>       [,1] [,2] #>  [1,]    0    0 #>  [2,]    0    0 #>  [3,]    0    0 #>  [4,]    0    0 #>  [5,]    0    0 #>  [6,]    0    1 #>  [7,]    0    0 #>  [8,]    0    0 #>  [9,]    0    0 #> [10,]    1    0 #> [11,]    0    0 #> [12,]    0    0 #>  #>  #> $eigvec #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    0    0    0    0    0    0    0    0    0     0 #>  [2,]    0    0    0    0    0    0    0    0    0     0 #>  [3,]    0    0    1    0    0    0    0    0    0     0 #>  [4,]    0    0    0    0    0    1    0    0    0     0 #>  [5,]    0    0    0    0    0    0    0    1    0     0 #>  [6,]    0    0    0    0    0    0    0    0    0     1 #>  [7,]    0    1    0    0    0    0    0    0    0     0 #>  [8,]    0    0    0    0    1    0    0    0    0     0 #>  [9,]    0    0    0    0    0    0    1    0    0     0 #> [10,]    0    0    0    0    0    0    0    0    1     0 #> [11,]    1    0    0    0    0    0    0    0    0     0 #> [12,]    0    0    0    1    0    0    0    0    0     0 #>"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_extend.html","id":null,"dir":"Reference","previous_headings":"","what":"Extend multi-companion eigenvectors — mc_chain_extend","title":"Extend multi-companion eigenvectors — mc_chain_extend","text":"Extend Jordan chains multi-companion matrix higher dimension   complete full system adding eigenchains zero   eigenvalues.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_extend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extend multi-companion eigenvectors — mc_chain_extend","text":"","code":"mc_chain_extend(ev, newdim)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_extend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extend multi-companion eigenvectors — mc_chain_extend","text":"ev eigenvalues eigenvectors, list components values     vectors. newdim new dimension vectors.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_extend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extend multi-companion eigenvectors — mc_chain_extend","text":"eigenvectors multi-companion  matrix special   structure. function extends supplied eigenvectors   eigenvectors higher-dimensional multi-companion matrix   multi-companion order top rows extended zeroes. ev list components values, vectors   possibly others. particular, ev may value returned   call base function eigen().  component   len.block may used specify lengths Jordan   chains, default length one. function handles also case first mo.col   columns top original multi-companion matrix   non-zero. may specified component mo.col   ev, otherwise mo.col set dimension   space spanned non-zero eigenvalues. mo.col smaller multi-companion order,   information eigenvectors sufficient extend .   missing entries supplied via argument F0bot   (TODO: describe!). Chains corresponding zero eigenvalues come last result.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_extend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extend multi-companion eigenvectors — mc_chain_extend","text":"eigenvectors extended new dimension.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_extend.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extend multi-companion eigenvectors — mc_chain_extend","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X . Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_extend.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extend multi-companion eigenvectors — mc_chain_extend","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_extend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extend multi-companion eigenvectors — mc_chain_extend","text":"","code":"ev <- make_mcchains(eigval = c(1, 0.5), co = cbind(c(1,1), c(1, -1)), dim = 4,               mo.col = 2,               len.block = c(1, 1)) ev #> $eigval #> [1] 1.0 0.5 #>  #> $len.block #> [1] 1 1 #>  #> $mo #> [1] 2 #>  #> $eigvec #>      [,1] [,2] #> [1,]    1  0.5 #> [2,]    1 -0.5 #> [3,]    1  1.0 #> [4,]    1 -1.0 #>  #> $co #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1   -1 #>  #> $mo.col #> [1] 2 #>  ## extend evecs in ev to the requested dim and complete with chains for eval 0. mc_chain_extend(ev = ev, newdim = 6) #> $mo #> [1] 2 #>  #> $mo.col #> [1] 2 #>  #> $eigval #> [1] 1.0 0.5 0.0 0.0 #>  #> $len.block #> [1] 1 1 2 2 #>  #> $eigvec #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1  0.5    0    0    0    0 #> [2,]    1 -0.5    0    0    0    0 #> [3,]    1  1.0    0    1    0    0 #> [4,]    1 -1.0    0    0    0    1 #> [5,]    1  2.0    1    0    0    0 #> [6,]    1 -2.0    0    0    1    0 #>  #> $co #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    2    1    0    0    0 #> [2,]    1   -2    0    0    1    0 #>  mc_chain_extend(ev = ev, newdim = 7) #> $mo #> [1] 2 #>  #> $mo.col #> [1] 2 #>  #> $eigval #> [1] 1.0 0.5 0.0 0.0 #>  #> $len.block #> [1] 1 1 3 2 #>  #> $eigvec #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]    1  0.5    0    0    0    0    0 #> [2,]    1 -0.5    0    0    0    0    0 #> [3,]    1  1.0    0    0    1    0    0 #> [4,]    1 -1.0    0    0    0    0    1 #> [5,]    1  2.0    0    1    0    0    0 #> [6,]    1 -2.0    0    0    0    1    0 #> [7,]    1  4.0    1    0    0    0    0 #>  #> $co #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]    1   -2    0    0    0    1    0 #> [2,]    1    4    1    0    0    0    0 #>"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_scale.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale vectors in eigenchains of multi-companion matrices — mc_chain_scale","title":"Scale vectors in eigenchains of multi-companion matrices — mc_chain_scale","text":"Scale vectors eigenchain multi-companion matrix. Currently   factor determined seeding coefficient   maximal value becomes equal one. default seeding   coefficients bottom examined.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_scale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale vectors in eigenchains of multi-companion matrices — mc_chain_scale","text":"","code":"mc_chain_scale(ev, subset = NULL, fvec = NULL, fchain = NULL)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_scale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale vectors in eigenchains of multi-companion matrices — mc_chain_scale","text":"ev eigenvectors, list elements \"eigvec\",     \"len.block\".    subset subset eigenvectors examine, string     vector integers suitable indexing. fvec function computation normailising factor,     see Details. fchain can used specify general transformation,     function, see Details.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_scale.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scale vectors in eigenchains of multi-companion matrices — mc_chain_scale","text":"vectors chain scaled factor. factor determined seeding coefficient   maximal modulus becomes equal one. default seeding   coefficients bottom eigenvector examined   argument subset equal \"top\" tops checked   instead. subset may also vector integers used   index select desired subset. Argument fvec may used specify method   modulus normalising factor. fvec function two   arguments, first eigenvector second index   vector. Argument fchain may used specify completely different   way normailse chain. fchain function one   argument, chain, can transformation chain.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_scale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale vectors in eigenchains of multi-companion matrices — mc_chain_scale","text":"list ev desired transformations done.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_scale.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Scale vectors in eigenchains of multi-companion matrices — mc_chain_scale","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal utilities for mc eigenvectors — mc_chain_subset","title":"Internal utilities for mc eigenvectors — mc_chain_subset","text":"Utilities manipulation mc eigenchains:   subset, merge.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal utilities for mc eigenvectors — mc_chain_subset","text":"","code":"mc_chain_subset(ev, chainno) mc_chain_merge(ev1, ev2)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal utilities for mc eigenvectors — mc_chain_subset","text":"ev eigensystem, list, see details. ev1 chain, list. ev2 chain, list. chainno chains extract, integer vector.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal utilities for mc eigenvectors — mc_chain_subset","text":"mc_chain_subset mc_chain_merge, list   format ev1 ev2","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_subset.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Internal utilities for mc eigenvectors — mc_chain_subset","text":"lists representing eigensystems (ev, ev1,   ev2)  following structure:  chain elements represented  empty list. component co non-NULL, processed expected.    may also NULL absent. case NULL result   returned mc_chain_subset, similarly mc_chain_merge   since two arguments, see details . mc_chain_subset takes subsystem ev, basically   ev$eigval[chaino], etc, catering also possibility   chains length greater one. chainno specifies   chains take (omit) usual R index syntax. mc_chain_merge concatenates two chains.  co   NULL arguments, NULL result. Otherwise co   set bottom parts vectors. Components mo   mo.col two chains currently   checked.","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chain_subset.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Internal utilities for mc eigenvectors — mc_chain_subset","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chains_triangulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Triangulate a system of 0eigenvectors — mc_chains_triangulate","title":"Triangulate a system of 0eigenvectors — mc_chains_triangulate","text":"Triangulate system 0eigenchains.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chains_triangulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Triangulate a system of 0eigenvectors — mc_chains_triangulate","text":"","code":"mc_chains_triangulate(chains, mo, mo.col)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chains_triangulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Triangulate a system of 0eigenvectors — mc_chains_triangulate","text":"chains chains, see details mo mc order mo.col mc column order","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chains_triangulate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Triangulate a system of 0eigenvectors — mc_chains_triangulate","text":" modified chains, list","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chains_triangulate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Triangulate a system of 0eigenvectors — mc_chains_triangulate","text":"mc_chains_triangulate triangulates set chains make easier   extend 0chains. chains  list chains 0 eigenvalue   mcmatrix. chain represented matrix eigenvector   first column. multi-companion matrix maximum number chains   eigenvalue  mo. last mo elements eigenvectors mc matrices   corresponding zero eigenvalue may non-zero. mc_chains_triangulate triangulates eigenvectors following   sense. Let \\(i_1\\) first non-zero element first   eigenvector. elements position \\(i_1\\) remaining   eigenvectors made equal zero adding multiple   first eigenvector. corresponding transformation done   remaining elements chains remain proper   chains. position, \\(i_2\\), first non-zero element   second eigenvector found elements third   following eigenvectors position made zero adding   multiple second eigenvector. process repeated   last eigenvector reached. mo 4 4 chains, example,   procedure typically transform bottom \\(4\\times4\\) block   matrix obtained 4 eigenvectors lower triangular   matrix. zero elements original bottom   \\(4\\times4\\) block, result lower triangular   matrix shape equivalent purposes extending   eigenvectors. todo: describe precisely separate document,         vzh. rakopisnite belezhki za izpolzvaniya algoritam. todo: probably worth somewhat elaborately         numerical stability. todo: function specific zero eigenchains.         can used put canonic order eigenchain (        check).         Change name? todo: strictly speaking, canonical order needed         chains heights.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_chains_triangulate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Triangulate a system of 0eigenvectors — mc_chains_triangulate","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mc_eigen.html","id":null,"dir":"Reference","previous_headings":"","what":"The eigen decomposition of a multi-companion matrix — mc_eigen","title":"The eigen decomposition of a multi-companion matrix — mc_eigen","text":"Give eigenvalues entire eigen decomposition   multi-companion matrix","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_eigen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The eigen decomposition of a multi-companion matrix — mc_eigen","text":"","code":"mc_eigen(x, ...) mc_eigenvalues(x, ...)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_eigen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The eigen decomposition of a multi-companion matrix — mc_eigen","text":"x multi-companion matrix, object class MultiCompanion. ... additional arguments, currently used.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_eigen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The eigen decomposition of a multi-companion matrix — mc_eigen","text":"functions first check decomposition stored   x , case, return result without   computations. particularly useful matrix created   spectral decomposition first place.   restrictions result case come structure   multi-companion matrices. Otherwise use eigen main computation.   addition, top matrix structural columns zeroes,   mc_eigen takes care call eigen sub-matrix   whose last column zero, handles zero eigenvalues   separately. Note x@mo.col last column containing nonzero   elements top matrix. calling eigen top   left x@mo.col square block, rather entire matrix,   achieve several things. Firstly, block may turn   non-singular. case, chains corresponding zero   eigenvalues, , structural straightforward. Secondly,   block turns singular, know reducing   dimension left elements corresponding zero   eigenvalues. vectors associated zero eigenvalues somewhat   tricky case, manageable. net effect restriction comes use   eigen, handle Jordan chains length larger   one.  general, problem, since chains   one vector likely occur numerically. particular,   relatively safe assume space spanned non-zero   eigenvalues multicompanion matrix basis   eigenvectors. However, x@mo.col smaller   dimension matrix, eigenchains associated zero value   can easily occur, due structure matrix.    pay special attention . mc_eigen handling zero eigenvalues based   mc_chain_extend.  latter takes care also zero   eigenvalues whose Jordan blocks size larger one.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_eigen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The eigen decomposition of a multi-companion matrix — mc_eigen","text":"mc_eigenvalues, eigenvalues vector. mc_eigen, eigenvalues eigenvectors list   components values vectors. addition list   contains component len.block lengths Jordan   chains.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_eigen.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The eigen decomposition of a multi-companion matrix — mc_eigen","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_eigen.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The eigen decomposition of a multi-companion matrix — mc_eigen","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_eigen.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"The eigen decomposition of a multi-companion matrix — mc_eigen","text":"mc_eigenvalues currently simply calls eigen   eigenvalues stored object. probably mostly useful   interest nonzero eigenvalues.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_eigen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The eigen decomposition of a multi-companion matrix — mc_eigen","text":"","code":"x <- sim_mc(6,4,mo.col=2) x #> $eigval #> [1] -0.1535948+0.0820323i -0.1535948-0.0820323i  0.0000000+0.0000000i #> [4]  0.0000000+0.0000000i  0.0000000+0.0000000i  0.0000000+0.0000000i #>  #> $len.block #> [1] 1 1 1 1 1 1 #>  #> $mo #> [1] 4 #>  #> $eigvec #>                         [,1]                    [,2] [,3] [,4] [,5] [,6] #> [1,] -0.10345133-0.03262896i -0.10345133+0.03262896i 0+0i 0+0i 0+0i 0+0i #> [2,] -0.01414716+0.00243563i -0.01414716-0.00243563i 0+0i 0+0i 0+0i 0+0i #> [3,] -0.29130815+0.45450325i -0.29130815-0.45450325i 1+0i 0+0i 0+0i 0+0i #> [4,] -0.35998555+0.02489782i -0.35998555-0.02489782i 0+0i 1+0i 0+0i 0+0i #> [5,]  0.43577407+0.44517484i  0.43577407-0.44517484i 0+0i 0+0i 1+0i 0+0i #> [6,]  0.07825460+0.02593695i  0.07825460-0.02593695i 0+0i 0+0i 0+0i 1+0i #>  #> $co #>                        [,1]                   [,2] #> [1,] -0.2913082+0.45450325i -0.2913082-0.45450325i #> [2,] -0.3599856+0.02489782i -0.3599856-0.02489782i #> [3,]  0.4357741+0.44517484i  0.4357741-0.44517484i #> [4,]  0.0782546+0.02593695i  0.0782546-0.02593695i #>  #> $mo.col #> [1] 2 #>  #> $mat #>               [,1]          [,2] [,3] [,4] [,5] [,6] #> [1,]  5.517272e-03 -1.352708e+00    0    0    0    0 #> [2,]  2.369021e-02 -3.127068e-01    0    0    0    0 #> [3,]  1.832328e+00 -1.392620e+01    0    0    0    0 #> [4,]  4.795248e-01 -7.270499e+00    0    0    0    0 #> [5,]  1.000000e+00  2.011944e-15    0    0    0    0 #> [6,] -6.100521e-17  1.000000e+00    0    0    0    0 #>  y <- mCompanion(x,detect=\"gen\") y #> 6 x 6 Matrix of class \"MultiCompanion\" #>             [,1]        [,2] [,3] [,4] [,5] [,6] #> [1,] 0.005517272  -1.3527079    0    0    0    0 #> [2,] 0.023690213  -0.3127068    0    0    0    0 #> [3,] 1.832328094 -13.9261993    0    0    0    0 #> [4,] 0.479524809  -7.2704991    0    0    0    0 #> [5,] 1.000000000   0.0000000    0    0    0    0 #> [6,] 0.000000000   1.0000000    0    0    0    0 z <- as.matrix(y) xx <- mCompanion(x=z,mo.col=2) mc_eigen(xx) #> $values #> [1] -0.1535948+0.0820323i -0.1535948-0.0820323i  0.0000000+0.0000000i #> [4]  0.0000000+0.0000000i  0.0000000+0.0000000i  0.0000000+0.0000000i #>  #> $vectors #>                       [,1]                  [,2] [,3] [,4] [,5] [,6] #> [1,] -0.9913568+0.0000000i -0.9913568+0.0000000i 0+0i 0+0i 0+0i 0+0i #> [2,] -0.1166082+0.0601189i -0.1166082-0.0601189i 0+0i 0+0i 0+0i 0+0i #> [3,] -1.2895533+4.7621586i -1.2895533-4.7621586i 1+0i 0+0i 0+0i 0+0i #> [4,] -3.0691139+1.2066024i -3.0691139-1.2066024i 0+0i 1+0i 0+0i 0+0i #> [5,]  5.0218977+2.6821092i  5.0218977-2.6821092i 0+0i 0+0i 1+0i 0+0i #> [6,]  0.7533511+0.0109395i  0.7533511-0.0109395i 0+0i 0+0i 0+0i 1+0i #>  #> $len.block #> [1] 1 1 1 1 1 1 #>"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factorize.html","id":null,"dir":"Reference","previous_headings":"","what":"Factorise multi-companion matrices — mc_factorize","title":"Factorise multi-companion matrices — mc_factorize","text":"Companion factorization multi-companion matrices.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factorize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Factorise multi-companion matrices — mc_factorize","text":"","code":"mc_factorize(x, mo, mo.col) mc_leftc(x, mo, mo.col)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factorize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Factorise multi-companion matrices — mc_factorize","text":"x multi-companion matrix top. mo multi-companion order, number structural top rows. mo.col number non-trivial columns top matrix.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factorize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Factorise multi-companion matrices — mc_factorize","text":"companion factorization multi-companion matrix, \\(X\\),   (multi-companion) order \\(p\\)   \\(X=A_1\\times\\cdots\\times A_p\\),   \\(A_i\\), \\(=1,\\dots,p\\), companion   matrices. mc_leftc factorises multi-companion matrix product   companion times multi-companion. mc_factorize calls mc_leftc number times compute   full factorisation. x matrix attempt made convert   matrix. x vector converted matrix 1 row. x may whole matrix top.   mo missing x assumed top   matrix multi-companion order set number rows. mo.col defaults number columns x.   important specify mo.col columns   zeroes top matrix. Otherwise factorisation usually   fails message (solve) system exactly   singular. Note however objects class MultiCompanion   situation handled automatically (unless user overwrites   default behaviour).","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factorize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Factorise multi-companion matrices — mc_factorize","text":"mc_factorize, matrix whose -th row first row   -th companion factor. mc_leftc, numeric vector containing first row   companion factor.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factorize.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Factorise multi-companion matrices — mc_factorize","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factorize.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Factorise multi-companion matrices — mc_factorize","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factorize.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Factorise multi-companion matrices — mc_factorize","text":"companion factorisation always exist currently   possibility handled. Even exists, may numerically   unstable. Also, mo.col smaller number columns,   factorisation unique, one mo.col non-zero   entries computed.   existence treated. mc_leftc probably first function wrote   multi-companion matrices. checks consistently.   MultiCompanion class can used .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factorize.html","id":"level","dir":"Reference","previous_headings":"","what":"Level","title":"Factorise multi-companion matrices — mc_factorize","text":"0","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factorize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Factorise multi-companion matrices — mc_factorize","text":"","code":"mat2 <- make_mcmatrix(eigval = c(1), co = cbind(c(1,1,1,1), c(0,1,0,0)), dim = 4, len.block = c(2)) mat2 #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    0    0 #> [2,]   -1    2    0    0 #> [3,]    0    1    0    0 #> [4,]    0    1    0    0 eigen(mat2) #> eigen() decomposition #> $values #> [1] 1 1 0 0 #>  #> $vectors #>      [,1] [,2] [,3] [,4] #> [1,]  0.5 -0.5    0    0 #> [2,]  0.5 -0.5    0    0 #> [3,]  0.5 -0.5    1    0 #> [4,]  0.5 -0.5    0    1 #>  mc_leftc(mat2, mo = 4, mo.col = 2) #> [1] 0 1 0 0 mCompanion(mat2) #> 4 x 4 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    0    0 #> [2,]   -1    2    0    0 #> [3,]    0    1    0    0 #> [4,]    0    1    0    0 mCompanion(mat2, mo=4, mo.col=2) #> 4 x 4 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    0    0 #> [2,]   -1    2    0    0 #> [3,]    0    1    0    0 #> [4,]    0    1    0    0 mc_leftc(mCompanion(mat2), mo = 4, mo.col = 2) #> [1] 0 1 0 0 mc_eigen(mCompanion(mat2), mo = 4, mo.col = 2) #> eigen() decomposition #> $values #> [1] 1 1 0 0 #>  #> $vectors #>      [,1] [,2] [,3] [,4] #> [1,]  0.5 -0.5    0    0 #> [2,]  0.5 -0.5    0    0 #> [3,]  0.5 -0.5    1    0 #> [4,]  0.5 -0.5    0    1 #>  #> $len.block #> [1] 1 1 1 1 #>  mc_eigen(mCompanion(mat2, mo=4, mo.col=2), mo = 4, mo.col = 2) #> $values #> [1] 1 1 0 0 #>  #> $vectors #>           [,1]       [,2] [,3] [,4] #> [1,] 0.7071068 -0.7071068    0    0 #> [2,] 0.7071068 -0.7071068    0    0 #> [3,] 0.7071068 -0.7071068    1    0 #> [4,] 0.7071068 -0.7071068    0    1 #>  #> $len.block #> [1] 1 1 1 1 #>"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factors.html","id":null,"dir":"Reference","previous_headings":"","what":"Factors of multi-companion matrices — mc_factors","title":"Factors of multi-companion matrices — mc_factors","text":"Gives factors comprising companion factorisation   multi-companion matrix.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Factors of multi-companion matrices — mc_factors","text":"","code":"mc_factors(x, what = \"mc\")"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Factors of multi-companion matrices — mc_factors","text":"x multi-companion matrix, object class MultiCompanion. format result, see .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Factors of multi-companion matrices — mc_factors","text":"factors available object's pad requested   format, returned without processing.   factors may available previously computed   matrix created factors. factors available, requested format,   converted . Otherwise factors computed. factors stored object's pad name \"mC.factors\"   == \"mc\", \"mC.factorsmat\" otherwise.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Factors of multi-companion matrices — mc_factors","text":"== \"mc\" companion factors x list  MultiCompanion objects. Otherwise matrix -th row representing -th factor. side effect, factors stored object's pad, see   `Details'.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factors.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Factors of multi-companion matrices — mc_factors","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Factors of multi-companion matrices — mc_factors","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_factors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Factors of multi-companion matrices — mc_factors","text":"","code":"m <- mCompanion(matrix(1:8, nrow = 2)) mc_factors(m) #> [[1]] #> 4 x 4 Matrix of class \"MultiCompanion\" #>       [,1]  [,2] [,3]  [,4] #> [1,] 0.875 -0.75 -0.5 -0.25 #> [2,] 1.000  0.00  0.0  0.00 #> [3,] 0.000  1.00  0.0  0.00 #> [4,] 0.000  0.00  1.0  0.00 #>  #> [[2]] #> 4 x 4 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] #> [1,]    2    4    6    8 #> [2,]    1    0    0    0 #> [3,]    0    1    0    0 #> [4,]    0    0    1    0 #>"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_from_factors.html","id":null,"dir":"Reference","previous_headings":"","what":"Multi-companion matrix from factors — mc_from_factors","title":"Multi-companion matrix from factors — mc_from_factors","text":"Compute multi-companion matrix companion factors   periodic filter. Create multi-companion matrix corresponding   periodic filter multiplying relevant companion matrices   reverse order.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_from_factors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multi-companion matrix from factors — mc_from_factors","text":"","code":"mc_from_factors(x) mc_from_filter(x)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_from_factors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multi-companion matrix from factors — mc_from_factors","text":"x matrix row companion factor, see details.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_from_factors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multi-companion matrix from factors — mc_from_factors","text":"x matrix whose -th row top row -th   companion factor (mc_from_factors) filter   coefficients -th season (mc_from_filter). mc_from_factors , effectively, inverse mc_factorize.   companion matrices specified argument multiplied. mc_from_filter similar except relevant companion   matrices multiplied reverse order. , natural   coefficients -th season -th row! todo: add argument specify \"first\" season.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_from_factors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multi-companion matrix from factors — mc_from_factors","text":"top resulting multi-companion matrix.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_from_factors.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multi-companion matrix from factors — mc_from_factors","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_from_factors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Multi-companion matrix from factors — mc_from_factors","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_from_factors.html","id":"level","dir":"Reference","previous_headings":"","what":"Level","title":"Multi-companion matrix from factors — mc_from_factors","text":"Currently mc_from_factors calls mCompanion, probably   .","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mc_from_factors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multi-companion matrix from factors — mc_from_factors","text":"","code":"x <- matrix(1:8, nrow = 2) mc_from_factors(x) #> 2 x 4 Matrix of class \"dgeMatrix\" #>      [,1] [,2] [,3] [,4] #>         5    9   13    8 #> wrk2    2    4    6    8 mCompanion(mc_from_factors(x)) #> 4 x 4 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] #>         5    9   13    8 #> wrk2    2    4    6    8 #>         1    0    0    0 #>         0    1    0    0  mc_from_filter(x) #> 2 x 4 Matrix of class \"dgeMatrix\" #>      [,1] [,2] [,3] [,4] #>         6   12   18   14 #> wrk2    1    3    5    7 mCompanion(mc_from_filter(x)) #> 4 x 4 Matrix of class \"MultiCompanion\" #>      [,1] [,2] [,3] [,4] #>         6   12   18   14 #> wrk2    1    3    5    7 #>         1    0    0    0 #>         0    1    0    0"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic utilities for multi-companion matrices — mc_matrix","title":"Basic utilities for multi-companion matrices — mc_matrix","text":"Compute dense matrix representation multi-companion matrix   convert argument ordinary matrix.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic utilities for multi-companion matrices — mc_matrix","text":"","code":"mc_full(x) mc_matrix(x) mc_order(x) is_mc_bottom(x)"},{"path":"https://geobosh.github.io/mcompanion/reference/mc_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic utilities for multi-companion matrices — mc_matrix","text":"x top part multi-companion matrix whole matrix, see     Details.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Basic utilities for multi-companion matrices — mc_matrix","text":"mc_matrix returns ordinary matrix. returns x   x ordinary matrix (.matrix(x) == TRUE), converts   x matrix one row x vector, returns   .matrix(x) otherwise. mc_matrix used   functions package mcompanion want allow flexible   format top multicompanion matrix even whole matrix   (e.g. x may MultiCompanion object)   really multi-companion aware. mc_full, x normally top part   multi-companion matrix. Rows appended necessary obtain   dense representation matrix result guaranteed   multi-companion matrix.  error rows   columns.  number rows equal number columns,   .e. x whole matrix, effect x   converted ordinary matrix check made see   result indeed multi-companion matrix.   x may vector multi-companion order 1. Give multi-companion order square matrix Determine multi-companion order square matrix check   matrix may bottom part multi-companion matrix. mc_order(x) square matrix,   is_mc_bottom(x) matrix usually rectangular. bottom part multi-companion matrix form [0],   identity matrix 0 matrix zeroes. top   consists rows bottom part.   multi-companion order number rows top   multi-companion matrix. Identity matrices mc_order zero.   general matrices mc_order equal number   rows. particular, \\(1\\times1\\) matrix mc_order   zero, element equal one, mc_order one   otherwise. Acordingly, is_mc_bottom(x) returns TRUE x   identity matrix matrix zero rows.  consistent   treatment identity matrix multi-companion multi order   0 general matrix multi-companion multi-companion order   equal number rows.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic utilities for multi-companion matrices — mc_matrix","text":"mc_full, multi-companion matrix ordinary dense   matrix object. mc_matrix, ordinary matrix. mc_order, multi-companion order x,   non-negative integer is_mc_bottom, TRUE x may bottom part   multi-companion matrix FALSE otherwise.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_matrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Basic utilities for multi-companion matrices — mc_matrix","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_matrix.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Basic utilities for multi-companion matrices — mc_matrix","text":"mc_matrix multi-companion specific, except   converts vector matrix one row (column).  square   matrices functions really multi-companion specific. may make sense allow non-square matrices also mc_order.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mc_matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Basic utilities for multi-companion matrices — mc_matrix","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mc_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic utilities for multi-companion matrices — mc_matrix","text":"","code":"mc <- mCompanion(\"sim\", dim = 4, mo = 2) mc #> 4 x 4 Matrix of class \"MultiCompanion\" #>            [,1]      [,2]      [,3]        [,4] #> [1,] -0.4551479 0.3515955 0.1277068 -0.02420814 #> [2,] -1.1558121 0.2972545 0.1194295 -0.01510008 #> [3,]  1.0000000 0.0000000 0.0000000  0.00000000 #> [4,]  0.0000000 1.0000000 0.0000000  0.00000000 mc_order(mc) #> [1] 2 x <- mc[1:2, ]   # the top of mc x #> 2 x 4 Matrix of class \"dgeMatrix\" #>            [,1]      [,2]      [,3]        [,4] #> [1,] -0.4551479 0.3515955 0.1277068 -0.02420814 #> [2,] -1.1558121 0.2972545 0.1194295 -0.01510008 x2 <- mc[]      # whole mc as ordinary matrix x2 #> 4 x 4 Matrix of class \"MultiCompanion\" #>            [,1]      [,2]      [,3]        [,4] #> [1,] -0.4551479 0.3515955 0.1277068 -0.02420814 #> [2,] -1.1558121 0.2972545 0.1194295 -0.01510008 #> [3,]  1.0000000 0.0000000 0.0000000  0.00000000 #> [4,]  0.0000000 1.0000000 0.0000000  0.00000000  mc_matrix(mc) #>            [,1]      [,2]      [,3]        [,4] #> [1,] -0.4551479 0.3515955 0.1277068 -0.02420814 #> [2,] -1.1558121 0.2972545 0.1194295 -0.01510008 #> [3,]  1.0000000 0.0000000 0.0000000  0.00000000 #> [4,]  0.0000000 1.0000000 0.0000000  0.00000000 mc_matrix(x2) #>            [,1]      [,2]      [,3]        [,4] #> [1,] -0.4551479 0.3515955 0.1277068 -0.02420814 #> [2,] -1.1558121 0.2972545 0.1194295 -0.01510008 #> [3,]  1.0000000 0.0000000 0.0000000  0.00000000 #> [4,]  0.0000000 1.0000000 0.0000000  0.00000000 ## mc_matrix() doesn't append rows to its argument mc_matrix(x) #>            [,1]      [,2]      [,3]        [,4] #> [1,] -0.4551479 0.3515955 0.1277068 -0.02420814 #> [2,] -1.1558121 0.2972545 0.1194295 -0.01510008  ## mc_full() appends rows, to make the matrix square multicompanion mc_full(x) #>            [,1]      [,2]      [,3]        [,4] #> [1,] -0.4551479 0.3515955 0.1277068 -0.02420814 #> [2,] -1.1558121 0.2972545 0.1194295 -0.01510008 #> [3,]  1.0000000 0.0000000 0.0000000  0.00000000 #> [4,]  0.0000000 1.0000000 0.0000000  0.00000000 ## mc and x2 are square, so not amended: mc_full(mc) #>            [,1]      [,2]      [,3]        [,4] #> [1,] -0.4551479 0.3515955 0.1277068 -0.02420814 #> [2,] -1.1558121 0.2972545 0.1194295 -0.01510008 #> [3,]  1.0000000 0.0000000 0.0000000  0.00000000 #> [4,]  0.0000000 1.0000000 0.0000000  0.00000000 mc_full(x2) #>            [,1]      [,2]      [,3]        [,4] #> [1,] -0.4551479 0.3515955 0.1277068 -0.02420814 #> [2,] -1.1558121 0.2972545 0.1194295 -0.01510008 #> [3,]  1.0000000 0.0000000 0.0000000  0.00000000 #> [4,]  0.0000000 1.0000000 0.0000000  0.00000000  ## a vector argument is treated as a matrix with 1 row: mc_matrix(1:4) #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    3    4 mc_full(1:4) #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    3    4 #> [2,]    1    0    0    0 #> [3,]    0    1    0    0 #> [4,]    0    0    1    0 ## mc_order(1:4) # not by mc_order   m <- mCompanion(matrix(1:8, nrow = 2)) mc_matrix(m) #>      [,1] [,2] [,3] [,4] #> [1,]    1    3    5    7 #> [2,]    2    4    6    8 #> [3,]    1    0    0    0 #> [4,]    0    1    0    0 mc_order(m) #> [1] 2  m[-c(1,2), ] #> 2 x 4 Matrix of class \"dgeMatrix\" #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 is_mc_bottom(m[-c(1,2), ]) # TRUE #> [1] TRUE  ## TRUE for reactangular diagonal matrix with nrow < ncol is_mc_bottom(diag(1, nrow = 3, ncol = 5)) #> [1] TRUE ## border cases is_mc_bottom(matrix(0, nrow = 0, ncol = 4)) # TRUE, 0 rows #> [1] TRUE is_mc_bottom(diag(4))                       # TRUE, square diagonal matrix #> [1] TRUE"},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"Provides class multi-companion matrices methods     arithmetic factorization.  method generation     multi-companion matrices prespecified spectral properties     provided, well utilities periodically correlated     multivariate time series models. See Boshnakov (2002)     <doi:10.1016/S0024-3795(01)00475-X> Boshnakov & Iqelan (2009)     <doi:10.1111/j.1467-9892.2009.00617.x>.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"Index main exported objects, classes methods:         Overview package Package \"mcompanion\" implements multi-companion matrices discussed Boshnakov (2002) Boshnakov Iqelan (2009). main feature provided parsimonious parameterisation matrices based eigenvalues seeds eigenvectors.  can used specification parameterisation models time series dynamical systems terms spectral characteristics, poles associated filters transition matrices. multi-companion matrix order k square \\(n\\times n\\) matrix arbitrary k rows put top identity \\((n-k)\\times(n-k)\\) matrix zero \\((n-k)\\times k\\) matrix. number \\(k\\) multi-companion order matrix.  may happen top \\(k \\times n\\) block, say T, mc-matrix columns zeroes end.  documentation say \\(n\\times n\\) matrix dimension \\(n\\) size \\(n\\times n\\). Multi-companion matrices can created functions new mCompanion, latter versatile. functions  package return objects, well. sim_mc generates multi-companion matrix partially fully specified spectral properties. specification incomplete, completes simulated values. sim_pcfilter convenience function (uses sim_mc) generation filters periodically correlated models.  can converted various multivariate models, VAR, conveniently using class MultiFilter, see . Class \"MultiFilter\" formal representation periodic filters methods conversion periodic (non-periodic) multivariate filters. Several forms VAR models provided, see mf_VSform, VAR2pcfilter, MultiFilter, examples .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":"classes-and-generators","dir":"Reference","previous_headings":"","what":"Classes and generators","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"","code":"MultiCompanion-class    Class \"MultiCompanion\" MultiFilter-class       Class \"MultiFilter\" VAR2pcfilter            PAR representations of VAR models mCompanion              Create objects from class MultiCompanion mcSpec                  Generate objects of class mcSpec mcSpec-class            A class for spectral specifications of                         multi-companion matrices mf_VSform               Extract properties of multi-filters"},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":"utilities-for-multi-companion-matrices","dir":"Reference","previous_headings":"","what":"Utilities for multi-companion matrices","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"","code":"mc_eigen                The eigen decomposition of a multi-companion                         matrix mc_factorize            Factorise multi-companion matrices mc_factors              Factors of multi-companion matrices mc_from_factors         Multi-companion matrix from factors"},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":"simulation","dir":"Reference","previous_headings":"","what":"Simulation","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"","code":"sim_mc                  Simulate a multi-companion matrix sim_pcfilter            Generate periodic filters"},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":"generic-matrix-utilities","dir":"Reference","previous_headings":"","what":"Generic matrix utilities","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"","code":"Jordan_matrix           Utilities for Jordan matrices mcStable                Check if an object is stable rblockmult              Right-multiply a matrix by a block"},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":"spectral-description-of-mc-matrices","dir":"Reference","previous_headings":"","what":"Spectral description of mc-matrices","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"","code":"spec_core               Parameterise Jordan chains of multi-companion                         matrices spec_root0              Give the spectral parameters for zero                         eigenvalues of mc-matrices spec_root1              Give the spectral parameters for eigenvalues of                         mc-matrices equal to one spec_seeds1             Generate seed parameters for unit                         mc-eigenvectors"},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":"low-level-functions","dir":"Reference","previous_headings":"","what":"Low-level functions","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"","code":"mc_chain_extend         Extend multi-companion eigenvectors"},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"Georgi N. Boshnakov [aut, cre] Maintainer: Georgi N. Boshnakov <georgi.boshnakov@manchester.ac.uk>","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X . Boshnakov GN (2007). “Singular value decomposition multi-companion matrices.” Linear Algebra Appl., 424(2-3), 393--404. ISSN 0024-3795, doi:10.1016/j.laa.2007.02.010 . Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mcompanion-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Objects and Methods for Multi-Companion Matrices — mcompanion-package","text":"","code":"## see the examples in the links in section 'See Also' above."},{"path":"https://geobosh.github.io/mcompanion/reference/mf_VSform.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract properties of multi-filters — mf_VSform","title":"Extract properties of multi-filters — mf_VSform","text":"Extract properties scalar vector seasons forms multi-filters.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mf_VSform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract properties of multi-filters — mf_VSform","text":"","code":"mf_order(x, i = \"max\", form = \"pc\", perm) mf_period(x) mf_poles(x, blocks = FALSE) mf_VSform(x, first = 1, form = \"U\", perm)"},{"path":"https://geobosh.github.io/mcompanion/reference/mf_VSform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract properties of multi-filters — mf_VSform","text":"x filter, object class  \"MultiFilter\". index, integer vector string. first first season year. form form filter result refers,     one \"pc\", \"\", \"U\", \"L\", see Details. perm permutation seasons within year. blocks request lengths Jordan chains.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mf_VSform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract properties of multi-filters — mf_VSform","text":"mf_order,   = \"max\" positive integer,   otherwise vector  positive integers. mf_period period filter, positive integer. mf_poles,   blocks = FALSE, vector eigenvalues associated   multi-companion matrix, eigenvalue repeated according   algebraic multiplicity.   blocks = TRUE, 2-column matrix eigenvalues   first column lengths  Jordan chains second.   one row   chain (.e. multiple eigenvalues   repeated according geometric multiplicity). mf_VSform list components: Phi0 zero lag coefficient, matrix, Phi remaining coefficients, matrix, Phi0inv (form==\"\" ) inverse zero lag coefficient     matrix vs-form, matrix. (TODO: name     component misleading since case form = \"\" Phi0     identity matrix Phi0inv equal inverse     Phi0.)","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mf_VSform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract properties of multi-filters — mf_VSform","text":"default ==\"max\" function mf_order returns   single number, order filter representation   requested form.   orders components may obtained setting   ==\"\" gives vector whose j-th element order   j-th component filter. subset may obtained   numeric treated standard index vector.   Values default meaningful mainly   form=\"pc\". mf_VSform arranges filter coefficients one vector   seasons forms (todo: cite ). component Phi   result matrix obtained putting coefficient matrices next   , [A1 ... Ad].  perm provided,   result \"U\" \"L\". mf_VSform called implicitly subscripting operation   (\"[\") needed, flexible recommended general   use. vector forms (\"\", \"U\", \"L\") argument perm   specifies arrangement components filter   form. - U-forms default mf_period(x):1,   L-form 1:mf_period(x). Currently perm may take   values can  obtained default rotation, e.g.   period 4,  perm may one   (4,3,2,1), (1,4,3,2), (2,1,4,3), (3,2,1,4) U-form,     (1,2,3,4), (4,1,2,3), (3,4,1,2), (2,3,4,1) L-form.   permutations may usefull situations may   result U- L- forms (without transformations).   -form permutation permissible implemented   (todo:). mf_order argument perm affects computation   , ordering result.  result (vector)   permuted unless argument asks .   mf_VSform however behaviour peculiar   rows result permuted seasons.   short, -th element result mf_order (  vector) gives order (requested form) -th season   -th row matrices returned  mf_VSform   depends perm form. Note: terminology reflects application pc processes,   probably made neutral respect. todo: (2013-03-26) mf_order seems unfinished.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mf_VSform.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract properties of multi-filters — mf_VSform","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/mf_VSform.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract properties of multi-filters — mf_VSform","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X . Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/mf_VSform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract properties of multi-filters — mf_VSform","text":"","code":"## simulate a 3x3 2-companion matrix ##  and turn it into a multi-filter (m <- mCompanion(\"sim\", dim=3, mo=2)) #> 3 x 3 Matrix of class \"MultiCompanion\" #>           [,1]       [,2]          [,3] #> [1,] 0.2812126 0.01740568 -0.0095772357 #> [2,] 1.5021262 0.03800016  0.0006236083 #> [3,] 1.0000000 0.00000000  0.0000000000 (flt <- new(\"MultiFilter\", mc = m )) #> An object of class \"MultiFilter\" #> Slot \"mc\": #> 3 x 3 Matrix of class \"MultiCompanion\" #>           [,1]       [,2]          [,3] #> [1,] 0.2812126 0.01740568 -0.0095772357 #> [2,] 1.5021262 0.03800016  0.0006236083 #> [3,] 1.0000000 0.00000000  0.0000000000 #>  #> Slot \"coef\": #>            [,1]        [,2]         [,3] #> [1,]   1.502126  0.03800016 0.0006236083 #> [2,] -15.357775 23.35052846 0.6010035334 #>  #> Slot \"order\": #> [1] 3 3 #>  #> Slot \"sign\": #> [1] 1 #>  mf_period(flt) #> [1] 2 mf_poles(flt) #> [1]  0.33977135+0.00000000i -0.01027931-0.03158169i -0.01027931+0.03158169i abs(mf_poles(flt)) #> [1] 0.33977135 0.03321246 0.03321246 mf_VSform(flt,form=\"U\") #> $Phi0 #>      [,1]     [,2] #> [1,]    1 15.35778 #> [2,]    0  1.00000 #>  #> $Phi #>           [,1]       [,2]         [,3] [,4] #> [1,] 23.350528 0.60100353 0.0000000000    0 #> [2,]  1.502126 0.03800016 0.0006236083    0 #>  mf_VSform(flt,form=\"L\") #> $Phi0 #> 2 x 2 Matrix of class \"dgeMatrix\" #>          [,1] [,2] #> [1,]  1.00000    0 #> [2,] 15.35778    1 #>  #> $Phi #>            [,1]      [,2] [,3]         [,4] #> [1,] 0.03800016  1.502126    0 0.0006236083 #> [2,] 0.60100353 23.350528    0 0.0000000000 #>  mf_VSform(flt,form=\"I\") #> $Phi0 #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> $Phi #>           [,1]       [,2]          [,3] [,4] #> [1,] 0.2812126 0.01740568 -0.0095772357    0 #> [2,] 1.5021262 0.03800016  0.0006236083    0 #>  #> $Phi0inv #>      [,1]      [,2] #> [1,]    1 -15.35778 #> [2,]    0   1.00000 #>   ## simulate a pc filter (2 seasons) ## and turn it into a multi-filter object (rfi <- sim_pcfilter(2, 3)) #> $eigval #> [1]  0.95318835+0.00000000i -0.02983427+0.02201284i -0.02983427-0.02201284i #>  #> $len.block #> [1] 1 1 1 #>  #> $mo #> [1] 2 #>  #> $eigvec #>               [,1]                    [,2]                    [,3] #> [1,] -0.7479218+0i -0.01191958-0.01125631i -0.01191958+0.01125631i #> [2,]  0.6821736+0i  0.05458344+0.00761394i  0.05458344-0.00761394i #> [3,] -0.7846527+0i  0.07844080+0.43517115i  0.07844080-0.43517115i #>  #> $co #>               [,1]                   [,2]                   [,3] #> [1,]  0.6821736+0i 0.05458344+0.00761394i 0.05458344-0.00761394i #> [2,] -0.7846527+0i 0.07844080+0.43517115i 0.07844080-0.43517115i #>  #> $mo.col #> [1] 3 #>  #> $mat #>           [,1]       [,2]        [,3] #> [1,]  1.127772  0.2207155  0.02547841 #> [2,] -1.060914 -0.2342517 -0.02110437 #> [3,]  1.000000  0.0000000  0.00000000 #>  #> $pcfilter #>           [,1]       [,2]        [,3] #> [1,] -1.060914 -0.2342517 -0.02110437 #> [2,] -1.207257 -0.1530246 -0.06208663 #>  (flt <- new(\"MultiFilter\", coef = rfi$pcfilter)) #> An object of class \"MultiFilter\" #> Slot \"mc\": #> 3 x 3 Matrix of class \"MultiCompanion\" #>           [,1]       [,2]        [,3] #>       1.127772  0.2207155  0.02547841 #> wrk2 -1.060914 -0.2342517 -0.02110437 #>       1.000000  0.0000000  0.00000000 #>  #> Slot \"coef\": #>           [,1]       [,2]        [,3] #> [1,] -1.060914 -0.2342517 -0.02110437 #> [2,] -1.207257 -0.1530246 -0.06208663 #>  #> Slot \"order\": #> [1] 3 3 #>  #> Slot \"sign\": #> [1] 1 #>  mf_period(flt) #> [1] 2 mf_poles(flt) #> [1]  0.95318835+0.00000000i -0.02983427+0.02201284i -0.02983427-0.02201284i abs(mf_poles(flt)) #> [1] 0.95318835 0.03707626 0.03707626 mf_VSform(flt, form=\"U\") #> $Phi0 #>      [,1]     [,2] #> [1,]    1 1.207257 #> [2,]    0 1.000000 #>  #> $Phi #>            [,1]        [,2]        [,3] [,4] #> [1,] -0.1530246 -0.06208663  0.00000000    0 #> [2,] -1.0609139 -0.23425170 -0.02110437    0 #>  mf_VSform(flt, form=\"I\") #> $Phi0 #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> $Phi #>           [,1]       [,2]        [,3] [,4] #> [1,]  1.127772  0.2207155  0.02547841    0 #> [2,] -1.060914 -0.2342517 -0.02110437    0 #>  #> $Phi0inv #>      [,1]      [,2] #> [1,]    1 -1.207257 #> [2,]    0  1.000000 #>  mf_VSform(flt, form=\"L\") #> $Phi0 #> 2 x 2 Matrix of class \"dgeMatrix\" #>          [,1] [,2] #> [1,] 1.000000    0 #> [2,] 1.207257    1 #>  #> $Phi #>             [,1]       [,2] [,3]        [,4] #> [1,] -0.23425170 -1.0609139    0 -0.02110437 #> [2,] -0.06208663 -0.1530246    0  0.00000000 #>   ## indexing can be used  to extract filter coefficients flt[] #>           [,1]       [,2]        [,3] #> [1,] -1.060914 -0.2342517 -0.02110437 #> [2,] -1.207257 -0.1530246 -0.06208663 flt[1,] #>           [,1]       [,2]        [,3] #> [1,] -1.060914 -0.2342517 -0.02110437 ## the rest are some checks of numerical performance. rfi #> $eigval #> [1]  0.95318835+0.00000000i -0.02983427+0.02201284i -0.02983427-0.02201284i #>  #> $len.block #> [1] 1 1 1 #>  #> $mo #> [1] 2 #>  #> $eigvec #>               [,1]                    [,2]                    [,3] #> [1,] -0.7479218+0i -0.01191958-0.01125631i -0.01191958+0.01125631i #> [2,]  0.6821736+0i  0.05458344+0.00761394i  0.05458344-0.00761394i #> [3,] -0.7846527+0i  0.07844080+0.43517115i  0.07844080-0.43517115i #>  #> $co #>               [,1]                   [,2]                   [,3] #> [1,]  0.6821736+0i 0.05458344+0.00761394i 0.05458344-0.00761394i #> [2,] -0.7846527+0i 0.07844080+0.43517115i 0.07844080-0.43517115i #>  #> $mo.col #> [1] 3 #>  #> $mat #>           [,1]       [,2]        [,3] #> [1,]  1.127772  0.2207155  0.02547841 #> [2,] -1.060914 -0.2342517 -0.02110437 #> [3,]  1.000000  0.0000000  0.00000000 #>  #> $pcfilter #>           [,1]       [,2]        [,3] #> [1,] -1.060914 -0.2342517 -0.02110437 #> [2,] -1.207257 -0.1530246 -0.06208663 #>  rfi$mat==0 #>       [,1]  [,2]  [,3] #> [1,] FALSE FALSE FALSE #> [2,] FALSE FALSE FALSE #> [3,] FALSE  TRUE  TRUE  zapsmall(rfi$mat) #>           [,1]       [,2]       [,3] #> [1,]  1.127771  0.2207155  0.0254784 #> [2,] -1.060914 -0.2342517 -0.0211044 #> [3,]  1.000000  0.0000000  0.0000000 mCompanion(zapsmall(rfi$mat)) #> 3 x 3 Matrix of class \"MultiCompanion\" #>           [,1]       [,2]       [,3] #> [1,]  1.127771  0.2207155  0.0254784 #> [2,] -1.060914 -0.2342517 -0.0211044 #> [3,]  1.000000  0.0000000  0.0000000 unclass(mCompanion(zapsmall(rfi$mat))) #> <S4 Type Object> #> attr(,\"xtop\") #>           [,1]       [,2]       [,3] #> [1,]  1.127771  0.2207155  0.0254784 #> [2,] -1.060914 -0.2342517 -0.0211044 #> attr(,\"mo\") #> [1] 2 #> attr(,\"ido\") #> [1] 1 #> attr(,\"mo.col\") #> [1] 3 #> attr(,\"pad\") #> An object of class \"objectPad\" #> [[1]] #> function (x)  #> { #>     if (missing(x))  #>         sklad #>     else sklad[[x]] #> } #> <bytecode: 0x5635f3d467e0> #> <environment: 0x5635f6fe0338> #>  #> [[2]] #> function (x, value)  #> { #>     sklad[[x]] <<- value #> } #> <bytecode: 0x5635f3d46498> #> <environment: 0x5635f6fe0338> #>  #> attr(,\"x\") #> [1]  1.1277715 -1.0609139  1.0000000  0.2207155 -0.2342517  0.0000000  0.0254784 #> [8] -0.0211044  0.0000000 #> attr(,\"Dim\") #> [1] 3 3 #> attr(,\"Dimnames\") #> attr(,\"Dimnames\")[[1]] #> NULL #>  #> attr(,\"Dimnames\")[[2]] #> NULL #>  #> attr(,\"factors\") #> list() unclass(mCompanion(rfi$mat)) #> <S4 Type Object> #> attr(,\"xtop\") #>           [,1]       [,2]        [,3] #> [1,]  1.127772  0.2207155  0.02547841 #> [2,] -1.060914 -0.2342517 -0.02110437 #> attr(,\"mo\") #> [1] 2 #> attr(,\"ido\") #> [1] 1 #> attr(,\"mo.col\") #> [1] 3 #> attr(,\"pad\") #> An object of class \"objectPad\" #> [[1]] #> function (x)  #> { #>     if (missing(x))  #>         sklad #>     else sklad[[x]] #> } #> <bytecode: 0x5635f3d467e0> #> <environment: 0x5635f7f6ccd8> #>  #> [[2]] #> function (x, value)  #> { #>     sklad[[x]] <<- value #> } #> <bytecode: 0x5635f3d46498> #> <environment: 0x5635f7f6ccd8> #>  #> attr(,\"x\") #> [1]  1.12777151 -1.06091388  1.00000000  0.22071546 -0.23425170  0.00000000 #> [7]  0.02547841 -0.02110437  0.00000000 #> attr(,\"Dim\") #> [1] 3 3 #> attr(,\"Dimnames\") #> attr(,\"Dimnames\")[[1]] #> NULL #>  #> attr(,\"Dimnames\")[[2]] #> NULL #>  #> attr(,\"factors\") #> list()  flt1 <- new(\"MultiFilter\", mc = mCompanion(zapsmall(rfi$mat))) flt2 <- flt  flt1[] #>           [,1]       [,2]        [,3] #> [1,] -1.060914 -0.2342517 -0.02110440 #> [2,] -1.207255 -0.1530225 -0.06208612 flt2[] #>           [,1]       [,2]        [,3] #> [1,] -1.060914 -0.2342517 -0.02110437 #> [2,] -1.207257 -0.1530246 -0.06208663 flt1[] - flt2[] #>               [,1]         [,2]          [,3] #> [1,] -1.919518e-08 9.036163e-10 -2.756118e-08 #> [2,]  1.986049e-06 2.075207e-06  5.057117e-07 rfi$pcfilter - rfi$mat[1:2,] #>            [,1]        [,2]        [,3] #> [1,] -2.1886854 -0.45496716 -0.04658278 #> [2,] -0.1463435  0.08122713 -0.04098225  mf_poles(flt1) #> [1]  0.95318827+0.00000000i -0.02983424+0.02201268i -0.02983424-0.02201268i abs(mf_poles(flt1)) #> [1] 0.95318827 0.03707613 0.03707613  svd(rfi$mat) #> $d #> [1] 1.863242845 0.174357069 0.004033309 #>  #> $u #>            [,1]       [,2]        [,3] #> [1,] -0.6162229  0.3101119 -0.72394751 #> [2,]  0.5817562 -0.4403792 -0.68383176 #> [3,] -0.5308758 -0.8425537  0.09096224 #>  #> $v #>             [,1]        [,2]          [,3] #> [1,] -0.98915051 -0.14690520  0.0003668788 #> [2,] -0.14613623  0.98422201  0.0997558566 #> [3,] -0.01501574  0.09861994 -0.9950118765 #>  rcond(rfi$mat) #> [1] 0.00160921 Matrix::rcond(Matrix::Matrix(rfi$mat),\"O\") #> [1] 0.00160921 1/Matrix::rcond(Matrix::Matrix(rfi$mat),\"O\") #> [1] 621.4231"},{"path":"https://geobosh.github.io/mcompanion/reference/nullComplement.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the orthogonal complement of a subspace — null_complement","title":"Compute the orthogonal complement of a subspace — null_complement","text":"Computes orthogonal complement subspace relative   universe.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/nullComplement.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the orthogonal complement of a subspace — null_complement","text":"","code":"null_complement(m, universe = NULL, na.allow = TRUE)"},{"path":"https://geobosh.github.io/mcompanion/reference/nullComplement.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the orthogonal complement of a subspace — null_complement","text":"m NA matrix whose columns define subspace, vector     treated matrix one column. universe matrix whose columns specify subspace relative     compute complement, default full space. na.allow TRUE, default, treat NA's specially, see Details.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/nullComplement.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the orthogonal complement of a subspace — null_complement","text":"null_complement computes orthogonal complement   subspace (spanned columns m) relative universe. Argument universe can used specify subspace w.r.t.   compute complement.  universe NULL   (default), complement w.r.t. full space computed.   full space \\(n\\)-dimensional space, \\(n\\)   number rows argument m. null_complement returns matrix whose columns give basis   required subspace. null_complement uses Null() package MASS   actual computation. null_complement(m, na.allow = FALSE)   equivalent Null(m). m typically matrix whose columns represent subspace   w.r.t. compute complement.   null_complement can also deal NA's m.   facility can turned specifying na.allow = FALSE. na.allow = TRUE, default, m identical   NA, universe returned (.e. m = NA represents   empty subspace). Note case universe   NULL, since way determine dimension full   space. Otherwise, m matrix. elements m   NA, matrix NA's returned number columns equal   ncol(universe) - ncol(m).","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/nullComplement.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the orthogonal complement of a subspace — null_complement","text":"matrix representing basis requested subspace","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/nullComplement.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute the orthogonal complement of a subspace — null_complement","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/nullComplement.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the orthogonal complement of a subspace — null_complement","text":"","code":"m1 <- diag(1, nrow = 3, ncol = 2) null_complement(m1) #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    1  null_complement(c(1,1,0)) #>            [,1] [,2] #> [1,] -0.7071068    0 #> [2,]  0.7071068    0 #> [3,]  0.0000000    1 null_complement(c(1,1,0), m1) #>            [,1] #> [1,]  0.7071068 #> [2,] -0.7071068 #> [3,]  0.0000000  ## the columns of the result from null_complement() are orthogonal ## to  the 1st argument: t(c(1,1,0)) %*% null_complement(c(1,1,0)) #>              [,1] [,2] #> [1,] 1.110223e-16    0 t(c(1,1,0)) %*% null_complement(c(1,1,0), m1) #>               [,1] #> [1,] -1.110223e-16  null_complement(rep(NA_real_, 3), m1) #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA null_complement(NA, m1) #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #> [3,]    0    0"},{"path":"https://geobosh.github.io/mcompanion/reference/optionalMatrix-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class optionalMatrix — optionalMatrix-class","title":"Class optionalMatrix — optionalMatrix-class","text":"Class optionalMatrix.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/optionalMatrix-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class optionalMatrix — optionalMatrix-class","text":"virtual Class: objects may created .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/optionalMatrix-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class optionalMatrix — optionalMatrix-class","text":"methods defined class \"optionalMatrix\" signature.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/optionalMatrix-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class optionalMatrix — optionalMatrix-class","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/optionalMatrix-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class optionalMatrix — optionalMatrix-class","text":"","code":"showClass(\"optionalMatrix\") #> Virtual Class \"optionalMatrix\" [package \"mcompanion\"] #>  #> No Slots, prototype of class \"NULL\" #>  #> Known Subclasses:  #> Class \"NULL\", directly #> Class \"matrix\", directly #> Class \".NULL\", by class \"NULL\", distance 2, with explicit coerce #> Class \"mts\", by class \"matrix\", distance 2"},{"path":"https://geobosh.github.io/mcompanion/reference/permute_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Permute rows and columns of matrices — permute_var","title":"Permute rows and columns of matrices — permute_var","text":"Permute rows columns matrices.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/permute_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permute rows and columns of matrices — permute_var","text":"","code":"permute_var(mat, perm = nrow(mat):1) permute_synch(param, perm)"},{"path":"https://geobosh.github.io/mcompanion/reference/permute_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permute rows and columns of matrices — permute_var","text":"mat matrix. param matrix list, see Details. perm permutation, defaults nrow:1.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/permute_var.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Permute rows and columns of matrices — permute_var","text":"Given permutation, permute_var permutes rows columns   matrix way mat covariance matrix   vector x, rearranged matrix covariance   matrix x[perm]. P permutation matrix   corresponding perm, computed value   P %*% mat %*% t(P). permute_synch performs transformation matrices   found param. precisely, param matrix,   result permute_var. Otherwise   param list , conceptually, permute_synch   applied recursively element list. net result   matrix, say \\(M\\), param replaced   \\(PMP'\\) vector, say \\(v\\), \\(Pv\\). idea   param may contain specification VAR model, components   need reshuffled components multivariate   vector permuted. matrices param must number rows, say   d, checked. perm permutation   1:d.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/permute_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permute rows and columns of matrices — permute_var","text":"permute_var, matrix, permute_synch, matrix list shape  param matrix transformed described   Details.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/permute_var.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Permute rows and columns of matrices — permute_var","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/permute_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permute rows and columns of matrices — permute_var","text":"","code":"Cl <- cor(longley) # from example for 'cor()' nc <- ncol(Cl) v <- 1:nc names(v) <- colnames(Cl)  permute_var(Cl) #>               Employed      Year Population Armed.Forces Unemployed       GNP #> Employed     1.0000000 0.9713295  0.9603906    0.4573074  0.5024981 0.9835516 #> Year         0.9713295 1.0000000  0.9939528    0.4172451  0.6682566 0.9952735 #> Population   0.9603906 0.9939528  1.0000000    0.3644163  0.6865515 0.9910901 #> Armed.Forces 0.4573074 0.4172451  0.3644163    1.0000000 -0.1774206 0.4464368 #> Unemployed   0.5024981 0.6682566  0.6865515   -0.1774206  1.0000000 0.6042609 #> GNP          0.9835516 0.9952735  0.9910901    0.4464368  0.6042609 1.0000000 #> GNP.deflator 0.9708985 0.9911492  0.9791634    0.4647442  0.6206334 0.9915892 #>              GNP.deflator #> Employed        0.9708985 #> Year            0.9911492 #> Population      0.9791634 #> Armed.Forces    0.4647442 #> Unemployed      0.6206334 #> GNP             0.9915892 #> GNP.deflator    1.0000000 all(permute_var(Cl) == Cl[ncol(Cl):1, ncol(Cl):1]) #> [1] TRUE"},{"path":"https://geobosh.github.io/mcompanion/reference/rblockmult.html","id":null,"dir":"Reference","previous_headings":"","what":"Right-multiply a matrix by a block — rblockmult","title":"Right-multiply a matrix by a block — rblockmult","text":"Treats matrix block matrix multiplies block given   block.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/rblockmult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Right-multiply a matrix by a block — rblockmult","text":"","code":"rblockmult(x, b)"},{"path":"https://geobosh.github.io/mcompanion/reference/rblockmult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Right-multiply a matrix by a block — rblockmult","text":"x matrix. b block.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/rblockmult.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Right-multiply a matrix by a block — rblockmult","text":"x split blocks [x1 ... xn]   ncol(xi)==nrow(b) block multiplied b.   result matrix [x1 b ... xn b].","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/rblockmult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Right-multiply a matrix by a block — rblockmult","text":"matrix obtained described ","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/rblockmult.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Right-multiply a matrix by a block — rblockmult","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/rblockmult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Right-multiply a matrix by a block — rblockmult","text":"","code":"m <- matrix(1:12, nrow = 2) b <- matrix(c(0, 1, 1, 0), nrow = 2) rblockmult(m,b) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    3    1    7    5   11    9 #> [2,]    4    2    8    6   12   10"},{"path":"https://geobosh.github.io/mcompanion/reference/reduce_chains_simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a chain and drop excess, internal function — reduce_chains_simple","title":"Transform a chain and drop excess, internal function — reduce_chains_simple","text":"Transform chain drop excess, internal function.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/reduce_chains_simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a chain and drop excess, internal function — reduce_chains_simple","text":"","code":"reduce_chains_simple(chains, sort = TRUE)"},{"path":"https://geobosh.github.io/mcompanion/reference/reduce_chains_simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a chain and drop excess, internal function — reduce_chains_simple","text":"chains list 0chains sort flag sorting, see details","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/reduce_chains_simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a chain and drop excess, internal function — reduce_chains_simple","text":"list  chains","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/reduce_chains_simple.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform a chain and drop excess, internal function — reduce_chains_simple","text":"Given one chains corresponding common eigenvalue,   reduce_chains_simple transforms chains redundant   eigenvectors removed. process, heights chains   may decrease number chains may reduced, . sort == TRUE function reorders chains   lengths decreasing order.  However, algorithm depends   done, argument used chains   known already sorted. wrote function part support chains   multi-companion matrices associated 0 eigenvalue.    chains specified via top left mo.col x mo.col subchains   extended chains top left mo x mo corner   (extended) eigenvectors may linearly independent.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/reduce_chains_simple.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform a chain and drop excess, internal function — reduce_chains_simple","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/sim_chains.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Jordan chains — sim_chains","title":"Simulate Jordan chains — sim_chains","text":"Simulate Jordan chains.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_chains.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Jordan chains — sim_chains","text":"","code":"sim_chains(dim = nrow(vectors), type = NULL, heights = NULL,            vectors = NULL, argarg = list(0, pi), ...)"},{"path":"https://geobosh.github.io/mcompanion/reference/sim_chains.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Jordan chains — sim_chains","text":"dim dimension matrix, positive integer. type types eigenvalues, character vector containing     \"r\" \"cp\". heights heights eigenvalues, vector positive integers. vectors matrix containing chains. argarg TODO: describe. ... additional arguments passed sim_numbers.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_chains.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Jordan chains — sim_chains","text":"sim_chains prepares arguments calls sim_numbers   fill NA entries vectors simulated values.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_chains.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Jordan chains — sim_chains","text":"matrix","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_chains.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Jordan chains — sim_chains","text":"Georgi N, Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a multi-companion matrix — sim_mc","title":"Simulate a multi-companion matrix — sim_mc","text":"Simulate multi-companion matrix partially  fully specified spectral   properties.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a multi-companion matrix — sim_mc","text":"","code":"sim_mc(dim, mo, mo.col = dim, eigval, len.block, type.eigval = NULL,        co, eigabs, eigsign, type = \"real\",        value = \"real\", value.type = \"\", ...)"},{"path":"https://geobosh.github.io/mcompanion/reference/sim_mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a multi-companion matrix — sim_mc","text":"dim dimension matrix. mo multi-companion order. mo.col number structural columns. eigval eigenvalues, one Jordan block. len.block lengths Jordan blocks corresponding eigval. type.eigval types eigenvalues, character vector co co parameters, see Details. eigabs moduli (absolute values) eigenvalues, see Details. eigsign signs complex arguments eigenvalues, see Details. type passed generators (???) value return value.type type value (???) ... arguments passed sim_chains     sim_numbers, see Details.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_mc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a multi-companion matrix — sim_mc","text":"sim_mc generates multi-companion matrix dimension   dim x dim multi-companion order mo. matrix   spectral properties specified arguments. Values   inferred arguments simulated. Arguments dim, mo, mo.col define   structure matrix. first two compulsory last   one, mo.col, optional. arguments supplied   sim_mc produces matrix spectral parameters   simulated. number non-zero eigenvalues mo.col.   mo.col < dim multi-companion matrix structural   eigenvectors/chains corresponding zero eigenvalue(s), see   references. chains generated automatically. Arguments type.eigval, eigabs, eigsign   eigval vectors used specify types values   eigenvalues. may missing NULL.   present must length. necessary specify eigenvalues eigenvectors   corresponding eigenvalues equal zero, since structural   eigenchains needed mo.col < dim created automatically.   practice, number non-zero eigenvalues usually equal   mo.col.  net effect arguments specifying   spectral structure matrix normally need specify spectral   information non-zero eigval . eigenvalues may specified partially fully   using arguments eigabs, eigsign,   eigval. Non-NA entries eigval specify complete   eigenvalues. Non-NA entries eigabs specify absolute values   eigenvalues. Non-NA entries eigsign specify signs real   eigenvalues complex arguments complex eigenvalues. Generally,   entry eigenvalue eigval number (  NA), corresponding entries eigabs   eigsign NA. enforced limited   check consistency made case redundant information. type.eigval character vector describing types   eigenvalues, \"r\", \"c\", \"cp\" stand real, complex,   complex pair, respectively. best one entry   complex pair (specified \"cp\"), rather two \"c\" entries. type.eigval NULL (default) eigval supplied,   type.eigval inferred imaginary part   eigval (\"r\" \"cp\"), complex. compatibility older versions function eigval   may character vector case simply assigned   type.eigval. , type.eigval eigval, missing default   allocation types eigenvalues chosen. TODO: complete description . remaining spectral parameters may specified argument   co missing entries \"free\" entries. (!!!   complete, may better separate arguments absolute   value angle, eigenvalues, option   normalisation coefficients. ???) Generators default ones may specified   ...  argument. passed sim_numbers   sim_chains.  , \"co\" arguments support   finished.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a multi-companion matrix — sim_mc","text":"value.type character string \"matrix\",   required multi-companion matrix. Otherwise,  value.type==\"list\", list containing also spectral   information (list one  make_mcmatrix)).","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_mc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate a multi-companion matrix — sim_mc","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X . Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_mc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a multi-companion matrix — sim_mc","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_mc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulate a multi-companion matrix — sim_mc","text":"canonical form needed, especially repeated   eigenvalues whose eigenvectors may chosen orthogonal,   least. (nyakade v zapiskite mi tryabva da ima kanonichna forma!)","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/sim_mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a multi-companion matrix — sim_mc","text":"","code":"m0 <- sim_mc(3,2)   # simulate 3x3 2-companion matrix abs(m0$eigval)      # eigval random, so their abs values #> [1] 0.3074961 0.6979486 0.6979486  # now fix moduli of eigenvalues, and # ask for one real ev and one complex pair of ev's m1 <- sim_mc(3,2,eigabs=c(0.25,0.5), type.eigval=c(\"r\",\"cp\")) m1$eigval #> [1]  0.2500000+0.0000000i -0.0105565+0.4998885i -0.0105565-0.4998885i abs(m1$eigval) #> [1] 0.25 0.50 0.50  # same as above, since type.eigval happens to be the default # dim is odd, by default first ev is real, rest are complex pairs m1a <- sim_mc(3,2,eigabs=c(0.25,0.5)) m1a$eigval #> [1]  0.2500000+0.0000000i -0.4749147+0.1563843i -0.4749147-0.1563843i abs(m1a$eigval) #> [1] 0.25 0.50 0.50  # simulate 6x6 4-companion matrix # with ev's at the seasonal frequencies (1.57 3.141593 -1.57) # and random moduli. 3 complex pairs of ev's m2 <- sim_mc(6,4, eigsign = pi*c(1/2,1,-1/2) ) Arg(m2$eigval) #> [1]  1.570796  3.141593 -1.570796 -1.570796 -3.141593  1.570796"},{"path":"https://geobosh.github.io/mcompanion/reference/sim_pcfilter.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate periodic filters — sim_pcfilter","title":"Generate periodic filters — sim_pcfilter","text":"Generates periodic filters.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_pcfilter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate periodic filters — sim_pcfilter","text":"","code":"sim_pcfilter(period, n.root, order = n.root, mo.col, ...)"},{"path":"https://geobosh.github.io/mcompanion/reference/sim_pcfilter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate periodic filters — sim_pcfilter","text":"period period. n.root number non-zero roots (poles). order order  filter. ... additional parameters passed sim_mc. mo.col last non-zero column top mc-matrix. default     dim.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_pcfilter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate periodic filters — sim_pcfilter","text":"Generates periodic filters using multicompanion approach   (Boshnakov Iqelan 2009) . default generated filter stable may used   autoregressive moving average part periodic autoregressive   moving average model. filter generated specified   spectral information factoring multi-companion matrix.   non-specified quantities generated randomly. Randomly generated   eigenvalues correspond stable filter. user may specify   non-stable roots, unit roots particular, see sim_mc.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_pcfilter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate periodic filters — sim_pcfilter","text":"list obtained sim_mc addtional   component filter. pcfilter matrix filter coefficients -th     season -th row.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_pcfilter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate periodic filters — sim_pcfilter","text":"Boshnakov GN (2002). “Multi-companion matrices.” Linear Algebra Appl., 354, 53--83. ISSN 0024-3795, doi:10.1016/S0024-3795(01)00475-X . Boshnakov GN, Iqelan BM (2009). “Generation time series models given spectral properties.” J. Time Series Anal., 30(3), 349--368. ISSN 0143-9782, doi:10.1111/j.1467-9892.2009.00617.x .","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_pcfilter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate periodic filters — sim_pcfilter","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/sim_pcfilter.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate periodic filters — sim_pcfilter","text":"todo: ) Allow different orders individual seasons.    trivial maybe natural method. singular   case may make sense implement different strategies choosing   factorization (unique) choose carefully   order filter ensure existence factorization, see   paper.","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/sim_pcfilter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate periodic filters — sim_pcfilter","text":"","code":"rfi <- sim_pcfilter(2,3) rfi #> $eigval #> [1]  0.7583738+0.000000i -0.6349946+0.093015i -0.6349946-0.093015i #>  #> $len.block #> [1] 1 1 1 #>  #> $mo #> [1] 2 #>  #> $eigvec #>               [,1]                    [,2]                    [,3] #> [1,] -0.6933578+0i -0.00702768-0.03047627i -0.00702768+0.03047627i #> [2,] -0.1006209+0i -0.57104039+0.47045921i -0.57104039-0.47045921i #> [3,] -0.9142693+0i  0.00395218+0.04857345i  0.00395218-0.04857345i #>  #> $co #>               [,1]                    [,2]                    [,3] #> [1,] -0.1006209+0i -0.57104039+0.47045921i -0.57104039-0.47045921i #> [2,] -0.9142693+0i  0.00395218+0.04857345i  0.00395218-0.04857345i #>  #> $mo.col #> [1] 3 #>  #> $mat #>            [,1]          [,2]          [,3] #> [1,] 0.06821506 -9.988385e-03  5.244975e-01 #> [2,] 1.28090300 -5.798306e-01 -8.241258e-01 #> [3,] 1.00000000 -6.890707e-19 -3.187167e-17 #>  #> $pcfilter #>           [,1]       [,2]       [,3] #> [1,]  1.280903 -0.5798306 -0.8241258 #> [2,] -0.636429  0.8834189 -0.3790094 #>  mo <- cbind(c(1,1),rfi$pcfilter) mo #>      [,1]      [,2]       [,3]       [,4] #> [1,]    1  1.280903 -0.5798306 -0.8241258 #> [2,]    1 -0.636429  0.8834189 -0.3790094"},{"path":"https://geobosh.github.io/mcompanion/reference/spec_core.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameterise Jordan chains of multi-companion matrices — spec_core","title":"Parameterise Jordan chains of multi-companion matrices — spec_core","text":"Parameterise Jordan chains corresponding given eigenvalue   multi-companion matrix.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameterise Jordan chains of multi-companion matrices — spec_core","text":"","code":"spec_core(mo, evalue, heights, ubasis = NULL, uorth = NULL, evspace = NULL)"},{"path":"https://geobosh.github.io/mcompanion/reference/spec_core.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameterise Jordan chains of multi-companion matrices — spec_core","text":"mo multi-companion order, positive integer. evalue eigenvalue, real complex number. heights dimensions Jordan blocks evalue, vector positive     integers. ubasis basis universe, matrix. uorth orthogonal complement ubasis w.r.t. full core basis,     see Details. evspace space spanned eigenvectors, see Details.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_core.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parameterise Jordan chains of multi-companion matrices — spec_core","text":"spec_core prepares canonical representation parameters   multi-companion matrix coresponding eigenvalue. Roughly   speaking, free parameters represented NA's returned   object. -repeated eigenvalues parameterisation consists   eigenvalue seed parameters eigenvector. Even ,   uniqueness convention needs adopted. , general  parameterisation effectively terms   subspaces. TODO: Currently documented work   progress, working notes (rakopis:   \"technical details parameterisation mc-matrices\").","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_core.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameterise Jordan chains of multi-companion matrices — spec_core","text":"list representing parameterised chains corresponding   eigenvalue. Currently contains following elements: evalue  heights  co  core.vectors  param.tall  param.hang  generators","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_core.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parameterise Jordan chains of multi-companion matrices — spec_core","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_core.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameterise Jordan chains of multi-companion matrices — spec_core","text":"","code":"spec_core(4, 1, c(1,1,1,1)) #> $evalue #> [1] 1 #>  #> $heights #> [1] 1 1 1 1 #>  #> $co #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #> $core.vectors #> $core.vectors[[1]] #> $core.vectors[[1]]$tall #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #> $core.vectors[[1]]$hang #>      [,1] [,2] [,3] [,4] #> [1,]   NA   NA   NA   NA #> [2,]   NA   NA   NA   NA #> [3,]   NA   NA   NA   NA #> [4,]   NA   NA   NA   NA #>  #> $core.vectors[[1]]$both #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    0    0    0   NA   NA   NA   NA #> [2,]    0    1    0    0   NA   NA   NA   NA #> [3,]    0    0    1    0   NA   NA   NA   NA #> [4,]    0    0    0    1   NA   NA   NA   NA #>  #>  #>  #> $param.tall #> $param.tall[[1]] #> [1] NA #>  #>  #> $param.hang #> $param.hang[[1]] #>      [,1] [,2] [,3] [,4] #> [1,]   NA   NA   NA   NA #> [2,]   NA   NA   NA   NA #> [3,]   NA   NA   NA   NA #> [4,]   NA   NA   NA   NA #>  #>  #> $generators #> $generators[[1]] #> NULL #>  #>   spec_core(4, 1, c(2,1,1,1)) #> $evalue #> [1] 1 #>  #> $heights #> [1] 2 1 1 1 #>  #> $co #>      [,1] [,2] [,3] [,4] [,5] #> [1,] -Inf    0  Inf  Inf  Inf #> [2,] -Inf    0  Inf  Inf  Inf #> [3,] -Inf    0  Inf  Inf  Inf #> [4,] -Inf    0  Inf  Inf  Inf #>  #> $core.vectors #> $core.vectors[[1]] #> $core.vectors[[1]]$tall #>      [,1] #> [1,] -Inf #> [2,] -Inf #> [3,] -Inf #> [4,] -Inf #>  #> $core.vectors[[1]]$hang #>      [,1] [,2] [,3] #> [1,]  Inf  Inf  Inf #> [2,]  Inf  Inf  Inf #> [3,]  Inf  Inf  Inf #> [4,]  Inf  Inf  Inf #>  #> $core.vectors[[1]]$both #>      [,1] [,2] [,3] [,4] #> [1,] -Inf  Inf  Inf  Inf #> [2,] -Inf  Inf  Inf  Inf #> [3,] -Inf  Inf  Inf  Inf #> [4,] -Inf  Inf  Inf  Inf #>  #>  #> $core.vectors[[2]] #> $core.vectors[[2]]$tall #> [1] NA #>  #> $core.vectors[[2]]$hang #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #>  #> $core.vectors[[2]]$both #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #>  #>  #>  #> $param.tall #> $param.tall[[1]] #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA #>  #> $param.tall[[2]] #> [1] NA #>  #>  #> $param.hang #> $param.hang[[1]] #>      [,1] [,2] [,3] #> [1,]   NA   NA   NA #> [2,]   NA   NA   NA #> [3,]   NA   NA   NA #>  #> $param.hang[[2]] #>      [,1] #>  #>  #> $generators #> $generators[[1]] #> $generators[[1]]$param #> [1] \"tall\" #>  #> $generators[[1]]$tall #>      [,1] #> [1,] -Inf #> [2,] -Inf #> [3,] -Inf #> [4,] -Inf #>  #> $generators[[1]]$hang #>      [,1] [,2] [,3] #> [1,]  Inf  Inf  Inf #> [2,]  Inf  Inf  Inf #> [3,]  Inf  Inf  Inf #> [4,]  Inf  Inf  Inf #>  #> $generators[[1]]$universe #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #> $generators[[1]]$method #> [1] \"complement\" #>  #>  #> $generators[[2]] #> NULL #>  #>  spec_seeds1(c(2,2,2,2), 4) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    0    0    0    0    0    0    0 #> [2,]    0    0    1    0    0    0    0    0 #> [3,]    0    0    0    0    1    0    0    0 #> [4,]    0    0    0    0    0    0    1    0 spec_seeds1(c(2,1,1,1), 4) #>      [,1] [,2] [,3] [,4] [,5] #> [1,] -Inf    0  Inf  Inf  Inf #> [2,] -Inf    0  Inf  Inf  Inf #> [3,] -Inf    0  Inf  Inf  Inf #> [4,] -Inf    0  Inf  Inf  Inf spec_core(4, 1, c(2,1,1,1))$co #>      [,1] [,2] [,3] [,4] [,5] #> [1,] -Inf    0  Inf  Inf  Inf #> [2,] -Inf    0  Inf  Inf  Inf #> [3,] -Inf    0  Inf  Inf  Inf #> [4,] -Inf    0  Inf  Inf  Inf spec_core(4, 1, c(2,1,1,1))$generators #> [[1]] #> [[1]]$param #> [1] \"tall\" #>  #> [[1]]$tall #>      [,1] #> [1,] -Inf #> [2,] -Inf #> [3,] -Inf #> [4,] -Inf #>  #> [[1]]$hang #>      [,1] [,2] [,3] #> [1,]  Inf  Inf  Inf #> [2,]  Inf  Inf  Inf #> [3,]  Inf  Inf  Inf #> [4,]  Inf  Inf  Inf #>  #> [[1]]$universe #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #> [[1]]$method #> [1] \"complement\" #>  #>  #> [[2]] #> NULL #>"},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root0.html","id":null,"dir":"Reference","previous_headings":"","what":"Give the spectral parameters for zero eigenvalues of mc-matrices — spec_root0","title":"Give the spectral parameters for zero eigenvalues of mc-matrices — spec_root0","text":"Give spectral parameters zero eigenvalues   mc-matrices.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Give the spectral parameters for zero eigenvalues of mc-matrices — spec_root0","text":"","code":"spec_root0(dim, mo, mo.col)"},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root0.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Give the spectral parameters for zero eigenvalues of mc-matrices — spec_root0","text":"dim dimension matrix, positive integer. mo multi-companion order, positive integer. mo.col last non-zero column top mc-matrix,     non-negative integer.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root0.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Give the spectral parameters for zero eigenvalues of mc-matrices — spec_root0","text":"spec_root0 prepares structure zero roots   mc-matrix.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root0.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Give the spectral parameters for zero eigenvalues of mc-matrices — spec_root0","text":"list following components: mo multi-companion order ev.type type eigenvalues co.type used currently (:todo:) n.root number non-zero roots ev.abs absolute values roots ev.arg arguments eigenvalues (0 positive ev) block.length lengths Jordan blocks co.abs absolute values seed parameters co.arg arguments seed parameters (Hz: 0 positive; 1/2 negative) co0 redundant keep now.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root0.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Give the spectral parameters for zero eigenvalues of mc-matrices — spec_root0","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root0.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Give the spectral parameters for zero eigenvalues of mc-matrices — spec_root0","text":"","code":"spec_root0(4,2,3) #> $mo #> [1] 2 #>  #> $ev.type #> [1] \"r\" #>  #> $co.type #> [1] \"r\" #>  #> $n.root #> [1] 0 #>  #> $ev.abs #> [1] 0 #>  #> $ev.arg #> [1] 0 #>  #> $block.length #> [1] 1 #>  #> $co.abs #>      [,1] #> [1,]    0 #> [2,]    1 #>  #> $co.arg #>      [,1] #> [1,]    0 #> [2,]    0 #>  #> $co0 #>      [,1] #> [1,]    0 #> [2,]    1 #>  spec_root0(4,2,2) #> $mo #> [1] 2 #>  #> $ev.type #> [1] \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" #>  #> $n.root #> [1] 0 #>  #> $ev.abs #> [1] 0 0 #>  #> $ev.arg #> [1] 0 0 #>  #> $block.length #> [1] 1 1 #>  #> $co.abs #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> $co.arg #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #>  #> $co0 #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  spec_root0(4,2,1) #> $mo #> [1] 2 #>  #> $ev.type #> [1] \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" #>  #> $n.root #> [1] 0 #>  #> $ev.abs #> [1] 0 0 #>  #> $ev.arg #> [1] 0 0 #>  #> $block.length #> [1] 2 1 #>  #> $co.abs #>      [,1] [,2] [,3] #> [1,]    0    0    1 #> [2,]    1    0    0 #>  #> $co.arg #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #>  #> $co0 #>      [,1] [,2] [,3] #> [1,]    0    0    1 #> [2,]    1    0    0 #>  spec_root0(5,2,3) #> $mo #> [1] 2 #>  #> $ev.type #> [1] \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" #>  #> $n.root #> [1] 0 #>  #> $ev.abs #> [1] 0 0 #>  #> $ev.arg #> [1] 0 0 #>  #> $block.length #> [1] 1 1 #>  #> $co.abs #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> $co.arg #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #>  #> $co0 #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  spec_root1(4,2,2) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" #>  #> $n.root #> [1] 4 #>  #> $ev.abs #> [1] 1 1 #>  #> $ev.arg #> [1] 0 0 #>  #> $block.length #> [1] 2 2 #>  #> $co.abs #>      [,1] [,2] [,3] [,4] #> [1,]   NA    0   NA    0 #> [2,]   NA    0   NA    0 #> [3,]   NA    0   NA    0 #> [4,]   NA    0   NA    0 #>  #> $co.arg #>      [,1] [,2] [,3] [,4] #> [1,]   NA    0   NA    0 #> [2,]   NA    0   NA    0 #> [3,]   NA    0   NA    0 #> [4,]   NA    0   NA    0 #>  #> $co1 #>      [,1] [,2] [,3] [,4] #> [1,]   NA    0   NA    0 #> [2,]   NA    0   NA    0 #> [3,]   NA    0   NA    0 #> [4,]   NA    0   NA    0 #>   spec_root0(6,4,2) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $n.root #> [1] 0 #>  #> $ev.abs #> [1] 0 0 0 0 #>  #> $ev.arg #> [1] 0 0 0 0 #>  #> $block.length #> [1] 1 1 1 1 #>  #> $co.abs #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #> $co.arg #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $co0 #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  spec_root0(6,4,4) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" #>  #> $n.root #> [1] 0 #>  #> $ev.abs #> [1] 0 0 #>  #> $ev.arg #> [1] 0 0 #>  #> $block.length #> [1] 1 1 #>  #> $co.abs #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    1    0 #> [4,]    0    1 #>  #> $co.arg #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    0 #>  #> $co0 #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    1    0 #> [4,]    0    1 #>  spec_root0(10,4,8) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" #>  #> $n.root #> [1] 0 #>  #> $ev.abs #> [1] 0 0 #>  #> $ev.arg #> [1] 0 0 #>  #> $block.length #> [1] 1 1 #>  #> $co.abs #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    1    0 #> [4,]    0    1 #>  #> $co.arg #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    0 #>  #> $co0 #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    1    0 #> [4,]    0    1 #>"},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root1.html","id":null,"dir":"Reference","previous_headings":"","what":"Give the spectral parameters for eigenvalues  of mc-matrices\n  equal to one — spec_root1","title":"Give the spectral parameters for eigenvalues  of mc-matrices\n  equal to one — spec_root1","text":"Give spectral parameters eigenvalues    mc-matrices equal one.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Give the spectral parameters for eigenvalues  of mc-matrices\n  equal to one — spec_root1","text":"","code":"spec_root1(mo, root1 = numeric(0), iorder = 0, siorder = 0)"},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Give the spectral parameters for eigenvalues  of mc-matrices\n  equal to one — spec_root1","text":"mo mc order. root1 Jordan block lengths unit roots, vector     positive integer numbers. iorder order integration, non-negative integer. siorder order seasonal integration, non-negative integer.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Give the spectral parameters for eigenvalues  of mc-matrices\n  equal to one — spec_root1","text":"specifications given root1, iorder   siorder combined spectral parameters prepared. principle, argument root1 sufficient, two   convenient specification integration seasonal   integration. TODO: rename argument root1!","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Give the spectral parameters for eigenvalues  of mc-matrices\n  equal to one — spec_root1","text":"list following components: mo multi-companion order ev.type type eigenvalues co.type used currently (:todo:) n.root number non-zero roots ev.abs absolute values roots ev.arg arguments eigenvalues (0 positive ev) block.length lengths Jordan blocks co.abs absolute values seed parameters co.arg arguments seed parameters (Hz: 0 positive; 1/2 negative) co1 temporary hack; TODO: check calling code     remove !","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root1.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Give the spectral parameters for eigenvalues  of mc-matrices\n  equal to one — spec_root1","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/spec_root1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Give the spectral parameters for eigenvalues  of mc-matrices\n  equal to one — spec_root1","text":"","code":"spec_root1(4, root1 = 1) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" #>  #> $co.type #> [1] \"r\" #>  #> $n.root #> [1] 1 #>  #> $ev.abs #> [1] 1 #>  #> $ev.arg #> [1] 0 #>  #> $block.length #> [1] 1 #>  #> $co.abs #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA #>  #> $co.arg #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA #>  #> $co1 #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA #>  spec_root1(4, root1 = c(1,0,0,0))  # same #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" #>  #> $co.type #> [1] \"r\" #>  #> $n.root #> [1] 1 #>  #> $ev.abs #> [1] 1 #>  #> $ev.arg #> [1] 0 #>  #> $block.length #> [1] 1 #>  #> $co.abs #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA #>  #> $co.arg #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA #>  #> $co1 #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA #>  spec_root1(4, iorder = 1)          # same #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" #>  #> $co.type #> [1] \"r\" #>  #> $n.root #> [1] 1 #>  #> $ev.abs #> [1] 1 #>  #> $ev.arg #> [1] 0 #>  #> $block.length #> [1] 1 #>  #> $co.abs #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA #>  #> $co.arg #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA #>  #> $co1 #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA #>   spec_root1(4, root1 = 2) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" #>  #> $co.type #> [1] \"r\" #>  #> $n.root #> [1] 2 #>  #> $ev.abs #> [1] 1 #>  #> $ev.arg #> [1] 0 #>  #> $block.length #> [1] 2 #>  #> $co.abs #>      [,1] [,2] #> [1,]   NA    0 #> [2,]   NA    0 #> [3,]   NA    0 #> [4,]   NA    0 #>  #> $co.arg #>      [,1] [,2] #> [1,]   NA    0 #> [2,]   NA    0 #> [3,]   NA    0 #> [4,]   NA    0 #>  #> $co1 #>      [,1] [,2] #> [1,]   NA    0 #> [2,]   NA    0 #> [3,]   NA    0 #> [4,]   NA    0 #>  spec_root1(4, root1 = c(2,0,0,0))  # same #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" #>  #> $co.type #> [1] \"r\" #>  #> $n.root #> [1] 2 #>  #> $ev.abs #> [1] 1 #>  #> $ev.arg #> [1] 0 #>  #> $block.length #> [1] 2 #>  #> $co.abs #>      [,1] [,2] #> [1,]   NA    0 #> [2,]   NA    0 #> [3,]   NA    0 #> [4,]   NA    0 #>  #> $co.arg #>      [,1] [,2] #> [1,]   NA    0 #> [2,]   NA    0 #> [3,]   NA    0 #> [4,]   NA    0 #>  #> $co1 #>      [,1] [,2] #> [1,]   NA    0 #> [2,]   NA    0 #> [3,]   NA    0 #> [4,]   NA    0 #>  spec_root1(4, iorder = 2)          # same #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" #>  #> $co.type #> [1] \"r\" #>  #> $n.root #> [1] 2 #>  #> $ev.abs #> [1] 1 #>  #> $ev.arg #> [1] 0 #>  #> $block.length #> [1] 2 #>  #> $co.abs #>      [,1] [,2] #> [1,]   NA    0 #> [2,]   NA    0 #> [3,]   NA    0 #> [4,]   NA    0 #>  #> $co.arg #>      [,1] [,2] #> [1,]   NA    0 #> [2,]   NA    0 #> [3,]   NA    0 #> [4,]   NA    0 #>  #> $co1 #>      [,1] [,2] #> [1,]   NA    0 #> [2,]   NA    0 #> [3,]   NA    0 #> [4,]   NA    0 #>   spec_root1(4, root1 = c(1,1,1,1)) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $n.root #> [1] 4 #>  #> $ev.abs #> [1] 1 1 1 1 #>  #> $ev.arg #> [1] 0 0 0 0 #>  #> $block.length #> [1] 1 1 1 1 #>  #> $co.abs #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #> $co.arg #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $co1 #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  spec_root1(4, siorder = 1)          # same #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $n.root #> [1] 4 #>  #> $ev.abs #> [1] 1 1 1 1 #>  #> $ev.arg #> [1] 0 0 0 0 #>  #> $block.length #> [1] 1 1 1 1 #>  #> $co.abs #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #> $co.arg #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $co1 #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>   spec_root1(4, root1 = c(2,2,2,2)) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $n.root #> [1] 8 #>  #> $ev.abs #> [1] 1 1 1 1 #>  #> $ev.arg #> [1] 0 0 0 0 #>  #> $block.length #> [1] 2 2 2 2 #>  #> $co.abs #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    0    0    0    0    0    0    0 #> [2,]    0    0    1    0    0    0    0    0 #> [3,]    0    0    0    0    1    0    0    0 #> [4,]    0    0    0    0    0    0    1    0 #>  #> $co.arg #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    0    0    0    0    0    0    0    0 #> [2,]    0    0    0    0    0    0    0    0 #> [3,]    0    0    0    0    0    0    0    0 #> [4,]    0    0    0    0    0    0    0    0 #>  #> $co1 #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    0    0    0    0    0    0    0 #> [2,]    0    0    1    0    0    0    0    0 #> [3,]    0    0    0    0    1    0    0    0 #> [4,]    0    0    0    0    0    0    1    0 #>  spec_root1(4, siorder = 2)          # same #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $n.root #> [1] 8 #>  #> $ev.abs #> [1] 1 1 1 1 #>  #> $ev.arg #> [1] 0 0 0 0 #>  #> $block.length #> [1] 2 2 2 2 #>  #> $co.abs #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    0    0    0    0    0    0    0 #> [2,]    0    0    1    0    0    0    0    0 #> [3,]    0    0    0    0    1    0    0    0 #> [4,]    0    0    0    0    0    0    1    0 #>  #> $co.arg #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    0    0    0    0    0    0    0    0 #> [2,]    0    0    0    0    0    0    0    0 #> [3,]    0    0    0    0    0    0    0    0 #> [4,]    0    0    0    0    0    0    0    0 #>  #> $co1 #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    0    0    0    0    0    0    0 #> [2,]    0    0    1    0    0    0    0    0 #> [3,]    0    0    0    0    1    0    0    0 #> [4,]    0    0    0    0    0    0    1    0 #>    spec_root1(4, root1 = c(2,1,1,1)) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $n.root #> [1] 5 #>  #> $ev.abs #> [1] 1 1 1 1 #>  #> $ev.arg #> [1] 0 0 0 0 #>  #> $block.length #> [1] 2 1 1 1 #>  #> $co.abs #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  Inf    0  Inf  Inf  Inf #> [2,]  Inf    0  Inf  Inf  Inf #> [3,]  Inf    0  Inf  Inf  Inf #> [4,]  Inf    0  Inf  Inf  Inf #>  #> $co.arg #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.5    0    0    0    0 #> [2,]  0.5    0    0    0    0 #> [3,]  0.5    0    0    0    0 #> [4,]  0.5    0    0    0    0 #>  #> $co1 #>      [,1] [,2] [,3] [,4] [,5] #> [1,] -Inf    0  Inf  Inf  Inf #> [2,] -Inf    0  Inf  Inf  Inf #> [3,] -Inf    0  Inf  Inf  Inf #> [4,] -Inf    0  Inf  Inf  Inf #>  spec_root1(4, iorder = 1, siorder = 1) # same #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" \"r\" \"r\" #>  #> $n.root #> [1] 5 #>  #> $ev.abs #> [1] 1 1 1 1 #>  #> $ev.arg #> [1] 0 0 0 0 #>  #> $block.length #> [1] 2 1 1 1 #>  #> $co.abs #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  Inf    0  Inf  Inf  Inf #> [2,]  Inf    0  Inf  Inf  Inf #> [3,]  Inf    0  Inf  Inf  Inf #> [4,]  Inf    0  Inf  Inf  Inf #>  #> $co.arg #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.5    0    0    0    0 #> [2,]  0.5    0    0    0    0 #> [3,]  0.5    0    0    0    0 #> [4,]  0.5    0    0    0    0 #>  #> $co1 #>      [,1] [,2] [,3] [,4] [,5] #> [1,] -Inf    0  Inf  Inf  Inf #> [2,] -Inf    0  Inf  Inf  Inf #> [3,] -Inf    0  Inf  Inf  Inf #> [4,] -Inf    0  Inf  Inf  Inf #>    spec_root1(4, root1 = c(2,1)) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" #>  #> $n.root #> [1] 3 #>  #> $ev.abs #> [1] 1 1 #>  #> $ev.arg #> [1] 0 0 #>  #> $block.length #> [1] 2 1 #>  #> $co.abs #>      [,1] [,2] [,3] #> [1,]   NA   NA   NA #> [2,]   NA   NA   NA #> [3,]   NA   NA   NA #> [4,]   NA   NA   NA #>  #> $co.arg #>      [,1] [,2] [,3] #> [1,]   NA   NA   NA #> [2,]   NA   NA   NA #> [3,]   NA   NA   NA #> [4,]   NA   NA   NA #>  #> $co1 #>      [,1] [,2] [,3] #> [1,]   NA   NA   NA #> [2,]   NA   NA   NA #> [3,]   NA   NA   NA #> [4,]   NA   NA   NA #>  spec_root1(4, root1 = c(2,1,1)) #> $mo #> [1] 4 #>  #> $ev.type #> [1] \"r\" \"r\" \"r\" #>  #> $co.type #> [1] \"r\" \"r\" \"r\" #>  #> $n.root #> [1] 4 #>  #> $ev.abs #> [1] 1 1 1 #>  #> $ev.arg #> [1] 0 0 0 #>  #> $block.length #> [1] 2 1 1 #>  #> $co.abs #>      [,1] [,2] [,3] [,4] #> [1,]   NA   NA   NA   NA #> [2,]   NA   NA   NA   NA #> [3,]   NA   NA   NA   NA #> [4,]   NA   NA   NA   NA #>  #> $co.arg #>      [,1] [,2] [,3] [,4] #> [1,]   NA   NA   NA   NA #> [2,]   NA   NA   NA   NA #> [3,]   NA   NA   NA   NA #> [4,]   NA   NA   NA   NA #>  #> $co1 #>      [,1] [,2] [,3] [,4] #> [1,]   NA   NA   NA   NA #> [2,]   NA   NA   NA   NA #> [3,]   NA   NA   NA   NA #> [4,]   NA   NA   NA   NA #>"},{"path":"https://geobosh.github.io/mcompanion/reference/spec_seeds1.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate seed parameters for unit mc-eigenvectors — spec_seeds1","title":"Generate seed parameters for unit mc-eigenvectors — spec_seeds1","text":"Generates seed parameters mc-eigenvectors corresponding unit   roots.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_seeds1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate seed parameters for unit mc-eigenvectors — spec_seeds1","text":"","code":"spec_seeds1(len.block, mo)"},{"path":"https://geobosh.github.io/mcompanion/reference/spec_seeds1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate seed parameters for unit mc-eigenvectors — spec_seeds1","text":"len.block lengths Jordan blocks, vector positive integers. mo multi-companion order.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_seeds1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate seed parameters for unit mc-eigenvectors — spec_seeds1","text":"Creates matrix seed parameters corresponding unit eigenvalues   multi-companion matrix multi-companion order mo.   len.block gives sizes Jordan blocks corresponding   eigenvalues equal one. general, entries filled NA's   configurations (even ) entries uniquely   determined linear transformation. cases   ``canonical'' choice made. generated seed parameters can considered \"top\"   \"bottom\", needed. (TODO: check claim,   forgotten details think reason   necessary argument dimension matrix). codespec_seeds1 can used model fitting functions prepare   parameters estimation see spec_root1   mcSpec comprehensive treatment.","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_seeds1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate seed parameters for unit mc-eigenvectors — spec_seeds1","text":"matrix mo rows sum(len.block) columns","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_seeds1.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate seed parameters for unit mc-eigenvectors — spec_seeds1","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/mcompanion/reference/spec_seeds1.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate seed parameters for unit mc-eigenvectors — spec_seeds1","text":"TODO: treatment ``canonical'' cases incomplete, see also   comments source code function. TODO: explain Inf -Inf output entries   configurations (e.g. last example ). \"co\" name spec_seeds1 short coefficient.","code":""},{"path":[]},{"path":"https://geobosh.github.io/mcompanion/reference/spec_seeds1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate seed parameters for unit mc-eigenvectors — spec_seeds1","text":"","code":"spec_seeds1(c(1), mo = 4)       # NA's #>      [,1] #> [1,]   NA #> [2,]   NA #> [3,]   NA #> [4,]   NA spec_seeds1(c(1,1), mo = 4)     # NA's #>      [,1] [,2] #> [1,]   NA   NA #> [2,]   NA   NA #> [3,]   NA   NA #> [4,]   NA   NA spec_seeds1(c(1,1,1), mo = 4)   # NA's (but for parameterisation #>      [,1] [,2] [,3] #> [1,]   NA   NA   NA #> [2,]   NA   NA   NA #> [3,]   NA   NA   NA #> [4,]   NA   NA   NA                             #     a different approach is used) spec_seeds1(c(1,1,1,1), mo = 4) # identity matrix but other bases are good too #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 spec_seeds1(c(2,2,2,2), mo = 4) # no NA's, tops of gen.evecs can be chosen 0 #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    0    0    0    0    0    0    0 #> [2,]    0    0    1    0    0    0    0    0 #> [3,]    0    0    0    0    1    0    0    0 #> [4,]    0    0    0    0    0    0    1    0 spec_seeds1(c(2,1,1,1), mo = 4) # (can be improved) #>      [,1] [,2] [,3] [,4] [,5] #> [1,] -Inf    0  Inf  Inf  Inf #> [2,] -Inf    0  Inf  Inf  Inf #> [3,] -Inf    0  Inf  Inf  Inf #> [4,] -Inf    0  Inf  Inf  Inf spec_seeds1(c(2,1), mo = 4)     # NA's #>      [,1] [,2] [,3] #> [1,]   NA   NA   NA #> [2,]   NA   NA   NA #> [3,]   NA   NA   NA #> [4,]   NA   NA   NA"}]
